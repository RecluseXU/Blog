<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Javascript-Babel-traverse-NodePath.evaluate方法增强</title>
    <link href="/post/undefined/"/>
    <url>/post/undefined/</url>
    
    <content type="html"><![CDATA[<p><a href=""><code>NodePath.evaluate()</code></a> 方法，可以帮我们处理 “1|3|5|7|9”.slice(“|”),但是不支持对 parseInt 等全局函数的处理，因此我们可以修改部分源码，让其支持即可。</p><p>其实很简单，打开node_modules@babel\traverse\lib\path\evaluation.js 文件 ，看看他都支持哪些，往后面添加即可。</p><p>主要是这行代码:</p><p>const VALID_CALLEES = [“String”, “Number”, “Math”];</p><p>它只处理了这三种，我们可以往后面添加想处理的全局函数即可。比如你想要支持 parseInt 函数，只需将其修改:</p><p>const VALID_CALLEES = [“String”, “Number”, “Math”，”parseInt”];</p>]]></content>
    
    
    
    <tags>
      
      <tag>Babel</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>域名-DomainName-意义-购买-解析-备案</title>
    <link href="/post/e5cd2b3/"/>
    <url>/post/e5cd2b3/</url>
    
    <content type="html"><![CDATA[<h1 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h1><h2 id="基础信息"><a href="#基础信息" class="headerlink" title="基础信息"></a>基础信息</h2><p>网域名称（英语：Domain Name，简称：Domain），简称 <strong>域名</strong>、<strong>网域</strong>，是由一串用点分隔的字符组成的互联网上某一台计算机或计算机组的名称，用于在数据传输时标识计算机的电子方位  </p><h2 id="意义、特点、限制"><a href="#意义、特点、限制" class="headerlink" title="意义、特点、限制"></a>意义、特点、限制</h2><h3 id="意义"><a href="#意义" class="headerlink" title="意义"></a><strong>意义</strong></h3><p>域名存在的意义是为了方便记忆 <strong>IP地址</strong>  </p><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a><strong>特性</strong></h3><p>域名具有唯一性<br>在资源更改 <strong>IP地址</strong> 时，只需要进行新IP地址与恒定域名的转换，即可实现将资源移动到网络地址拓扑中的不同物理位置  </p><h3 id="限制"><a href="#限制" class="headerlink" title="限制"></a><strong>限制</strong></h3><p>完整域名的所有字符加起来不得超过253个ASCII字符的总长度<br>当每一级都使用单个字符时，限制为127个级别(127个字符加上126个点的总长度为253)  </p><h2 id="发展过程"><a href="#发展过程" class="headerlink" title="发展过程"></a>发展过程</h2><ol><li><p>使用 <strong>Hosts文件</strong> 管理<br>这种方式在网络小，计算机数量也少的情况下能解决问题，但随着接入网络的计算机越来越多，频繁的更新 <strong>Hosts文件</strong> 会造成问题  </p></li><li><p>域名解析服务 与 域名 被发明<br>1983年，保罗·莫卡派乔斯发明了域名解析服务和域名系统，随后它们被引入<code>ARPANET</code><br>原始的技术规范在882号和883号因特网标准草案中发布  </p></li><li><p>修正技术规范<br>1987年发布的第1034和1035号草案修正了一些技术规范，并废除了之前的第882和883号草案<br>此之后对因特网标准草案的修改基本上没有涉及到域名系统技术规范部分的改动。</p></li></ol><h2 id="ICANN"><a href="#ICANN" class="headerlink" title="ICANN"></a>ICANN</h2><blockquote><p>维基百科：<a href="https://zh.wikipedia.org/wiki/%E4%BA%92%E8%81%94%E7%BD%91%E5%90%8D%E7%A7%B0%E4%B8%8E%E6%95%B0%E5%AD%97%E5%9C%B0%E5%9D%80%E5%88%86%E9%85%8D%E6%9C%BA%E6%9E%84">https://zh.wikipedia.org/wiki/%E4%BA%9……</a>  </p></blockquote><p>互联网名称与数字地址分配机构（Internet Corporation for Assigned Names and Numbers），简称 <strong>ICANN</strong>，是位于美国加利福尼亚的非营利社团<br>主要由互联网协会的成员组成，创建于1998年9月18日，目的是接管包括管理域名和IP地址的分配等与互联网相关的任务  </p><h2 id="顶级域"><a href="#顶级域" class="headerlink" title="顶级域"></a>顶级域</h2><p>顶级域（英语：Top-level domains，缩写：TLD）是域名中最高的一级，每个域名都以顶级域结尾  </p><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><table><thead><tr><th>名称</th><th>缩写</th><th>信息</th></tr></thead><tbody><tr><td>国家及地区双字代码顶级域<br>Country Code Top-level domains</td><td>ccTLD</td><td>最初定义类型之一<br>基于 ISO-3166 规定的国家/地区双字缩写代码</td></tr><tr><td>通用顶级域<br>general Top-level domains</td><td>gTLD</td><td>最初定义类型之一<br>代表了一组名称和多个组织</td></tr><tr><td>新通用顶级域<br>New general Top-level domains</td><td>NewgTLD</td><td>2011年，新的TLD命名政策被 <strong>ICANN</strong> 批准<br>2012年初，开始实施<br>现在见到的那些奇怪的顶级域(比如说中文顶级域名)为此类</td></tr></tbody></table><h4 id="gTLD代表意义"><a href="#gTLD代表意义" class="headerlink" title="gTLD代表意义"></a>gTLD代表意义</h4><table><thead><tr><th>域名</th><th>信息</th></tr></thead><tbody><tr><td><code>.gov</code></td><td>政府，现被用于美国政府的网站</td></tr><tr><td><code>.edu</code></td><td>教育机构，现被用于美国各类学校的网站</td></tr><tr><td><code>.com</code></td><td>商业，现在成为全球注册量最大、最通用的域名</td></tr><tr><td><code>.mil</code></td><td>军事，现被用于美国国防部及其附属机构的网站</td></tr><tr><td><code>.org</code></td><td>非营利组织</td></tr><tr><td><code>.net</code></td><td>网络，过去时被定位为网络基础服务提供商</td></tr><tr><td><code>.int</code></td><td>国际组织</td></tr></tbody></table><h2 id="子域名"><a href="#子域名" class="headerlink" title="子域名"></a>子域名</h2><p>子域名将顶级域名进一步细分<br>域名层次结构中，顶级域名下面是二级域名，它位于顶级域名的左侧<br>更下级的域名也类似，从右侧到左侧，隔一个点依次下降一层  </p><h2 id="国际化域名"><a href="#国际化域名" class="headerlink" title="国际化域名"></a>国际化域名</h2><blockquote><p>传统域名系统中允许的字符集基于 <strong>ASCII</strong>，只支持英文字母(不区分大小写)、数字和连字符(-)，而不允许其他语言的文字  </p></blockquote><p>国际化域名（英语：Internationalized Domain Name，缩写：IDN）系统<br>该系统将其他语言对应的 <strong>Unicode</strong> 字符串，转换为一个名为 <strong>Punycode</strong> 的编码字符集<br>转换结果符合传统域名的规范，这使得其他语言的文字可以注册域名，并在浏览器中访问  </p><h2 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a>域名解析</h2><p>域名解析包括正向解析和反向解析  </p><h3 id="正向解析"><a href="#正向解析" class="headerlink" title="正向解析"></a>正向解析</h3><p>正向解析是把域名转换为IP地址的过程<br>因为机器间互相只认IP地址，所以需要把域名转换为IP地址<br>这需要由专门的 <strong>域名解析服务器</strong> 来完成，整个过程自动进行  </p><p>DNS服务器可接受两种类型的解析，分别是 <strong>递归解析</strong> 和 <strong>反复解析</strong><br>两者的区别在于，前者查询失败一般直接返回失败消息，后者会继续查询一些其他的服务器  </p><h3 id="反向解析"><a href="#反向解析" class="headerlink" title="反向解析"></a>反向解析</h3><p>反向解析比较罕见，是把IP地址转换为域名的过程<br><strong>.arpa</strong> 顶级域名专门被用于这类用途  </p><h2 id="虚构域名"><a href="#虚构域名" class="headerlink" title="虚构域名"></a>虚构域名</h2><p>虚构域名是用于小说或流行文化，或用于示例、测试的域名，用于指代实际上不存在的域名<br>规范的虚构域名是 <strong>example.com</strong> 和 <strong>example.org</strong> 以及 <strong>.测试</strong> 等顶级域名  </p><h2 id="域名数据库查询-WHOIS"><a href="#域名数据库查询-WHOIS" class="headerlink" title="域名数据库查询 WHOIS"></a>域名数据库查询 WHOIS</h2><p>一个域名的所有者可以通过查询 <strong>WHOIS数据库</strong> 而被找到<br>对于大多数根域名服务器，<strong>基本的WHOIS</strong> 由 <strong>ICANN</strong> 维护，而 **WHOIS的细节 ** 则由控制那个域的域注册机构维护  </p><p>对于240多个国家代码顶级域名（<strong>ccTLDs</strong>），通常由该域名权威注册机构负责维护 <strong>WHOIS</strong>  </p><blockquote><p>例如  </p><ul><li><strong>.CN</strong> 域名的WHOIS维护<br>中国互联网络信息中心（China Internet Network Information Center）负责</li><li><strong>.HK</strong> 域名的WHOIS维护<br>香港互联网注册管理有限公司（Hong Kong Internet Registration Corporation Limited）负责  </li><li><strong>.TW</strong> 域名的WHOIS维护<br>台湾网络信息中心（Taiwan Network Information Center）负责  </li></ul></blockquote><h2 id="权力滥用"><a href="#权力滥用" class="headerlink" title="权力滥用"></a>权力滥用</h2><p>对域名的控制权本身就是一种权力<br>权力存在的地方，就必定会有滥用的情况  </p><ul><li><p><strong>VeriSign</strong> 重定向搜索事件  </p></li><li><p>*.com<strong>的域名注册管理机构 **VeriSign</strong> ，开发了<strong>VeriSign Site Finder</strong>系统<br>系统将所有未注册的 <strong>.com</strong> 和 <strong>.net</strong> 域名重定向到 <strong>VeriSign</strong>的搜索网页<br>尽管此举在社会上受到非常多的批评，但 <strong>VeriSign</strong> 无动于衷。直到 <strong>ICANN</strong> 威胁要撤销其管理 <strong>.com</strong> 域名的资格授权之后，<strong>VeriSign</strong> 才不情愿地撤下 <strong>Site Finder</strong> 系统  </p></li><li><p>美国注册的域名为何没有**.us**  </p><blockquote><p>这其实是过去美国政府操作的结果  </p></blockquote><p>20世纪80年代，互联网域名与地址的管理权一直由美国政府垄断，它自行定义了一些域名为自己所用    </p><blockquote><p>比如将 <strong>.edu</strong>、**.mil** 、**.gov** 等域名用作美国自己使用，而不用 <strong>.edu.us</strong> 二级域名）</p></blockquote><p>1998年，美国政府与 <strong>ICANN</strong> 签订合同，授权由 <strong>ICANN</strong> 负责协调管理, 但美国政府仍然拥有对域名的控制权，并有时进行干涉<br>2013年，美国曝出的“棱镜门”丑闻引发了风波。“棱镜门”丑闻曝光带来的压力，促使奥巴马政府最终决定放弃对 <strong>ICANN</strong> 的权力<br>2016年10月，美国政府机构正式将互联网域名的管理权完全移交给 <strong>ICANN</strong>，才结束了对域名管理近20年的垄断  </p></li></ul><ul><li>使你无法访问外网的 <strong>墙</strong><br>维基百科：<a href="https://zh.wikipedia.org/wiki/%E9%98%B2%E7%81%AB%E9%95%BF%E5%9F%8E">https://zh.wikipedia.org/wiki/%E9%98%……</a>  </li></ul><p><a id="DNS"></a></p><h1 id="域名服务器-DNS"><a href="#域名服务器-DNS" class="headerlink" title="域名服务器 DNS"></a>域名服务器 DNS</h1><h2 id="域名记录类型"><a href="#域名记录类型" class="headerlink" title="域名记录类型"></a>域名记录类型</h2><p>DNS系统中，常见的资源记录类型有：</p><table><thead><tr><th>记录名称</th><th>类型</th><th>定义标准</th><th>信息</th></tr></thead><tbody><tr><td>主机记录</td><td>A记录</td><td>RFC 1035定义</td><td>A记录是用于名称解析的重要记录<br>它将特定的主机名映射到对应主机的IP地址上</td></tr><tr><td>别名记录</td><td>CNAME记录</td><td>RFC 1035定义</td><td>CNAME记录用于将某个别名指向到某个A记录上<br>这样就不需要再为某个新名字另外创建一条新的A记录</td></tr><tr><td>IPv6主机记录</td><td>AAAA记录</td><td>RFC 3596定义</td><td>与A记录类似，用于将特定的主机名映射到一个主机的 IPv6 地址</td></tr><tr><td>服务位置记录</td><td>SRV记录</td><td>RFC 2782定义</td><td>用于定义提供特定服务的服务器的位置，如主机（hostname），端口（port number）等</td></tr><tr><td>域名服务器记录</td><td>NS记录</td><td></td><td>用来指定该域名由哪个 DNS服务器 来进行解析<br>注册域名时，总有默认的DNS服务器，每个注册的域名都是由一个 DNS域名服务器 来进行解析的<br>DNS服务器的NS记录地址一般以以下的形式出现： ns1.domain.com、ns2.domain.com等</td></tr><tr><td>NAPTR记录</td><td></td><td>RFC 3403定义</td><td>它提供了正则表达式方式去映射一个域名<br>NAPTR记录非常著名的一个应用是用于ENUM查询</td></tr><tr><td>邮件交换记录</td><td>MX记录</td><td>RFC 1035定义</td><td>用于指定负责处理发往收件人域名的邮件服务器<br>MX记录允许设置一个优先级，当多个邮件服务器可用时，会根据该值决定投递邮件的服务器。简单邮件传输协议（SMTP）会根据MX记录的值来决定邮件的路由过程。</td></tr></tbody></table><blockquote><p>类型大全：<a href="https://zh.wikipedia.org/wiki/DNS%E8%AE%B0%E5%BD%95%E7%B1%BB%E5%9E%8B%E5%88%97%E8%A1%A8">https://zh.wikipedia.org/wiki/DNS%E8……</a>  </p></blockquote><h2 id="最常用类型"><a href="#最常用类型" class="headerlink" title="最常用类型"></a>最常用类型</h2><p>在域名解析控制台里，最常配置的是  </p><ul><li><code>A记录</code> 主机记录  </li><li><code>CNAME记录</code> 别名记录  </li></ul><p>这里用假用百度域名<code>baidu.com</code>和假定的服务器<code>192.168.1.2</code>来举例<br><code>A记录</code> 会作为主记录存在，可以利用域名直接指定  </p><blockquote><p>即<code>baidu.com</code>-A记录解析-&gt;<code>192.168.1.2</code>  </p></blockquote><p>但<code>baidu.com</code>并不是我们最常用的访问域名，我们最常用的访问域名是<code>www.baidu.com</code>，这里实际上并不是指定一个新的<code>A记录</code>，因为如果这样做。未来服务器IP改变的话，就需要更改大量的记录<br><code>CNAME记录</code> 就是用来处理这种情况的。记录可以将子域名<code>www.baidu.com</code>指定到<code>baidu.com</code>上  </p><blockquote><p>即<code>www.baidu.com</code>-CNAME记录解析-&gt;<code>baidu.com</code>-&gt;<code>A记录解析</code>-&gt;<code>192.168.1.2</code>  </p></blockquote><h1 id="域名购买-备案-使用"><a href="#域名购买-备案-使用" class="headerlink" title="域名购买-备案-使用"></a>域名购买-备案-使用</h1><h2 id="域名购买"><a href="#域名购买" class="headerlink" title="域名购买"></a>域名购买</h2><h3 id="确认需求"><a href="#确认需求" class="headerlink" title="确认需求"></a>确认需求</h3><p>一般而言，购买域名适用于部署网站的，当然你也能用来炒<br>如果是用于部署网站，那么最好在网站部署完成前一到半个月考虑域名的事情。买早了浪费，买迟了会被备案拖累  </p><h3 id="运营商选择"><a href="#运营商选择" class="headerlink" title="运营商选择"></a>运营商选择</h3><p>在购买之前需要选择一个运营商<br>不少云服务商也经营着域名相关的业务（例如：<a href="https://buy.cloud.tencent.com/domain">腾讯云</a>，<a href="https://wanwang.aliyun.com/domain/yumingheji">阿里云</a>）<br>销售策略也多为捆绑销售（买服务器送域名之类）  </p><h3 id="查询域名"><a href="#查询域名" class="headerlink" title="查询域名"></a>查询域名</h3><p>由于域名是唯一的，在购买之前需要知道你想要的域名是否已经被注册<br>这个运营商会提供查询服务<br><img src="/%E5%9F%9F%E5%90%8D-DomainName-%E6%84%8F%E4%B9%89-%E8%B4%AD%E4%B9%B0-%E8%A7%A3%E6%9E%90-%E5%A4%87%E6%A1%88/20201208025140801.png" alt="腾讯域名查询"><br>域名是可以买卖的，好的域名老早就被人抢注了  </p><h3 id="域名价格"><a href="#域名价格" class="headerlink" title="域名价格"></a>域名价格</h3><ul><li>查询得到的结果内会包含购买的价格信息，可以在不同运营商的平台上查询，货比三家  </li><li>一次性购买时间越长越便宜  </li><li>顶级域越奇怪约便宜  </li><li>域名越长越便宜  </li></ul><h3 id="购买域名"><a href="#购买域名" class="headerlink" title="购买域名"></a>购买域名</h3><p>购买域名需要填写一些个人信息<br>并不复杂  </p><h2 id="域名备案"><a href="#域名备案" class="headerlink" title="域名备案"></a>域名备案</h2><p>在你制作好了网站项目，部署好了以后，需要对域名进行备案<br>域名运营商会提供备案的渠道，你需要在渠道中填写一些信息<br>比如：</p><ul><li>网站名称  </li><li>域名  </li><li>网站描述  </li><li>域名控制台截图  </li><li>用于联系的手机号（需要两个号码）  </li><li>……  </li></ul><p>信息最终会提交到各省的管理部门进行审核  </p><h3 id="等待备案审核完成"><a href="#等待备案审核完成" class="headerlink" title="等待备案审核完成"></a>等待备案审核完成</h3><p>这个步骤会花费不少的时间。在不同的地区，审核时间会不一样<br>我在广州，花了12天。 有网友在北京，花了一个月 </p><p>在多天以后，会收到来自 <strong>工业和信息化部网站备案系统邮件通知</strong>，说明备案成功<br><img src="/%E5%9F%9F%E5%90%8D-DomainName-%E6%84%8F%E4%B9%89-%E8%B4%AD%E4%B9%B0-%E8%A7%A3%E6%9E%90-%E5%A4%87%E6%A1%88/20201208045759316.png"><br>随后，也会收到来自服务商的通知<br><img src="/%E5%9F%9F%E5%90%8D-DomainName-%E6%84%8F%E4%B9%89-%E8%B4%AD%E4%B9%B0-%E8%A7%A3%E6%9E%90-%E5%A4%87%E6%A1%88/20201208050039061.png">  </p><p>它会提示你  </p><ul><li>30天内常住地公安机关备案  </li><li>将备案信息html插入到网站首页  </li></ul><p>去公安机关进行备案后，html信息也会给你，所以实际上只需要去公安机关备案即可  </p><h2 id="公安局备案"><a href="#公安局备案" class="headerlink" title="公安局备案"></a>公安局备案</h2><p>全国互联网安全管理服务平台：<a href="http://www.beian.gov.cn/portal/index">http://www.beian.gov.cn/portal/index</a>  </p><h3 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h3><p>访问以后需要注册<br><img src="/%E5%9F%9F%E5%90%8D-DomainName-%E6%84%8F%E4%B9%89-%E8%B4%AD%E4%B9%B0-%E8%A7%A3%E6%9E%90-%E5%A4%87%E6%A1%88/1.gif"><br>注册完以后，依然是点那个按钮来登录  </p><h3 id="创建主体"><a href="#创建主体" class="headerlink" title="创建主体"></a>创建主体</h3><p><img src="/%E5%9F%9F%E5%90%8D-DomainName-%E6%84%8F%E4%B9%89-%E8%B4%AD%E4%B9%B0-%E8%A7%A3%E6%9E%90-%E5%A4%87%E6%A1%88/20201208065102442.png"><br>需要填入很多信息  </p><h3 id="办理备案"><a href="#办理备案" class="headerlink" title="办理备案"></a>办理备案</h3><p><img src="/%E5%9F%9F%E5%90%8D-DomainName-%E6%84%8F%E4%B9%89-%E8%B4%AD%E4%B9%B0-%E8%A7%A3%E6%9E%90-%E5%A4%87%E6%A1%88/20201208065759604.png"><br>需要填入很多信息，注意与域名备案匹配<br>其中会有个点需要注意：域名证书  </p><blockquote><p>域名证书<br>虽然表单中域名证书并不是必填项，但你不填必定会不会通过审核<br>域名证书可以在域名控制台里下载到(一张图片)<br><img src="/%E5%9F%9F%E5%90%8D-DomainName-%E6%84%8F%E4%B9%89-%E8%B4%AD%E4%B9%B0-%E8%A7%A3%E6%9E%90-%E5%A4%87%E6%A1%88/20201209045557661.png">  </p></blockquote><p>申请提交完成后，能在首页查看到申请信息<br><img src="/%E5%9F%9F%E5%90%8D-DomainName-%E6%84%8F%E4%B9%89-%E8%B4%AD%E4%B9%B0-%E8%A7%A3%E6%9E%90-%E5%A4%87%E6%A1%88/20201208070043543.png">  </p><p>接下来就是等待审核的结果了，审核完成后（无论通过还是不通过）都会通过手机给你发短信进行通知<br>所以不必担心不知道结果  </p><h3 id="网站首页张贴指定HTML"><a href="#网站首页张贴指定HTML" class="headerlink" title="网站首页张贴指定HTML"></a>网站首页张贴指定HTML</h3><p>在通过审核后，可以在此处看到审核通过的信息<br><img src="/%E5%9F%9F%E5%90%8D-DomainName-%E6%84%8F%E4%B9%89-%E8%B4%AD%E4%B9%B0-%E8%A7%A3%E6%9E%90-%E5%A4%87%E6%A1%88/20201211040628850.png"><br>它会给你生成一小段的HTML引用信息<br><img src="/%E5%9F%9F%E5%90%8D-DomainName-%E6%84%8F%E4%B9%89-%E8%B4%AD%E4%B9%B0-%E8%A7%A3%E6%9E%90-%E5%A4%87%E6%A1%88/20201211041014061.png"><br>复制下来，将内容粘贴到网站首页就行  </p><h1 id="解析域名"><a href="#解析域名" class="headerlink" title="解析域名"></a>解析域名</h1><p>做了那麽多操作，但實際上還并沒有將域名用起來<br>不過設置解析并不是什麽困難的事情，也不需要花費什麽時間<br>進到域名控制台解析頁面裏<br><img src="/%E5%9F%9F%E5%90%8D-DomainName-%E6%84%8F%E4%B9%89-%E8%B4%AD%E4%B9%B0-%E8%A7%A3%E6%9E%90-%E5%A4%87%E6%A1%88/20201221080859208.png"><br>將主要需要解析的IP和端口號解析用擁有的域名進行解析就行<br><img src="/%E5%9F%9F%E5%90%8D-DomainName-%E6%84%8F%E4%B9%89-%E8%B4%AD%E4%B9%B0-%E8%A7%A3%E6%9E%90-%E5%A4%87%E6%A1%88/20201221081158804.png"><br>一般來説，域名解析用得最多的是A類型。具體可以參考上文的<a href="#DNS">解析類型</a>  </p><p>可以將更低級的域名解析到不同的 位置/端口，使得單個域名給多個服務器同時使用。他們之間并不會相互影響  </p><hr><p>参考  </p><ul><li><a href="https://zh.wikipedia.org/wiki/%E5%9F%9F%E5%90%8D">维基百科-域名</a>  </li><li><a href="https://cloud.tencent.com/document/product/243/19142?from=10680">腾讯云文档-公安局备案</a>  </li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>域名</tag>
      
      <tag>备案</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Javascript-Babel-API</title>
    <link href="/post/undefined/"/>
    <url>/post/undefined/</url>
    
    <content type="html"><![CDATA[<h1 id="API信息"><a href="#API信息" class="headerlink" title="API信息"></a>API信息</h1><p>這些記錄是我自行查閲文檔/源代碼，來進行編寫的<br>大多數都會編寫一個小例子來進行説明  </p><p>内容并不一定準確，要是發現有什麽問題，歡迎通過 <a href="https://github.com/RecluseXU">Github</a> 聯係我  </p><h1 id="babel-parse"><a href="#babel-parse" class="headerlink" title="@babel/parse"></a>@babel/parse</h1><h3 id="解析函数"><a href="#解析函数" class="headerlink" title="解析函数"></a>解析函数</h3><h4 id="babelParser-parse-code-options"><a href="#babelParser-parse-code-options" class="headerlink" title="babelParser.parse(code, [options])"></a>babelParser.parse(code, [options])</h4><p>将提供的代码作为一个完整的<code>ECMAScript</code>程序进行解析  </p><h4 id="babelParser-parseExpression-code-options"><a href="#babelParser-parseExpression-code-options" class="headerlink" title="babelParser.parseExpression(code, [options])"></a>babelParser.parseExpression(code, [options])</h4><p>用于解析单个<code>Expression</code>，性能比<code>parse()</code>要高  </p><h4 id="options-函数参数"><a href="#options-函数参数" class="headerlink" title="options 函数参数"></a>options 函数参数</h4><ul><li><p>allowImportExportEverywhere<br>默认情况下，<code>import</code> 和 <code>export</code> 声明语句只能出现在程序的最顶层<br>把这个设置为<code>true</code>，可以使得语句在任何地方都可以声明  </p></li><li><p>allowAwaitOutsideFunction<br>默认情况下，仅在 异步函数内部 或 启用<code>topLevelAwait插件</code>时 在模块的顶层内允许使用<code>await</code><br>把这个设置为<code>true</code>，可以使得语句在任何地方都可以声明  </p></li><li><p>allowReturnOutsideFunction<br>默认情况下，如果在顶层中使用<code>return</code>语句会引起错误<br>把这个设置为<code>true</code>，就不会报错  </p></li><li><p>allowSuperOutsideMethod<br>默认情况下，在类和对象方法之外不允许使用<code>super</code><br>把这个设置为<code>true</code>就可以声明  </p></li><li><p>allowUndeclaredExports<br>默认情况下，<code>export</code>一个在当前作用域下未声明的内容会报错<br>把这个设置为<code>true</code>就可以防止解析器过早地抛出未声明的错误  </p></li><li><p>createParenthesizedExpressions<br>默认情况下，<code>parser</code>会在<code>expression</code>节点设置<code>extra.parenthesized</code><br>把这个设置为<code>true</code>，则会设置<code>ParenthesizedExpression</code>AST节点  </p></li><li><p>errorRecovery<br>默认情况下，如果<code>Babel</code>发现一些 不正常的代码 就会抛出错误<br>把这个设置为<code>true</code>，则会在保存解析错误的同时继续解析代码，错误的记录将被保存在 最终生成的AST的<code>errors</code>属性中<br>注意，那些严重的错误依然会终止解析  </p></li><li><p>plugins<br>记录希望启动的插件的数组  </p></li><li><p>sourceType<br>代码的解析方式，你可以填入<code>&quot;script&quot;</code>（默认）,<code>&quot;module&quot;</code> 或 <code>&quot;unambiguous&quot;</code><br>如果设置为”unambiguous”，那么系统会根据ES6语法中的<code>imports</code>和<code>export</code>来判断是<code>&quot;module&quot;</code>还是<code>&quot;script&quot;</code>  </p></li><li><p>sourceFilename<br>将输出的AST节点与其源文件名相关联<br>在你处理多个文件时，这个功能会很有用  </p></li><li><p>startLine<br>默认情况下，第一行代码就是<code>line 1</code>。你可以传入一个数字，作为起始行数<br>这个功能在你整合其他插件的时候会很有用  </p></li><li><p>strictMode<br>默认情况下，只有在声明了”use strict”条件下，ECMAScript代码才会被严格解析<br>将此选项设置为<code>true</code>则始终以严格模式解析文件  </p></li><li><p>ranges<br>添加ranges属性到每一个节点中  </p><blockquote><p>ranges: [node.start, node.end]  </p></blockquote></li><li><p>tokens<br>将所有已经解析的<code>tokens</code>保存到<code>File</code>节点的<code>tokens</code>属性中  </p></li></ul><h2 id="输出-Output"><a href="#输出-Output" class="headerlink" title="输出 Output"></a>输出 Output</h2><p><code>Babel parser</code>是根据 <a href="https://github.com/babel/babel/tree/master/packages/babel-parser/ast/spec.md">Babel AST format</a> 创建AST的<br>而<code>Babel AST format</code>是基于 <a href="https://github.com/estree/estree">ESTree 规范</a> 建立的  </p><p><a href="https://github.com/estree/estree/blob/master/es5.md#literal">ESTree 代码生成对应节点文档</a><br><a href="https://github.com/babel/babel/blob/master/packages/babel-parser/ast/spec.md#stringliteral">Babel parser 代码生成对应节点文档</a></p><blockquote><p><code>Babel parser</code>与ESTree的不同之处  </p><ul><li>用<a href="https://github.com/babel/babel/tree/master/packages/babel-parser/ast/spec.md#stringliteral"><code>StringLiteral</code></a>, <a href="https://github.com/babel/babel/tree/master/packages/babel-parser/ast/spec.md#numericliteral"><code>NumericLiteral</code></a>, <a href="https://github.com/babel/babel/tree/master/packages/babel-parser/ast/spec.md#booleanliteral"><code>BooleanLiteral</code></a>, <a href="https://github.com/babel/babel/tree/master/packages/babel-parser/ast/spec.md#nullliteral"><code>NullLiteral</code></a>, <a href="https://github.com/babel/babel/tree/master/packages/babel-parser/ast/spec.md#regexpliteral"><code>RegExpLiteral</code></a>取代<a href="https://github.com/estree/estree/blob/master/es5.md#literal"><code>Literal</code></a>  </li><li>用 <a href="https://github.com/babel/babel/tree/master/packages/babel-parser/ast/spec.md#objectproperty"><code>ObjectProperty</code></a> 和 <a href="https://github.com/babel/babel/tree/master/packages/babel-parser/ast/spec.md#objectmethod"><code>ObjectMethod</code></a>取代<a href="https://github.com/estree/estree/blob/master/es5.md#property"><code>Property</code></a>  </li><li>用<a href="https://github.com/estree/estree/blob/master/es2015.md#methoddefinition"><code>MethodDefinition</code></a>取代<a href="https://github.com/babel/babel/tree/master/packages/babel-parser/ast/spec.md#classmethod"><code>ClassMethod</code></a></li><li><a href="https://github.com/babel/babel/tree/master/packages/babel-parser/ast/spec.md#programs"><code>Program</code></a> and <a href="https://github.com/babel/babel/tree/master/packages/babel-parser/ast/spec.md#blockstatement"><code>BlockStatement</code></a> 包含的<code>directives</code>用 <a href="https://github.com/babel/babel/tree/master/packages/babel-parser/ast/spec.md#directive"><code>Directive</code></a> 和 <a href="https://github.com/babel/babel/tree/master/packages/babel-parser/ast/spec.md#directiveliteral"><code>DirectiveLiteral</code></a>来填充  </li><li><a href="https://github.com/babel/babel/tree/master/packages/babel-parser/ast/spec.md#functionexpression"><code>FunctionExpression</code></a>中的 <a href="https://github.com/babel/babel/tree/master/packages/babel-parser/ast/spec.md#classmethod"><code>ClassMethod</code></a>, <a href="https://github.com/babel/babel/tree/master/packages/babel-parser/ast/spec.md#objectproperty"><code>ObjectProperty</code></a>,<a href="https://github.com/babel/babel/tree/master/packages/babel-parser/ast/spec.md#objectmethod"><code>ObjectMethod</code></a>属性被引入到<code>main方法</code>节点中  </li></ul></blockquote><h1 id="babel-generator"><a href="#babel-generator" class="headerlink" title="@babel/generator"></a>@babel/generator</h1><p>官方文档：<a href="https://babeljs.io/docs/en/babel-generator">https://babeljs.io/docs/en/babel-generator</a>    </p><h2 id="generate-ast-options-code"><a href="#generate-ast-options-code" class="headerlink" title="generate(ast,  options,  code);"></a>generate(ast,  options,  code);</h2><p>函数用于根据ast生成代码，可以传入一些参数  </p><h3 id="options-参数"><a href="#options-参数" class="headerlink" title="options 参数"></a>options 参数</h3><table><thead><tr><th>name 参数名</th><th>type 类型</th><th>default 默认值</th><th>description 描述</th></tr></thead><tbody><tr><td>auxiliaryCommentAfter</td><td>string</td><td></td><td>Optional 在输出文件内容末尾添加的注释块文字</td></tr><tr><td>auxiliaryCommentBefore</td><td>string</td><td></td><td>Optional 在输出文件内容头部添加的注释块文字</td></tr><tr><td>comments</td><td>boolean</td><td><code>true</code></td><td>输出内容是否包含注释</td></tr><tr><td>compact</td><td>boolean or <code>&#39;auto&#39;</code></td><td><code>opts.minified</code></td><td>是否不添加空格来让代码看起来紧密</td></tr><tr><td>concise</td><td>boolean</td><td><code>false</code></td><td>是否减少空格来让代码看起来紧凑一些<br>只是减少空格，而不是不添加</td></tr><tr><td>decoratorsBeforeExport</td><td>boolean</td><td></td><td>是否在导出之前<code>print</code>一下装饰器</td></tr><tr><td>filename</td><td>string</td><td></td><td>Used in warning messages</td></tr><tr><td>jsescOption</td><td>object</td><td></td><td>Use <code>jsesc</code> to process literals. <code>jsesc</code> is applied to numbers only if <code>jsescOption.numbers</code> (added in <code>v7.9.0</code>) is present. You can customize <code>jsesc</code> by <a href="https://github.com/mathiasbynens/jsesc#api">passing options</a> to it.</td></tr><tr><td>jsonCompatibleStrings</td><td>boolean</td><td><code>false</code></td><td>Set to true to run <code>jsesc</code> with “json”: true to print “\u00A9” vs. “©”;</td></tr><tr><td>minified</td><td>boolean</td><td><code>false</code></td><td>Should the output be minified<br>是否压缩代码</td></tr><tr><td>retainFunctionParens</td><td>boolean</td><td><code>false</code></td><td>Retain parens around function expressions (could be used to change engine parsing behavior)</td></tr><tr><td>retainLines</td><td>boolean</td><td><code>false</code></td><td>尝试在输出代码中使用与源代码中相同的行号(用于追踪堆栈)</td></tr><tr><td>shouldPrintComment</td><td>function</td><td><code>opts.comments</code></td><td>Function that takes a comment (as a string) and returns <code>true</code> if the comment should be included in the output. <br>By default, comments are included if <code>opts.comments</code> is <code>true</code> or if <code>opts.minified</code> is <code>false</code> and the comment contains <code>@preserve</code> or <code>@license</code></td></tr></tbody></table><h1 id="babel-traverse"><a href="#babel-traverse" class="headerlink" title="@babel/traverse"></a>@babel/traverse</h1><h2 id="index"><a href="#index" class="headerlink" title="index"></a>index</h2><h3 id="NodePath基础属性"><a href="#NodePath基础属性" class="headerlink" title="NodePath基础属性"></a>NodePath基础属性</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> parser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/parser&quot;</span>);<br><span class="hljs-keyword">const</span> traverse = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/traverse&quot;</span>).default;<br><br><span class="hljs-keyword">var</span> jscode = <span class="hljs-string">`</span><br><span class="hljs-string">function f()&#123;</span><br><span class="hljs-string">    var b = 123;</span><br><span class="hljs-string">    a = [&#x27;a&#x27;, &#x27;b&#x27;];</span><br><span class="hljs-string">&#125;`</span>;<br><br><span class="hljs-keyword">const</span> visitor = &#123;<br>    BlockStatement(path)<br>    &#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;当前路径 源码:\n&#x27;</span>, path.toString());<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;当前路径 节点:\n&#x27;</span>, path.node)<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;当前路径 父级节点:\n&#x27;</span>, path.parent);<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;当前路径 父级路径:\n&#x27;</span>, path.parentPath)<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;当前路径 类型:\n&#x27;</span>, path.type)<br><br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;当前路径 contexts:\n&#x27;</span>, path.contexts);<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;当前路径 hub:\n&#x27;</span>, path.hub);<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;当前路径 state:\n&#x27;</span>, path.state);<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;当前路径 opts:\n&#x27;</span>, path.opts)<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;当前路径 skipKeys:\n&#x27;</span>, path.skipKeys)<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;当前路径 container:\n&#x27;</span>, path.container)<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;当前路径 key:\n&#x27;</span>, path.key)<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;当前路径 scope:\n&#x27;</span>, path.scope)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> ast = parser.parse(jscode);<br>traverse(ast, visitor);<br></code></pre></td></tr></table></figure><p>你会发现其中有不少值都是没有定义的，这是因为很多值都是懒加载的<br>而且会给与专门的方法进行获取，并不是这样直接获取的  </p><h2 id="ancestry"><a href="#ancestry" class="headerlink" title="ancestry"></a>ancestry</h2><p>父级/祖先相关  </p><p><a id="path_findParent"></a></p><h3 id="NodePath-findParent-callback"><a href="#NodePath-findParent-callback" class="headerlink" title="NodePath.findParent(callback)"></a>NodePath.findParent(callback)</h3><p><code>@return NodePath | None</code><br>逐级递归寻找父级节点的Path，并将<code>Path</code>作为参数传入的判断函数进行判断<br>当判断函数返回<code>true</code>, 则<code>Path.findParent(callback)</code>返回对应<code>Path</code><br>当判断函数返回<code>false</code>, 则递归继续寻找父级, 进行判断。若已无父级，则返回<code>null</code>  </p><blockquote><p>例: 寻找当前Path的父级函数节点  </p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> parser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/parser&quot;</span>);<br><span class="hljs-keyword">const</span> traverse = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/traverse&quot;</span>).default;<br><br><span class="hljs-keyword">var</span> jscode = <span class="hljs-string">`</span><br><span class="hljs-string">function f()&#123;</span><br><span class="hljs-string">    var b = 123;</span><br><span class="hljs-string">    a = b + 1;</span><br><span class="hljs-string">&#125;`</span>;<br><br><span class="hljs-keyword">const</span> visitor = &#123;<br>    <span class="hljs-function"><span class="hljs-title">AssignmentExpression</span>(<span class="hljs-params">path</span>)</span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;当前路径源码:\n&#x27;</span>, path.toString());<br>        <br>        <span class="hljs-comment">// 寻找父级</span><br>        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">to_parent_function_path</span>(<span class="hljs-params">x</span>)</span>&#123;  <span class="hljs-comment">// 进行判断是否是函数声明节点的判断函数</span><br>            <span class="hljs-keyword">if</span>(x.isFunctionDeclaration())&#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>&#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>&#125;<br>        &#125;<br>        <span class="hljs-comment">//      将判断函数传入，进行递归寻找父级path</span><br>        the_path = path.findParent(to_parent_function_path)<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;to_parent_function_path 最终路径源码:\n&#x27;</span>, the_path.toString())<br><br>        <span class="hljs-comment">//      递归后如果没有发现符合要求的父级</span><br>        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">to_null</span>(<span class="hljs-params">x</span>)</span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>&#125;<br>        the_path = path.findParent(to_null)<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;to_null 最终路径:\n&#x27;</span>, the_path)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> ast = parser.parse(jscode);<br>traverse(ast, visitor);<br></code></pre></td></tr></table></figure><p>得到的输出结果  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript">当前路径源码:<br> a = b + <span class="hljs-number">1</span><br>to_parent_function_path 最终路径源码:<br> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> b = <span class="hljs-number">123</span>;<br>  a = b + <span class="hljs-number">1</span>;<br>&#125;<br>to_null 最终路径:<br> <span class="hljs-literal">null</span><br></code></pre></td></tr></table></figure><h3 id="NodePath-find-callback"><a href="#NodePath-find-callback" class="headerlink" title="NodePath.find(callback)"></a>NodePath.find(callback)</h3><p><code>@return NodePath | None</code><br>此函数与 <code>Path.findParent</code> 基本相同, 但这个判断包含对 当前Path 的判断<br>它会先对 当前Path 进行一次判断. 如果自身符合条件，那就返回 当前Path，然后才递归调用父级进行判断  </p><blockquote><p>例子：当前或父级Path  </p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> parser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/parser&quot;</span>);<br><span class="hljs-keyword">const</span> traverse = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/traverse&quot;</span>).default;<br><br><span class="hljs-keyword">var</span> jscode = <span class="hljs-string">`</span><br><span class="hljs-string">function f()&#123;</span><br><span class="hljs-string">    var b = 123;</span><br><span class="hljs-string">    a = b + 1;</span><br><span class="hljs-string">&#125;`</span>;<br><br><span class="hljs-keyword">const</span> visitor = &#123;<br>    <span class="hljs-function"><span class="hljs-title">AssignmentExpression</span>(<span class="hljs-params">path</span>)</span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;当前路径源码:\n&#x27;</span>, path.toString());<br>        <br>        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">to_path</span>(<span class="hljs-params">x</span>)</span>&#123;  <br>            <span class="hljs-keyword">if</span>(x.isAssignmentExpression())&#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>&#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>&#125;<br>        &#125;<br>        the_path = path.find(to_path)<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;to_path最终路径源码:\n&#x27;</span>, the_path.toString())<br><br>        <span class="hljs-comment">// 寻找父级</span><br>        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">to_parent_function_path</span>(<span class="hljs-params">x</span>)</span>&#123;  <span class="hljs-comment">// 进行判断是否是函数声明节点的判断函数</span><br>            <span class="hljs-keyword">if</span>(x.isFunctionDeclaration())&#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>&#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>&#125;<br>        &#125;<br>        the_path = path.find(to_parent_function_path)<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;to_parent_function_path最终路径源码:\n&#x27;</span>, the_path.toString())<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> ast = parser.parse(jscode);<br>traverse(ast, visitor);<br></code></pre></td></tr></table></figure><p>得到的输出结果  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript">当前路径源码:<br> a = b + <span class="hljs-number">1</span><br>to_path最终路径源码:<br> a = b + <span class="hljs-number">1</span><br>to_parent_function_path最终路径源码:<br> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> b = <span class="hljs-number">123</span>;<br>  a = b + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="NodePath-getFunctionParent"><a href="#NodePath-getFunctionParent" class="headerlink" title="NodePath.getFunctionParent()"></a>NodePath.getFunctionParent()</h3><p><code>@return NodePath | None</code><br>得到当前节点的第一个 父级/祖先 函数声明节点的Path  </p><p>此方法通过调用 <a href="#path_findParent"><code>Path.findParent(callback)</code></a> 传入内置的判断函数，来得到对应的结果  </p><blockquote><p>例: 寻找 父级/祖先 函数声明节点的Path  </p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> parser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/parser&quot;</span>);<br><span class="hljs-keyword">const</span> traverse = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/traverse&quot;</span>).default;<br><br><span class="hljs-keyword">var</span> jscode = <span class="hljs-string">`</span><br><span class="hljs-string">function f()&#123;</span><br><span class="hljs-string">    var b = 123;</span><br><span class="hljs-string">    a = b + 1;</span><br><span class="hljs-string">&#125;`</span>;<br><br><span class="hljs-keyword">const</span> visitor = &#123;<br>    <span class="hljs-function"><span class="hljs-title">AssignmentExpression</span>(<span class="hljs-params">path</span>)</span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;当前路径源码:\n&#x27;</span>, path.toString());<br><br>        the_path = path.getFunctionParent()<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;最终路径源码:\n&#x27;</span>, the_path.toString())<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> ast = parser.parse(jscode);<br>traverse(ast, visitor);<br></code></pre></td></tr></table></figure><p>得到对应结果</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript">当前路径源码:<br> a = b + <span class="hljs-number">1</span><br>最终路径源码:<br> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> b = <span class="hljs-number">123</span>;<br>  a = b + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="NodePath-getStatementParent"><a href="#NodePath-getStatementParent" class="headerlink" title="NodePath.getStatementParent()"></a>NodePath.getStatementParent()</h3><p><code>@return NodePath</code><br>返回第一个 父级/祖先 声明节点的Path<br>声明节点所包含的节点类型见：<a href="https://github.com/babel/babylon/blob/master/ast/spec.md#blockstatement">Github文档</a><br>若找不到目标，会报错  </p><blockquote><p>例：返回第一个 父级/祖先 声明节点的 Path  </p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> parser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/parser&quot;</span>);<br><span class="hljs-keyword">const</span> traverse = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/traverse&quot;</span>).default;<br><br><span class="hljs-keyword">var</span> jscode = <span class="hljs-string">`</span><br><span class="hljs-string">function f2()&#123;</span><br><span class="hljs-string">    var b = 123;</span><br><span class="hljs-string">    a = b + 1;</span><br><span class="hljs-string">&#125;`</span>;<br><br><span class="hljs-keyword">const</span> visitor = &#123;<br>    <span class="hljs-function"><span class="hljs-title">BinaryExpression</span>(<span class="hljs-params">path</span>)</span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;当前路径源码:\n&#x27;</span>, path.toString());<br>        the_path = path.getStatementParent()<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;最终路径源码:\n&#x27;</span>, the_path.toString())<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> ast = parser.parse(jscode);<br>traverse(ast, visitor);<br></code></pre></td></tr></table></figure><p>得到的结果  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">当前路径源码:<br> b + <span class="hljs-number">1</span><br>最终路径源码:<br> a = b + <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><h3 id="NodePath-getAncestry"><a href="#NodePath-getAncestry" class="headerlink" title="NodePath.getAncestry()"></a>NodePath.getAncestry()</h3><p><code>@return Array</code><br>返回所有 父级/祖先 的Path  </p><blockquote><p>例：得到当前Path的所有 父级/祖先 的Path  </p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> parser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/parser&quot;</span>);<br><span class="hljs-keyword">const</span> traverse = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/traverse&quot;</span>).default;<br><br><span class="hljs-keyword">var</span> jscode = <span class="hljs-string">`</span><br><span class="hljs-string">function f2()&#123;</span><br><span class="hljs-string">    var b = 123;</span><br><span class="hljs-string">    a = b + 1;</span><br><span class="hljs-string">&#125;`</span>;<br><br><span class="hljs-keyword">const</span> visitor = &#123;<br>    <span class="hljs-function"><span class="hljs-title">AssignmentExpression</span>(<span class="hljs-params">path</span>)</span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;当前路径源码:\n&#x27;</span>, path.toString());<br>        the_paths = path.getAncestry()<br><br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;返回类型:\n&#x27;</span>, the_paths <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Array</span>)<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;结果路径源码:\n&#x27;</span>, the_paths.join(<span class="hljs-string">&#x27;\n\n&#x27;</span>))<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> ast = parser.parse(jscode);<br>traverse(ast, visitor);<br></code></pre></td></tr></table></figure><p>输出结果  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript">当前路径源码:<br> a = b + <span class="hljs-number">1</span><br>返回类型:<br> <span class="hljs-literal">true</span><br>结果路径源码:<br> a = b + <span class="hljs-number">1</span><br><br>a = b + <span class="hljs-number">1</span>;<br><br>&#123;<br>  <span class="hljs-keyword">var</span> b = <span class="hljs-number">123</span>;<br>  a = b + <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f2</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> b = <span class="hljs-number">123</span>;<br>  a = b + <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f2</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> b = <span class="hljs-number">123</span>;<br>  a = b + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><a id="path_isdescendant"></a>  </p><h3 id="NodePath-isDescendant-path"><a href="#NodePath-isDescendant-path" class="headerlink" title="NodePath.isDescendant(path)"></a>NodePath.isDescendant(path)</h3><p><code>@return bool</code><br>判断当前 Path 是否是指定 Path 的后代  </p><p>此方法通过调用 <a href="#path_findParent"><code>Path.findParent()</code></a> 来进行判断，得到结果  </p><blockquote><p>例:辈分判断  </p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> parser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/parser&quot;</span>);<br><span class="hljs-keyword">const</span> traverse = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/traverse&quot;</span>).default;<br><br><span class="hljs-keyword">var</span> jscode = <span class="hljs-string">`</span><br><span class="hljs-string">function f2()&#123;</span><br><span class="hljs-string">    var b = 123;</span><br><span class="hljs-string">    a = b + 1;</span><br><span class="hljs-string">&#125;`</span>;<br><br><span class="hljs-keyword">const</span> visitor = &#123;<br>    <span class="hljs-function"><span class="hljs-title">AssignmentExpression</span>(<span class="hljs-params">path</span>)</span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;当前路径源码:\n&#x27;</span>, path.toString());<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;儿子是爸爸的后代：&#x27;</span>, path.isDescendant(path.parentPath))<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;儿子是爷爷的后代：&#x27;</span>, path.isDescendant(path.parentPath.parentPath))<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;儿子是孙子的后代：&#x27;</span>, path.isDescendant(path.get(<span class="hljs-string">&#x27;left&#x27;</span>)))<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> ast = parser.parse(jscode);<br>traverse(ast, visitor);<br></code></pre></td></tr></table></figure><p>输出结果：  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">当前路径源码:<br> a = b + <span class="hljs-number">1</span><br>儿子是爸爸的后代： <span class="hljs-literal">true</span><br>儿子是爷爷的后代： <span class="hljs-literal">true</span><br>儿子是孙子的后代： <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><h3 id="NodePath-isAncestor-path"><a href="#NodePath-isAncestor-path" class="headerlink" title="NodePath.isAncestor(path)"></a>NodePath.isAncestor(path)</h3><p><code>@return bool</code><br>判断当前 Path 是否是指定 Path 的后代  </p><p>此方法是调用 传入的path的<a href="#path_isdescendant"><code>Path.isDescendant()</code></a> 来进行判断的  </p><blockquote><p>例：判断是否是后代  </p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> parser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/parser&quot;</span>);<br><span class="hljs-keyword">const</span> traverse = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/traverse&quot;</span>).default;<br><br><span class="hljs-keyword">var</span> jscode = <span class="hljs-string">`</span><br><span class="hljs-string">function f2()&#123;</span><br><span class="hljs-string">    var b = 123;</span><br><span class="hljs-string">    a = b + 1;</span><br><span class="hljs-string">&#125;`</span>;<br><br><span class="hljs-keyword">const</span> visitor = &#123;<br>    <span class="hljs-function"><span class="hljs-title">AssignmentExpression</span>(<span class="hljs-params">path</span>)</span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;当前路径源码:\n&#x27;</span>, path.toString());<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;儿子是爸爸的祖先：&#x27;</span>, path.isAncestor(path.parentPath))<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;儿子是爷爷的祖先：&#x27;</span>, path.isAncestor(path.parentPath.parentPath))<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;儿子是孙子的祖先：&#x27;</span>, path.isAncestor(path.get(<span class="hljs-string">&#x27;left&#x27;</span>)))<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> ast = parser.parse(jscode);<br>traverse(ast, visitor);<br></code></pre></td></tr></table></figure><p>得到结果:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">当前路径源码:<br> a = b + <span class="hljs-number">1</span><br>儿子是爸爸的祖先： <span class="hljs-literal">false</span><br>儿子是爷爷的祖先： <span class="hljs-literal">false</span><br>儿子是孙子的祖先： <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><h3 id="NodePath-inType-NodeType-str"><a href="#NodePath-inType-NodeType-str" class="headerlink" title="NodePath.inType(**NodeType_str)"></a>NodePath.inType(**NodeType_str)</h3><p><code>@return bool</code><br>判断当前<code>Path</code>对应节点，或其 父/祖先 节点 是否包含特定类型的节点<br>可以一次性传入多个类型，只要有一个符合就会返回 <code>true</code>, 否则返回 <code>false</code>  </p><blockquote><p>例: 是否包含特定类型的节点  </p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> parser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/parser&quot;</span>);<br><span class="hljs-keyword">const</span> traverse = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/traverse&quot;</span>).default;<br><br><span class="hljs-keyword">var</span> jscode = <span class="hljs-string">`</span><br><span class="hljs-string">function f2()&#123;</span><br><span class="hljs-string">    var b = 123;</span><br><span class="hljs-string">    a = b + 1;</span><br><span class="hljs-string">&#125;`</span>;<br><br><span class="hljs-keyword">const</span> visitor = &#123;<br>    <span class="hljs-function"><span class="hljs-title">AssignmentExpression</span>(<span class="hljs-params">path</span>)</span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;当前路径源码:\n&#x27;</span>, path.toString());<br>        _is = path.inType(<span class="hljs-string">&#x27;FunctionDeclaration&#x27;</span>)<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;父级或自身包含函数声明节点：&#x27;</span>, _is);<br>        _is = path.inType(<span class="hljs-string">&#x27;WithStatement&#x27;</span>, <span class="hljs-string">&#x27;DebuggerStatement&#x27;</span>)<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;父级或自身包含 with 或 debugger：&#x27;</span>, path.inType(_is));<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> ast = parser.parse(jscode);<br>traverse(ast, visitor);<br></code></pre></td></tr></table></figure><p>输出的结果：  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">当前路径源码:<br> a = b + <span class="hljs-number">1</span><br>父级或自身包含函数声明节点： <span class="hljs-literal">true</span><br>父级或自身包含 <span class="hljs-keyword">with</span> 或 <span class="hljs-keyword">debugger</span>： <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p><a id="traverse_getDeepestCommonAncestorFrom"></a></p><h3 id="NodePath-getDeepestCommonAncestorFrom-paths-filter"><a href="#NodePath-getDeepestCommonAncestorFrom-paths-filter" class="headerlink" title="NodePath.getDeepestCommonAncestorFrom(paths, filter)"></a>NodePath.getDeepestCommonAncestorFrom(paths, filter)</h3><p><code>@return NodePath | 自定义</code><br>获取传入的<code>Path</code>对应节点的 最大深度共同祖先节点的<code>Path</code>  </p><ul><li>当 <code>paths</code>不存在<code>length</code>属性时，报错  </li><li>当 <code>paths</code> 长度为0时，返回 <code>null</code>  </li><li>当 <code>paths</code> 长度为1时，返回唯一的<code>Path</code>  </li><li>当 <code>paths</code> 大于1  <ul><li>计算 最大深度共同祖先节点 的<code>Path</code>并返回  </li><li>当传入一个<code>filter</code>函数，那么返回结果会作为参数进行回调。返回结果变为<code>filter(最大深度共同祖先节点Path:NodePath, 深度:int, 所有path的祖先信息:list);</code>  </li></ul></li><li>如果并不存在共同的祖先节点，报错  </li></ul><blockquote><p>例：最大深度的共同祖先节点  </p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> parser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/parser&quot;</span>);<br><span class="hljs-keyword">const</span> traverse = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/traverse&quot;</span>).default;<br><br><span class="hljs-keyword">var</span> jscode = <span class="hljs-string">`</span><br><span class="hljs-string">function f()&#123;</span><br><span class="hljs-string">    function f3()&#123;</span><br><span class="hljs-string">        function f1()&#123;return 1;&#125;</span><br><span class="hljs-string">        function f2()&#123;return 2;&#125;</span><br><span class="hljs-string">        return 3;</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string">&#125;`</span>;<br><br><br><span class="hljs-keyword">let</span> paths = []<br><br><span class="hljs-keyword">const</span> visitor = &#123;<br>    <span class="hljs-function"><span class="hljs-title">ReturnStatement</span>(<span class="hljs-params">path</span>)</span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;路径源码:\n&#x27;</span>, path.toString());<br>        paths.push(path)<br>        <span class="hljs-keyword">if</span> (paths.length &gt; <span class="hljs-number">1</span>)&#123;<br>            _is = path.getDeepestCommonAncestorFrom(paths)<br>            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;最大深度的共同祖先节点 源代码：&#x27;</span>, _is.toString());<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> ast = parser.parse(jscode);<br>traverse(ast, visitor);<br></code></pre></td></tr></table></figure><p>得到结果  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs javascript">路径源码:<br> <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>路径源码:<br> <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>最大深度的共同祖先节点 源代码： &#123;<br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f1</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f2</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<br>&#125;<br>路径源码:<br> <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<br>最大深度的共同祖先节点 源代码： &#123;<br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f1</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f2</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="NodePath-getEarliestCommonAncestorFrom-paths"><a href="#NodePath-getEarliestCommonAncestorFrom-paths" class="headerlink" title="NodePath.getEarliestCommonAncestorFrom(paths)"></a>NodePath.getEarliestCommonAncestorFrom(paths)</h3><p><code>@return NodePath</code><br>获取<code>paths</code>中最早出现的共同祖先<br>方法会遍历计算，共同祖先一旦出现, 则返回，不再继续计算所有的path  </p><p>此方法是调用 <a href="#traverse_getDeepestCommonAncestorFrom">getDeepestCommonAncestorFrom(paths, filter)</a> 方法，传入固定的<code>filter</code>函数来实现    </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> parser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/parser&quot;</span>);<br><span class="hljs-keyword">const</span> traverse = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/traverse&quot;</span>).default;<br><br><span class="hljs-keyword">var</span> jscode = <span class="hljs-string">`</span><br><span class="hljs-string">function f()&#123;</span><br><span class="hljs-string">    function f3()&#123;</span><br><span class="hljs-string">        function f1()&#123;return 1;&#125;</span><br><span class="hljs-string">        function f2()&#123;return 2;&#125;</span><br><span class="hljs-string">        return 3;</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string">&#125;`</span>;<br><br><br><span class="hljs-keyword">let</span> paths = []<br><br><span class="hljs-keyword">const</span> visitor = &#123;<br>    <span class="hljs-function"><span class="hljs-title">ReturnStatement</span>(<span class="hljs-params">path</span>)</span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;路径源码:\n&#x27;</span>, path.toString());<br>        paths.push(path)<br>        <span class="hljs-keyword">if</span> (paths.length &gt; <span class="hljs-number">1</span>)&#123;<br>            _is = path.getEarliestCommonAncestorFrom(paths)<br>            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;最早的共同祖先节点 源代码：&#x27;</span>, _is.toString());<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> ast = parser.parse(jscode);<br>traverse(ast, visitor);<br></code></pre></td></tr></table></figure><h2 id="removal"><a href="#removal" class="headerlink" title="removal"></a>removal</h2><p>移除相关  </p><h3 id="NodePath-remove"><a href="#NodePath-remove" class="headerlink" title="NodePath.remove()"></a>NodePath.remove()</h3><p><code>@return null</code><br>删除路径对应的节点  </p><p>删除以后，对应的<code>removed</code>标识为会被设定，内容会被设定为只读<br>如果再次执行<code>remove</code>方法，则会报错  </p><blockquote><p>例：删除 path 对应的节点  </p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> parser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/parser&quot;</span>);<br><span class="hljs-keyword">const</span> traverse = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/traverse&quot;</span>).default;<br><span class="hljs-keyword">const</span> generator = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/generator&quot;</span>).default;<br><br><span class="hljs-keyword">const</span> jscode = <span class="hljs-string">`function square(n) &#123;</span><br><span class="hljs-string">  var a = 1;</span><br><span class="hljs-string">  return 1 + 1;</span><br><span class="hljs-string">&#125;`</span>;<br><br><span class="hljs-keyword">const</span> ast = parser.parse(jscode);<br><span class="hljs-keyword">const</span> visitor = &#123;<br>  <span class="hljs-function"><span class="hljs-title">VariableDeclaration</span>(<span class="hljs-params">path</span>)</span>&#123;  <span class="hljs-comment">// 找到变量声明节点，删除</span><br>      path.remove()<br>  &#125;<br>&#125;<br><br>traverse(ast, visitor);<br><span class="hljs-built_in">console</span>.log(generator(ast)[<span class="hljs-string">&#x27;code&#x27;</span>])<br></code></pre></td></tr></table></figure><p>得到结果：  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">square</span>(<span class="hljs-params">n</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="scope"><a href="#scope" class="headerlink" title="scope"></a>scope</h2><p>此模块与作用域相关  </p><h4 id="Scope"><a href="#Scope" class="headerlink" title="Scope"></a>Scope</h4><p>和 作用域 相关的内容被定义在了 Scope类 中<br>这个类定义位于 <code>@babel/traverse/lib/scope/index.js</code> 文件中  </p><h4 id="Scope属性"><a href="#Scope属性" class="headerlink" title="Scope属性"></a>Scope属性</h4><blockquote><p>例：输出一些属性，一般不会直接使用，但可以留个印象，后面的函数可能会使用属性    </p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> parser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/parser&quot;</span>);<br><span class="hljs-keyword">const</span> traverse = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/traverse&quot;</span>).default;<br><br><span class="hljs-keyword">const</span> jscode = <span class="hljs-string">`</span><br><span class="hljs-string">var g = 1;</span><br><span class="hljs-string">function squire(i)&#123;</span><br><span class="hljs-string">    return i * g * i;</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">function i()</span><br><span class="hljs-string">&#123;</span><br><span class="hljs-string">    var i = 123;</span><br><span class="hljs-string">    i += 2;</span><br><span class="hljs-string">    return 123;</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">`</span>;<br><span class="hljs-keyword">let</span> ast = parser.parse(jscode);<br><span class="hljs-keyword">const</span> visitor = &#123;<br>    <span class="hljs-function"><span class="hljs-title">VariableDeclaration</span>(<span class="hljs-params">path</span>)</span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;\n这里是&quot;</span>, path.toString())<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;--------------------------------&#x27;</span>)<br>        sc = path.scope  <span class="hljs-comment">// 获取对应的 Scope对象</span><br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;这个对象是否已经初始化：&#x27;</span>, sc.inited)<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;uid 属性&#x27;</span>, sc.uid)<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;cached 属性&#x27;</span>, sc.cached)<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;node 属性&#x27;</span>, sc.node)<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;作用域节点：&#x27;</span>, sc.block)<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;作用对应的path：&#x27;</span>, sc.path.node == sc.block)<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;labels 属性&#x27;</span>, sc.labels)<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;被绑定量 的信息：&#x27;</span>, sc.bindings)<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;--------------------------------&#x27;</span>)<br>    &#125;<br>&#125;<br><br>traverse(ast, visitor);<br></code></pre></td></tr></table></figure><p>你能够直接访问<code>Scope</code>对象的属性，它本身也提供了一些方法来访问  </p><h4 id="Scope方法"><a href="#Scope方法" class="headerlink" title="Scope方法"></a>Scope方法</h4><h5 id="Scope-parent"><a href="#Scope-parent" class="headerlink" title="Scope.parent"></a>Scope.parent</h5><p><code>@return Scope | undefined</code>  </p><p>获取当前作用域的父级作用域  </p><p>此方法通过引用其<code>Scope.path</code>属性的<a href="#path_findParent"><code>PathNode.findParent</code></a>获取对应<code>PathNode</code>后再次获取作用域的方式获取  </p><blockquote><p>例：获取父级作用域</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> parser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/parser&quot;</span>);<br><span class="hljs-keyword">const</span> traverse = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/traverse&quot;</span>).default;<br><br><span class="hljs-keyword">const</span> jscode = <span class="hljs-string">`</span><br><span class="hljs-string">var g = 1;</span><br><span class="hljs-string">function squire(i)&#123;</span><br><span class="hljs-string">    return i * g * i;</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">function i()</span><br><span class="hljs-string">&#123;</span><br><span class="hljs-string">    var i = 123;</span><br><span class="hljs-string">    i += 2;</span><br><span class="hljs-string">    return 123;</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">`</span>;<br><span class="hljs-keyword">let</span> ast = parser.parse(jscode);<br><span class="hljs-keyword">const</span> visitor = &#123;<br>    <span class="hljs-function"><span class="hljs-title">VariableDeclaration</span>(<span class="hljs-params">path</span>)</span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;\n这里是&quot;</span>, path.toString())<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;--------------------------------&#x27;</span>)<br>        sc = path.scope  <span class="hljs-comment">// 获取对应的 Scope对象</span><br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;parent结果：&#x27;</span>, sc.parent)<br>    &#125;<br>&#125;<br><br>traverse(ast, visitor);<br></code></pre></td></tr></table></figure><details>    <summary>结果</summary>       <pre><code>           这里是 var g = 1;    --------------------------------    parent结果： undefined    这里是 var i = 123;    --------------------------------    parent结果： Scope &#123;      uid: 0,      block: Node &#123;        type: 'Program',        start: 0,        end: 118,        loc: SourceLocation &#123; start: [Position], end: [Position] &#125;,        sourceType: 'script',        interpreter: null,        body: [ [Node], [Node], [Node] ],        directives: []      &#125;,      path: NodePath &#123;        parent: Node &#123;          type: 'File',          start: 0,          end: 118,          loc: [SourceLocation],          errors: [],          program: [Node],          comments: []        &#125;,        hub: undefined,        contexts: [ [TraversalContext] ],        data: null,        _traverseFlags: 0,        state: undefined,        opts: &#123; VariableDeclaration: [Object], _exploded: true, _verified: true &#125;,        skipKeys: null,        parentPath: null,        context: TraversalContext &#123;          queue: [Array],          parentPath: undefined,          scope: undefined,          state: undefined,          opts: [Object],          priorityQueue: []        &#125;,        container: Node &#123;          type: 'File',          start: 0,          end: 118,          loc: [SourceLocation],          errors: [],          program: [Node],          comments: []        &#125;,        listKey: undefined,        key: 'program',        node: Node &#123;          type: 'Program',          start: 0,          end: 118,          loc: [SourceLocation],          sourceType: 'script',          interpreter: null,          body: [Array],          directives: []        &#125;,        scope: [Circular],        type: 'Program'      &#125;,      labels: Map &#123;&#125;,      inited: true,      references: [Object: null prototype] &#123; g: true, i: true, squire: true &#125;,      bindings: [Object: null prototype] &#123;        g: Binding &#123;          identifier: [Node],          scope: [Circular],          path: [NodePath],          kind: 'var',          constantViolations: [],          constant: true,          referencePaths: [Array],          referenced: true,          references: 1,          hasDeoptedValue: false,          hasValue: false,          value: null        &#125;,        squire: Binding &#123;          identifier: [Node],          scope: [Circular],          path: [NodePath],          kind: 'hoisted',          constantViolations: [],          constant: true,          referencePaths: [],          referenced: false,          references: 0,          hasDeoptedValue: false,          hasValue: false,          value: null        &#125;,        i: Binding &#123;          identifier: [Node],          scope: [Circular],          path: [NodePath],          kind: 'hoisted',          constantViolations: [],          constant: true,          referencePaths: [],          referenced: false,          references: 0,          hasDeoptedValue: false,          hasValue: false,          value: null        &#125;      &#125;,      globals: [Object: null prototype] &#123;&#125;,      uids: [Object: null prototype] &#123;&#125;,      data: [Object: null prototype] &#123;&#125;,      crawling: false    &#125;    </code></pre> </details><h5 id="Scope-dump"><a href="#Scope-dump" class="headerlink" title="Scope.dump()"></a>Scope.dump()</h5><p><code>return null</code>  </p><p>执行 Scope.dump()，会输出到自底向上的 作用域与被绑定量的信息  </p><p>执行后会得到类似于这样的输出信息  </p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># FunctionDeclaration</span><br> <span class="hljs-bullet">-</span> <span class="hljs-string">i</span> &#123; <span class="hljs-attr">constant:</span> <span class="hljs-literal">false</span>, <span class="hljs-attr">references:</span> <span class="hljs-number">0</span>, <span class="hljs-attr">violations:</span> <span class="hljs-number">1</span>, <span class="hljs-attr">kind:</span> <span class="hljs-string">&#x27;var&#x27;</span> &#125;<br><span class="hljs-comment"># Program</span><br> <span class="hljs-bullet">-</span> <span class="hljs-string">squire</span> &#123; <span class="hljs-attr">constant:</span> <span class="hljs-literal">true</span>, <span class="hljs-attr">references:</span> <span class="hljs-number">0</span>, <span class="hljs-attr">violations:</span> <span class="hljs-number">0</span>, <span class="hljs-attr">kind:</span> <span class="hljs-string">&#x27;hoisted&#x27;</span> &#125;<br> <span class="hljs-bullet">-</span> <span class="hljs-string">i</span> &#123; <span class="hljs-attr">constant:</span> <span class="hljs-literal">true</span>, <span class="hljs-attr">references:</span> <span class="hljs-number">0</span>, <span class="hljs-attr">violations:</span> <span class="hljs-number">0</span>, <span class="hljs-attr">kind:</span> <span class="hljs-string">&#x27;hoisted&#x27;</span> &#125;<br></code></pre></td></tr></table></figure><p>作用域 以<code>#</code>划分，此处有两个作用域 <code>FunctionDeclaration</code> 与 <code>Program</code>  </p><p>被绑定量 以最前方设置<code>-</code>来标识，一般显示其中的4种信息  </p><ul><li>constant<br> 量 在声明后，在作用域内是否会被 更变（重定义/赋值）<br> 实际上对应对应量的<code>Binding</code>对象的<code>Binding.constant</code>属性  </li><li>references<br> 被引用次数<br> 实际上对应对应量的<code>Binding</code>对象的<code>Binding.references</code>属性  </li><li>violations<br> 量 被 重新定义/赋值 的次数<br> 实际上对应对应量的<code>Binding</code>对象的<code>Binding.constantViolations</code>的长度。这个属性被用于记录变更位置（每次变更都添加内容）  </li><li>kind<br> 是函数声明类型。常见的有：<code>hoisted</code>提升，<code>var</code>变量， <code>local</code>内部<br> 实际上对应对应量的<code>Binding</code>对象的<code>Binding.kind</code>属性  </li></ul><p>实际上这些信息大部分 （以一个被绑定量，一个 <code>Binding</code>对象的方式）储存在 <code>Scope.bindings</code> 这个属性中  </p><blockquote><p>例：使用案例  </p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> parser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/parser&quot;</span>);<br><span class="hljs-keyword">const</span> traverse = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/traverse&quot;</span>).default;<br><br><span class="hljs-keyword">const</span> jscode = <span class="hljs-string">`</span><br><span class="hljs-string">function squire(i)&#123;</span><br><span class="hljs-string">    return i * i * i;</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">function i()&#123;</span><br><span class="hljs-string">    var i = 123;</span><br><span class="hljs-string">    i += 2;</span><br><span class="hljs-string">    return 123;</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">`</span>;<br><span class="hljs-keyword">let</span> ast = parser.parse(jscode);<br><span class="hljs-keyword">const</span> visitor = &#123;<br>    <span class="hljs-string">&quot;FunctionDeclaration&quot;</span>(path)&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;\n\n这里是函数 &quot;</span>, path.node.id.name + <span class="hljs-string">&#x27;()&#x27;</span>)<br>        path.scope.dump();<br>    &#125;<br>&#125;<br><br>traverse(ast, visitor);<br></code></pre></td></tr></table></figure><p>得到结果：  </p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">这里是函数  squire()<br>------------------------------------------------------------<br># FunctionDeclaration<br><span class="hljs-code"> - i &#123; constant: true, references: 3, violations: 0, kind: &#x27;param&#x27; &#125;</span><br># Program<br><span class="hljs-code"> - squire &#123; constant: true, references: 0, violations: 0, kind: &#x27;hoisted&#x27; &#125;</span><br><span class="hljs-code"> - i &#123; constant: true, references: 0, violations: 0, kind: &#x27;hoisted&#x27; &#125;</span><br>------------------------------------------------------------<br><br><br>这里是函数  i()<br>------------------------------------------------------------<br># FunctionDeclaration<br><span class="hljs-code"> - i &#123; constant: false, references: 0, violations: 1, kind: &#x27;var&#x27; &#125;</span><br># Program<br><span class="hljs-code"> - squire &#123; constant: true, references: 0, violations: 0, kind: &#x27;hoisted&#x27; &#125;</span><br><span class="hljs-code"> - i &#123; constant: true, references: 0, violations: 0, kind: &#x27;hoisted&#x27; &#125;</span><br>------------------------------------------------------------<br></code></pre></td></tr></table></figure><h5 id="Scope-parentBlock-name"><a href="#Scope-parentBlock-name" class="headerlink" title="Scope.parentBlock(name)"></a>Scope.parentBlock(name)</h5><p><code>@return Node</code>  </p><p>获取 作用域路径 的父级<br>它的源码就一句 <code>return this.path.parent;</code>    </p><blockquote><p>例: 获取作用域路径的父级  </p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> parser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/parser&quot;</span>);<br><span class="hljs-keyword">const</span> traverse = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/traverse&quot;</span>).default;<br><br><span class="hljs-keyword">const</span> jscode = <span class="hljs-string">`</span><br><span class="hljs-string">var g = 1;</span><br><span class="hljs-string">function a()&#123;return g;&#125;</span><br><span class="hljs-string">function b()&#123;var z=2; return z;&#125;</span><br><span class="hljs-string">`</span>;<br><span class="hljs-keyword">let</span> ast = parser.parse(jscode);<br><span class="hljs-keyword">const</span> visitor = &#123;<br>    <span class="hljs-function"><span class="hljs-title">ReturnStatement</span>(<span class="hljs-params">path</span>)</span>&#123;<br>        <span class="hljs-keyword">var</span> n = path.node.argument.name<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;\n这里是&quot;</span>, path.toString())<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;结果：&#x27;</span>, path.scope.parentBlock)<br>    &#125;<br>&#125;<br><br>traverse(ast, visitor);<br></code></pre></td></tr></table></figure><details>    <summary>结果</summary>       <pre><code>           这里是 return g;    结果： Node &#123;      type: 'Program',      start: 0,      end: 69,      loc: SourceLocation &#123;        start: Position &#123; line: 1, column: 0 &#125;,        end: Position &#123; line: 5, column: 0 &#125;      &#125;,      sourceType: 'script',      interpreter: null,      body: [        Node &#123;          type: 'VariableDeclaration',          start: 1,          end: 11,          loc: [SourceLocation],          declarations: [Array],          kind: 'var'        &#125;,        Node &#123;          type: 'FunctionDeclaration',          start: 12,          end: 35,          loc: [SourceLocation],          id: [Node],          generator: false,          async: false,          params: [],          body: [Node]        &#125;,        Node &#123;          type: 'FunctionDeclaration',          start: 36,          end: 68,          loc: [SourceLocation],          id: [Node],          generator: false,          async: false,          params: [],          body: [Node]        &#125;      ],      directives: []    &#125;    这里是 return z;    结果： Node &#123;      type: 'Program',      start: 0,      end: 69,      loc: SourceLocation &#123;        start: Position &#123; line: 1, column: 0 &#125;,        end: Position &#123; line: 5, column: 0 &#125;      &#125;,      sourceType: 'script',      interpreter: null,      body: [        Node &#123;          type: 'VariableDeclaration',          start: 1,          end: 11,          loc: [SourceLocation],          declarations: [Array],          kind: 'var'        &#125;,        Node &#123;          type: 'FunctionDeclaration',          start: 12,          end: 35,          loc: [SourceLocation],          id: [Node],          generator: false,          async: false,          params: [],          body: [Node]        &#125;,        Node &#123;          type: 'FunctionDeclaration',          start: 36,          end: 68,          loc: [SourceLocation],          id: [Node],          generator: false,          async: false,          params: [],          body: [Node]        &#125;      ],      directives: []    &#125;    </code></pre> </details><p><a id="Scope_getBinding"></a></p><h5 id="Scope-getBinding-name"><a href="#Scope-getBinding-name" class="headerlink" title="Scope.getBinding(name)"></a>Scope.getBinding(name)</h5><p><code>@return Binding</code>  </p><p>获取指定 被绑定量 的 <a href="#Binding"><code>Binding</code></a>对象  </p><p>如果在 当前作用域 找不到指定的 被绑定量，那么就会递归在父级作用域中寻找  </p><blockquote><p>例：获取指定的 被绑定量对象  </p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> parser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/parser&quot;</span>);<br><span class="hljs-keyword">const</span> traverse = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/traverse&quot;</span>).default;<br><br><span class="hljs-keyword">const</span> jscode = <span class="hljs-string">`</span><br><span class="hljs-string">var g = 1;</span><br><span class="hljs-string">function a()&#123;return g;&#125;</span><br><span class="hljs-string">function b()&#123;var z=2; return z;&#125;</span><br><span class="hljs-string">`</span>;<br><span class="hljs-keyword">let</span> ast = parser.parse(jscode);<br><span class="hljs-keyword">const</span> visitor = &#123;<br>    <span class="hljs-function"><span class="hljs-title">ReturnStatement</span>(<span class="hljs-params">path</span>)</span>&#123;<br>        <span class="hljs-keyword">var</span> n = path.node.argument.name<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;\n这里是&quot;</span>, path.toString())<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;被绑定量：&#x27;</span>, path.scope.getBinding(n))<br>    &#125;<br>&#125;<br><br>traverse(ast, visitor);<br></code></pre></td></tr></table></figure><h5 id="Scope-getOwnBinding-name"><a href="#Scope-getOwnBinding-name" class="headerlink" title="Scope.getOwnBinding(name)"></a>Scope.getOwnBinding(name)</h5><p><code>@return Binding</code>  </p><p>传入一个名称，从当前的 作用域 中拿到指定的 被绑定量对象<a href="#Binding"><code>Binding</code></a><br>实际上方法的源码就一句<code>return this.bindings[name];</code>    </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> parser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/parser&quot;</span>);<br><span class="hljs-keyword">const</span> traverse = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/traverse&quot;</span>).default;<br><br><span class="hljs-keyword">const</span> jscode = <span class="hljs-string">`</span><br><span class="hljs-string">var g = 1;</span><br><span class="hljs-string">function a()&#123;var a=1;return g;&#125;</span><br><span class="hljs-string">`</span>;<br><span class="hljs-keyword">let</span> ast = parser.parse(jscode);<br><span class="hljs-keyword">const</span> visitor = &#123;<br>    <span class="hljs-function"><span class="hljs-title">ReturnStatement</span>(<span class="hljs-params">path</span>)</span>&#123;<br>        <span class="hljs-keyword">var</span> n = path.node.argument.name<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;\n这里是&quot;</span>, path.toString())<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;获取挡墙定义域里 a的Binding，结果：&#x27;</span>, path.scope.bindings[<span class="hljs-string">&#x27;a&#x27;</span>])<br>    &#125;<br>&#125;<br><br>traverse(ast, visitor);<br></code></pre></td></tr></table></figure><h5 id="Scope-getBindingIdentifier-name"><a href="#Scope-getBindingIdentifier-name" class="headerlink" title="Scope.getBindingIdentifier(name)"></a>Scope.getBindingIdentifier(name)</h5><p><code>@return Node | void 0</code><br>获取指定的  <a href="#Binding"><code>Binding</code></a> 的定义节点<code>Node</code>  </p><p>方法作用域获取 <a href="#Binding"><code>Binding</code></a> ，再通过这个  <a href="#Binding"><code>Binding</code></a>  获取其定义的节点  </p><p>这个方法通过 <a href="#Scope_getBinding"><code>Scope.getBinding(name)</code></a> 方法获取 <a href="#Binding"><code>Binding</code></a>  ，所以会存在递归向上的情况  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> parser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/parser&quot;</span>);<br><span class="hljs-keyword">const</span> traverse = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/traverse&quot;</span>).default;<br><br><span class="hljs-keyword">const</span> jscode = <span class="hljs-string">`</span><br><span class="hljs-string">var g = 1;</span><br><span class="hljs-string">function a()&#123;return g;&#125;</span><br><span class="hljs-string">function b()&#123;var z=2; return z;&#125;</span><br><span class="hljs-string">`</span>;<br><span class="hljs-keyword">let</span> ast = parser.parse(jscode);<br><span class="hljs-keyword">const</span> visitor = &#123;<br>    <span class="hljs-function"><span class="hljs-title">ReturnStatement</span>(<span class="hljs-params">path</span>)</span>&#123;<br>        <span class="hljs-keyword">var</span> n = path.node.argument.name<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;\n这里是&quot;</span>, path.toString())<br>        <span class="hljs-built_in">console</span>.log(n, <span class="hljs-string">&#x27;的定义：&#x27;</span>, path.scope.getBindingIdentifier(n))<br>    &#125;<br>&#125;<br><br>traverse(ast, visitor);<br></code></pre></td></tr></table></figure><h5 id="Scope-getOwnBindingIdentifier-name"><a href="#Scope-getOwnBindingIdentifier-name" class="headerlink" title="Scope.getOwnBindingIdentifier(name)"></a>Scope.getOwnBindingIdentifier(name)</h5><p><code>@return Node|void 0</code><br>获取指定的 <a href="#Binding"><code>Binding</code></a> ，并通过这个  <a href="#Binding"><code>Binding</code></a>  获取其定义的节点<br>这个方法只关注 当前作用域，并不会向上寻找    </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> parser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/parser&quot;</span>);<br><span class="hljs-keyword">const</span> traverse = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/traverse&quot;</span>).default;<br><br><span class="hljs-keyword">const</span> jscode = <span class="hljs-string">`</span><br><span class="hljs-string">var g = 1;</span><br><span class="hljs-string">function a()&#123;return g;&#125;</span><br><span class="hljs-string">function b()&#123;var z=2; return z;&#125;</span><br><span class="hljs-string">`</span>;<br><span class="hljs-keyword">let</span> ast = parser.parse(jscode);<br><span class="hljs-keyword">const</span> visitor = &#123;<br>    <span class="hljs-function"><span class="hljs-title">ReturnStatement</span>(<span class="hljs-params">path</span>)</span>&#123;<br>        <span class="hljs-keyword">var</span> n = path.node.argument.name<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;\n这里是&quot;</span>, path.toString())<br>        <span class="hljs-built_in">console</span>.log(n, <span class="hljs-string">&#x27;的定义：&#x27;</span>, path.scope.getOwnBindingIdentifier(n))<br>    &#125;<br>&#125;<br><br>traverse(ast, visitor);<br></code></pre></td></tr></table></figure><p>得到结果:  </p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs less">这里是 <span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">g</span>;<br><span class="hljs-selector-tag">g</span> 的定义： <span class="hljs-selector-tag">undefined</span><br><br>这里是 <span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">z</span>;<br><span class="hljs-selector-tag">z</span> 的定义： <span class="hljs-selector-tag">Node</span> &#123;<br>  <span class="hljs-attribute">type</span>: <span class="hljs-string">&#x27;Identifier&#x27;</span>,<br>  <span class="hljs-attribute">start</span>: <span class="hljs-number">53</span>,<br>  <span class="hljs-attribute">end</span>: <span class="hljs-number">54</span>,<br>  <span class="hljs-attribute">loc</span>: SourceLocation &#123;<br>    <span class="hljs-attribute">start</span>: Position &#123; <span class="hljs-attribute">line</span>: <span class="hljs-number">4</span>, <span class="hljs-attribute">column</span>: <span class="hljs-number">17</span> &#125;,<br>    <span class="hljs-attribute">end</span>: Position &#123; <span class="hljs-attribute">line</span>: <span class="hljs-number">4</span>, <span class="hljs-attribute">column</span>: <span class="hljs-number">18</span> &#125;,<br>    <span class="hljs-attribute">identifierName</span>: <span class="hljs-string">&#x27;z&#x27;</span><br>  &#125;,<br>  <span class="hljs-attribute">name</span>: <span class="hljs-string">&#x27;z&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="Scope-hasOwnBinding-name"><a href="#Scope-hasOwnBinding-name" class="headerlink" title="Scope.hasOwnBinding(name)"></a>Scope.hasOwnBinding(name)</h5><p><code>@return bool</code>  </p><p>获知当前作用域是否有某个被绑定变量  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> parser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/parser&quot;</span>);<br><span class="hljs-keyword">const</span> traverse = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/traverse&quot;</span>).default;<br><br><span class="hljs-keyword">const</span> jscode = <span class="hljs-string">`</span><br><span class="hljs-string">var g = 1;</span><br><span class="hljs-string">function a()&#123;return g;&#125;</span><br><span class="hljs-string">function b()&#123;var z=2; return z;&#125;</span><br><span class="hljs-string">`</span>;<br><span class="hljs-keyword">let</span> ast = parser.parse(jscode);<br><span class="hljs-keyword">const</span> visitor = &#123;<br>    <span class="hljs-function"><span class="hljs-title">ReturnStatement</span>(<span class="hljs-params">path</span>)</span>&#123;<br>        <span class="hljs-keyword">var</span> n = path.node.argument.name<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;\n这里是&quot;</span>, path.toString())<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;当前作用域有 被绑定变量 z:&#x27;</span>, path.scope.hasOwnBinding(<span class="hljs-string">&#x27;z&#x27;</span>))<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;当前作用域有 被绑定变量 g:&#x27;</span>, path.scope.hasOwnBinding(<span class="hljs-string">&#x27;g&#x27;</span>))<br>    &#125;<br>&#125;<br><br>traverse(ast, visitor);<br><br></code></pre></td></tr></table></figure><p>得到结果：  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript">这里是 <span class="hljs-keyword">return</span> g;<br>当前作用域有 被绑定变量 z: <span class="hljs-literal">false</span><br>当前作用域有 被绑定变量 g: <span class="hljs-literal">false</span><br><br>这里是 <span class="hljs-keyword">return</span> z;<br>当前作用域有 被绑定变量 z: <span class="hljs-literal">true</span><br>当前作用域有 被绑定变量 g: <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p>两个函数的作用域内都不会有g的绑定，因为它被绑定在更上级作用域中  </p><h5 id="Scope-hasBinding-name-noGlobals"><a href="#Scope-hasBinding-name-noGlobals" class="headerlink" title="Scope.hasBinding(name, noGlobals)"></a>Scope.hasBinding(name, noGlobals)</h5><p><code>@return bool</code><br>向上递归作用域，获知是否有某个被绑定变量  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> parser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/parser&quot;</span>);<br><span class="hljs-keyword">const</span> traverse = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/traverse&quot;</span>).default;<br><br><span class="hljs-keyword">const</span> jscode = <span class="hljs-string">`</span><br><span class="hljs-string">var g = 1;</span><br><span class="hljs-string">function a()&#123;return g;&#125;</span><br><span class="hljs-string">function b()&#123;var z=2; return z;&#125;</span><br><span class="hljs-string">`</span>;<br><span class="hljs-keyword">let</span> ast = parser.parse(jscode);<br><span class="hljs-keyword">const</span> visitor = &#123;<br>    <span class="hljs-function"><span class="hljs-title">ReturnStatement</span>(<span class="hljs-params">path</span>)</span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;\n这里是&quot;</span>, path.toString())<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;作用域有 被绑定变量 z:&#x27;</span>, path.scope.hasBinding(<span class="hljs-string">&#x27;z&#x27;</span>))<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;作用域有 被绑定变量 g:&#x27;</span>, path.scope.hasBinding(<span class="hljs-string">&#x27;g&#x27;</span>))<br>    &#125;<br>&#125;<br><br>traverse(ast, visitor);<br></code></pre></td></tr></table></figure><p><a id="Binding"></a></p><h3 id="Binding"><a href="#Binding" class="headerlink" title="Binding"></a>Binding</h3><p><code>Binding</code> 对象用于存储 被绑定在作用域的量 的信息<br>你可以在 <code>@babel/traverse/lib/scope/binding.js</code> 查看到它的定义  </p><h4 id="Binding属性"><a href="#Binding属性" class="headerlink" title="Binding属性"></a>Binding属性</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> parser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/parser&quot;</span>);<br><span class="hljs-keyword">const</span> traverse = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/traverse&quot;</span>).default;<br><br><span class="hljs-keyword">const</span> jscode = <span class="hljs-string">`</span><br><span class="hljs-string">function a()&#123;</span><br><span class="hljs-string">    var a = 1;</span><br><span class="hljs-string">    a = a + 1;</span><br><span class="hljs-string">    return a;</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">function b()&#123;</span><br><span class="hljs-string">    var b = 1;</span><br><span class="hljs-string">    var c = 2;</span><br><span class="hljs-string">    b = b - c;</span><br><span class="hljs-string">    return b;</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">`</span>;<br><span class="hljs-keyword">let</span> ast = parser.parse(jscode);<br><span class="hljs-keyword">const</span> visitor = &#123;<br>    <span class="hljs-function"><span class="hljs-title">BlockStatement</span>(<span class="hljs-params">path</span>)</span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;\n此块节点源码：\n&quot;</span>, path.toString())<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;----------------------------------------&#x27;</span>)<br>        <span class="hljs-keyword">var</span> bindings = path.scope.bindings<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;作用域内 被绑定量 数量：&#x27;</span>, <span class="hljs-built_in">Object</span>.keys(bindings).length)<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> binding_ <span class="hljs-keyword">in</span> bindings)&#123;<br>            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;名字：&#x27;</span>, binding_)<br>            binding_ = bindings[binding_];<br>            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;类型：&#x27;</span>, binding_.kind)<br>            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;定义：&#x27;</span>, binding_.identifier)<br>            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;是否为常量：&#x27;</span>, binding_.constant)<br>            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;被修改信息信息记录&#x27;</span>, binding_.constantViolations)<br>            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;是否会被引用：&#x27;</span>, binding_.referenced)<br>            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;被引用次数&#x27;</span>, binding_.references)<br>            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;被引用信息NodePath记录&#x27;</span>, binding_.referencePaths)<br>        &#125;<br>    &#125;<br>&#125;<br><br>traverse(ast, visitor);<br><br></code></pre></td></tr></table></figure><h2 id="comments"><a href="#comments" class="headerlink" title="comments"></a>comments</h2><p>注释相关  </p><h3 id="NodePath-addComment-type-content-line"><a href="#NodePath-addComment-type-content-line" class="headerlink" title="NodePath.addComment(type, content, line)"></a>NodePath.addComment(type, content, line)</h3><p><code>@return None</code>  </p><p>添加注释  </p><p>实际上只是调用<code>types.addComment</code> 的方法而已  </p><p>参数:  </p><ul><li><p><code>type</code> <code>str</code> 指定添加的注释方式，如果填入<code>&quot;leading&quot;</code>，则添加的注释会插入已有注释之前，否则在原有注释之后  </p></li><li><p><code>content</code> <code>str</code> 注释内容  </p></li><li><p><code>line</code> <code>bool</code> 插入行注释还是块注释  </p></li></ul><blockquote><p>例：插入注释  </p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> parser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/parser&quot;</span>);<br><span class="hljs-keyword">const</span> traverse = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/traverse&quot;</span>).default;<br><span class="hljs-keyword">const</span> generator = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/generator&quot;</span>).default;<br><br><span class="hljs-keyword">const</span> jscode = <span class="hljs-string">`</span><br><span class="hljs-string">  var a = 1 + 9;</span><br><span class="hljs-string">`</span>;<br><br><span class="hljs-keyword">const</span> ast = parser.parse(jscode);<br><span class="hljs-keyword">const</span> visitor = &#123;<br>  <span class="hljs-function"><span class="hljs-title">NumericLiteral</span>(<span class="hljs-params">path</span>)</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;当前节点源码:\n&#x27;</span>, path.toString());<br>    path.addComment(<span class="hljs-string">&#x27;trailing&#x27;</span>, <span class="hljs-string">&quot;注释&quot;</span>, <span class="hljs-literal">false</span>);<br>  &#125;<br>&#125;<br><br>traverse(ast, visitor);<br><span class="hljs-built_in">console</span>.log(generator(ast)[<span class="hljs-string">&#x27;code&#x27;</span>])<br></code></pre></td></tr></table></figure><h1 id="babel-types"><a href="#babel-types" class="headerlink" title="@babel/types"></a>@babel/types</h1><h2 id="utils"><a href="#utils" class="headerlink" title="utils"></a>utils</h2><p><a id='types_shallowEqual'></a></p><h3 id="Types-shallowEqual-actual-expected"><a href="#Types-shallowEqual-actual-expected" class="headerlink" title="Types.shallowEqual(actual, expected)"></a>Types.shallowEqual(actual, expected)</h3><p><code>@return bool</code>  </p><p>对比函数，<code>expected</code>传入一个字典进行 <code>key</code>, <code>value</code> 遍历  </p><p>获取 <code>actual</code>.<code>key</code> 的值与 <code>value</code> 进行对比  </p><p>如果有一个不一致，那么返回 <code>false</code>, 否则返回 <code>true</code>  </p><p>其定义在： <code>@babel/types/lib/validators/generated/index.js</code>  </p><blockquote><p>例：判断节点的name是否为<code>a</code>  </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs j\avascript">const parser &#x3D; require(&quot;@babel&#x2F;parser&quot;);<br>const traverse &#x3D; require(&quot;@babel&#x2F;traverse&quot;).default;<br>const t &#x3D; require(&quot;@babel&#x2F;types&quot;);<br><br>const jscode &#x3D; &#39;var a&#x3D;1; var b&#x3D;1+1;&#39;;<br>let ast &#x3D; parser.parse(jscode);<br><br>const visitor &#x3D; &#123;<br>  enter(path)&#123;<br>    console.log(&#39;当前节点源码：&#39;, path.toString())<br>    console.log(&#39;其属性name为a:&#39;, t.shallowEqual(path.node, &#123;&#39;name&#39;:&#39;a&#39;&#125;))<br>  &#125;<br>&#125;<br><br>traverse(ast, visitor);<br></code></pre></td></tr></table></figure><h2 id="validators"><a href="#validators" class="headerlink" title="validators"></a>validators</h2><h3 id="Types-isNodeType-node-opts"><a href="#Types-isNodeType-node-opts" class="headerlink" title="Types.isNodeType(node, opts)"></a>Types.isNodeType(node, opts)</h3><p><code>@return bool</code>  </p><p>这并不是一个函数，这是一大堆由生成代码生成的函数，大约有290个</p><p>这些函数定义在 <code>@babel/types/lib/validators/generated/index.js</code></p><p>函数逻辑都是类似的  </p><ol><li><p>if( 没有node ) return <code>false</code>  </p></li><li><p>if(<code>node.type</code> == <code>声明类型</code>) return <code>false</code>  </p></li><li><p>else if( 没有opts ) return <code>true</code></p></li><li><p>else return <a href="#types_shallowEqual">types.shallowEqual(node, opts)</a></p></li></ol><blockquote><p>例: 判断节点是否符合判断  </p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> parser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/parser&quot;</span>);<br><span class="hljs-keyword">const</span> traverse = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/traverse&quot;</span>).default;<br><span class="hljs-keyword">const</span> t = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/types&quot;</span>);<br><br><span class="hljs-keyword">const</span> jscode = <span class="hljs-string">&#x27;var a=1;var b=1+1;&#x27;</span>;<br><span class="hljs-keyword">let</span> ast = parser.parse(jscode);<br><br><span class="hljs-keyword">const</span> visitor = &#123;<br> <span class="hljs-function"><span class="hljs-title">enter</span>(<span class="hljs-params">path</span>)</span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;当前节点源码：&#x27;</span>, path.toString())<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;是 Identifier&#x27;</span>, t.isIdentifier(path.node))<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;是 Identifier 且其属性name为a:&#x27;</span>, t.isIdentifier(path.node, &#123;<span class="hljs-string">&#x27;name&#x27;</span>:<span class="hljs-string">&#x27;a&#x27;</span>&#125;))<br> &#125;<br>&#125;<br><br>traverse(ast, visitor);<br></code></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><hr><ul><li><a href="https://github.com/jamiebuilds/babel-handbook/blob/master/translations/zh-Hans/plugin-handbook.md#toc-bindings">https://github.com/jamiebuilds/babel-handbook/blob/master/translations/zh-Hans/plugin-handbook.md#toc-bindings</a>  </li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Javascript</tag>
      
      <tag>Babel</tag>
      
      <tag>API</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Javascript-Babel-AST-解混淆-基础</title>
    <link href="/post/7389a59f/"/>
    <url>/post/7389a59f/</url>
    
    <content type="html"><![CDATA[<h1 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h1><h2 id="抽象语法树-AST"><a href="#抽象语法树-AST" class="headerlink" title="抽象语法树 AST"></a>抽象语法树 AST</h2><blockquote><p>维基百科-抽象语法树：<a href="https://zh.wikipedia.org/wiki/%E6%8A%BD%E8%B1%A1%E8%AA%9E%E6%B3%95%E6%A8%B9">https://zh.wikipedia.org/wiki/%E6%8A%……</a>  </p></blockquote><p>抽象语法树（Abstract Syntax Tree，AST）是源代码语法结构的一种抽象表示<br>它以树状的形式表现编程语言的语法结构，树上的每个节点都表示源代码中的一种结构<br>之所以说语法是“抽象”的，是因为这里的语法并不会表示出真实语法中出现的每个细节  </p><blockquote><p>例:代码转抽象语法树  </p></blockquote><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus">while <span class="hljs-selector-tag">b</span> ≠ <span class="hljs-number">0</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-selector-tag">a</span> &gt; b<br>        <span class="hljs-selector-tag">a</span> := <span class="hljs-selector-tag">a</span> − b<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-selector-tag">b</span> := <span class="hljs-selector-tag">b</span> − a<br>    return a<br></code></pre></td></tr></table></figure><p><img src="/Javascript-Babel-AST-%E8%A7%A3%E6%B7%B7%E6%B7%86-%E5%9F%BA%E7%A1%80/20201224050050034.png">  </p><h2 id="链接信息"><a href="#链接信息" class="headerlink" title="链接信息"></a>链接信息</h2><table><thead><tr><th>信息</th><th>地址</th></tr></thead><tbody><tr><td>AST在线解析</td><td><a href="https://astexplorer.net/">https://astexplorer.net/</a></td></tr><tr><td>babel中文文档</td><td><a href="https://www.babeljs.cn/docs/">https://www.babeljs.cn/docs/</a></td></tr><tr><td>babel英文文档</td><td><a href="https://babeljs.io/docs/en/">https://babeljs.io/docs/en/</a></td></tr><tr><td>Github</td><td><a href="https://github.com/babel/babel">https://github.com/babel/babel</a></td></tr><tr><td>插件手册</td><td><a href="https://blog.csdn.net/weixin_33826609/article/details/93164633#toc-visitors">https://blog.csdn.net/weixin_33826609/article/details/93164633#toc-visitors</a></td></tr></tbody></table><table><thead><tr><th>信息</th><th>地址</th></tr></thead><tbody><tr><td>babel各节点解释</td><td><a href="https://github.com/babel/babylon/blob/master/ast/spec.md">https://github.com/babel/babylon/blob/master/ast/spec.md</a></td></tr><tr><td>babel简单剖析</td><td><a href="http://www.alloyteam.com/2017/04/analysis-of-babel-babel-overview/">http://www.alloyteam.com/2017/04/analysis-of-babel-babel-overview/</a></td></tr><tr><td>淘宝前端团队写的babel相关</td><td><a href="https://fed.taobao.org/blog/taofed/do71ct/babel-plugins/">https://fed.taobao.org/blog/taofed/do71ct/babel-plugins/</a></td></tr><tr><td>babel到底将代码转换成什么</td><td><a href="http://www.alloyteam.com/2016/05/babel-code-into-a-bird-like/">http://www.alloyteam.com/2016/05/babel-code-into-a-bird-like/</a></td></tr></tbody></table><h1 id="安装-使用环境"><a href="#安装-使用环境" class="headerlink" title="安装/使用环境"></a>安装/使用环境</h1><h2 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h2><h3 id="安装-Node-js-与Babel"><a href="#安装-Node-js-与Babel" class="headerlink" title="安装 Node.js 与Babel"></a>安装 Node.js 与Babel</h3><p>首先你要有<code>Node.js</code>环境  </p><a href="#">Post not found: Node.js</a><p>全局安装 <code>babel</code>的各个库  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install @babel/core -g<br>npm install @babel/parser -g<br>npm install @babel/traverse -g<br>npm install @babel/generator -g<br>npm install @babel/types -g<br></code></pre></td></tr></table></figure><p>简单描述一下刚刚安装的库的作用：   </p><ul><li><code>@babel/core</code>是 <code>Babel</code> 的核心代码  </li><li><code>@babel/parser</code>常用于解析代码语法树的模块  </li><li><code>@babel/traverse</code>常用于操作语法树的模块  </li><li><code>@babel/generator</code>常用于将语法树生成代码的模块  </li><li><code>@babel/types</code> 包含类型信息，在生成节点等与类型相关的操作会用到</li></ul><h3 id="安装测试"><a href="#安装测试" class="headerlink" title="安装测试"></a>安装测试</h3><p>启动 <code>Node.js</code> 环境  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">node<br></code></pre></td></tr></table></figure><p>引入babel库，测试是否成功  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> parser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/parser&quot;</span>);<br></code></pre></td></tr></table></figure><p>这一步可能会出现说没有库的问题，这是由于环境变量导致的<br>一般而言，安装<code>Node.js</code>会默认配置上环境变量，但这个配置不一定有用<br>此时你可以手动设置环境变量，或者用绝对路径来引入  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> parser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;E:/Environment/Nodejs/node_global/node_modules/@babel/parser&quot;</span>);<br></code></pre></td></tr></table></figure><h2 id="在线解析网站"><a href="#在线解析网站" class="headerlink" title="在线解析网站"></a>在线解析网站</h2><p>链接： <a href="https://astexplorer.net/">https://astexplorer.net/</a><br>这个是一个解析代码语法树的网站<br>这里是需要用它的<code>Babel</code>解析语法树，所以要做对应设置<br><img src="/Javascript-Babel-AST-%E8%A7%A3%E6%B7%B7%E6%B7%86-%E5%9F%BA%E7%A1%80/20200830085956301.png"><br>打开以后将解析方式改为<code>@babel/parser</code><br>在左边的文本框里输入一些代码，就能在右边看到对应解析出来的语法树了  </p><h1 id="认识AST"><a href="#认识AST" class="headerlink" title="认识AST"></a>认识AST</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>如果将代码中各类的语句都看成节点，那么整个程序的代码就像是由一个个节点组成的树状结构，代码的运行就像是不完全遍历这颗树一样  </p><p>AST解析源代码实际上就是这样干的<br>在代码解析完成后，你会得到一颗语法树，这颗语法树包含了代码中的所有内容  </p><p>你可以对它进行树（数据结构）可以进行的所有操作（从复杂的 <code>有序树转二叉树</code> 到简单的 <code>替换节点</code>，<code>计算树的深度</code>，<code>剪枝</code>，<code>拼接</code>都可以）  </p><p>最后想象一下，程序运行 就是在这棵树里进行 <code>深度优先遍历</code>  </p><blockquote><p>实际上，它的结果更接近图（数据结构），因为可能存在调用循环/递归（树中的节点不允许连接自身或有多个父级）  </p></blockquote><h2 id="常见节点信息解析"><a href="#常见节点信息解析" class="headerlink" title="常见节点信息解析"></a>常见节点信息解析</h2><table><thead><tr><th>节点属性</th><th>记录的信息</th></tr></thead><tbody><tr><td>type</td><td>当前节点的类型</td></tr><tr><td>start</td><td>当前节点的起始位</td></tr><tr><td>end</td><td>当前节点的末尾</td></tr><tr><td>loc</td><td>当前节点所在的行列位置<br>起始于结束的行列信息</td></tr><tr><td>errors</td><td>File节点所持有的特有属性，可以不用理会</td></tr><tr><td>program</td><td>包含整个源代码，不包含注释节点</td></tr><tr><td>comments</td><td>源代码中所有的注释会显示在这里</td></tr></tbody></table><p>就这么直接列出来可能还不太容易理解<br>可以利用 <a href="https://astexplorer.net/">在线解析网站</a>  解析一小段<code>javascript</code>代码来帮助理解/记忆  </p><p>输入仪式性的语句  <code>console.log(&quot;Hello World&quot;)</code>  的变种代码  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 这是一段源代码，作用就是计算，输出一些字符</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params"></span>)</span>&#123;<br>  <span class="hljs-keyword">var</span> i = [<span class="hljs-string">&#x27;H&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;l&#x27;</span>, <span class="hljs-string">&#x27;l&#x27;</span>, <span class="hljs-string">&#x27;o&#x27;</span>, <span class="hljs-string">&#x27; &#x27;</span>, <span class="hljs-string">&#x27;W&#x27;</span>, <span class="hljs-string">&#x27;o&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>, <span class="hljs-string">&#x27;l&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>];<br>  i = i.join(<span class="hljs-string">&#x27;&#x27;</span>);<br>  <span class="hljs-keyword">return</span> i<br>&#125;<br><span class="hljs-built_in">console</span>.log(test())<br></code></pre></td></tr></table></figure><h3 id="最外层File节点"><a href="#最外层File节点" class="headerlink" title="最外层File节点"></a>最外层<code>File节点</code></h3><p><img src="/Javascript-Babel-AST-%E8%A7%A3%E6%B7%B7%E6%B7%86-%E5%9F%BA%E7%A1%80/20200901023343710.png"><br>先将节点收得差不多，观察最外面的<code>File节点</code>的信息  </p><ul><li><code>type</code> <code>start</code> <code>end</code> <code>loc</code> 你能在绝大多数节点里看到  </li><li>常用的类型判断方法<code>t.is****(node)</code>就是判断当前节点type是否为某个类型  </li></ul><h3 id="层级结构分析"><a href="#层级结构分析" class="headerlink" title="层级结构分析"></a>层级结构分析</h3><p>实际上，可以通过观察 <code>type</code> 知道一些信息  </p><blockquote><p>层级分析例1:<br><img src="/Javascript-Babel-AST-%E8%A7%A3%E6%B7%B7%E6%B7%86-%E5%9F%BA%E7%A1%80/20200901023523804.png"><br>比如说这整个文件包含了了代码块主要有两部分： <strong>一个函数声明</strong> 和 <strong>一句语句</strong>  </p></blockquote><br><blockquote><p>层级分析例2:<br><img src="/Javascript-Babel-AST-%E8%A7%A3%E6%B7%B7%E6%B7%86-%E5%9F%BA%E7%A1%80/20200901082003100.png"><br>又比如说，这个函数里包含了三个部分：<strong>一个声明</strong>，<strong>一个语句</strong>，<strong>一个返回</strong>  </p></blockquote><h2 id="解析代码-Code→AST"><a href="#解析代码-Code→AST" class="headerlink" title="解析代码 Code→AST"></a>解析代码 Code→AST</h2><p><code>@babel/parser</code>能将<code>javascript</code>代码解析成语法树<br>这个库在前文中已经安装好了，现在用它来解析语法树吧  </p><blockquote><p>例：用babel解析语法树  </p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> parser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/parser&quot;</span>);<br><br><span class="hljs-keyword">var</span> jscode = <span class="hljs-string">&quot;var a = 123;&quot;</span>;<br><span class="hljs-keyword">let</span> ast = parser.parse(jscode);<br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">JSON</span>.stringify(ast, <span class="hljs-literal">null</span>, <span class="hljs-string">&#x27;\t&#x27;</span>));<br></code></pre></td></tr></table></figure><p>此处会输出和网页解析出来的内容一样的结果<br>做简单分析时，用网页解析比较快捷方便，很少写代码来解析  </p><h2 id="AST寻路"><a href="#AST寻路" class="headerlink" title="AST寻路"></a>AST寻路</h2><p>在解析出语法树后，就可以进行各类的操作了<br>但和想要对树（数据结构）进行任何操作一样，在对AST进行各类操作之前，你要先会 寻路 （到达(遍历到)指定的节点）才能进行操作  </p><blockquote><p>寻路这个词是我自己瞎编的  </p></blockquote><h3 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h3><p>想要约朋友来家里玩，可以向别人描述 家的附近 或者 家本身 有什么特征。比如说:</p><blockquote><p>“我家门口有一颗歪脖子树” 或者 “我家房顶有一个大洞”  </p></blockquote><p>这样子能很方便得让别人找到位置  </p><p>寻路的过程也一样。想要到达 某个/某些 特定节点上，可以根据这个节点的 <code>类型</code> 与 <code>路径</code> 给出判断依据来到达特定的 某个/某些 节点  </p><h3 id="遍历整个语法树"><a href="#遍历整个语法树" class="headerlink" title="遍历整个语法树"></a>遍历整个语法树</h3><p>绝大多数情况下，对AST进行寻路比上面描述的情况更糟糕一些  </p><blockquote><p><strong>在AST中寻路的情况更像是：</strong><br>你的朋友坐在一个城市观光车上，观光车会穿过城市里的每一个街道。你的朋友无法控制车前进的方向，你只能让车在你描述的情况下停下，用这种方式来到达你家    </p></blockquote><p>默认情况下，<code>@babel/traverse</code>能让你遍历整个AST<br>如果想要寻路到达某个节点，就需要给出你想要寻路的 那个/那些 节点的特征进行判断操作  </p><h3 id="使用-Path-进行寻路"><a href="#使用-Path-进行寻路" class="headerlink" title="使用 Path 进行寻路"></a>使用 Path 进行寻路</h3><p>在使用 <code>enter</code> 遍历所有节点的时候，参数 <code>path</code> 会传入当前的路径<br>可以根据<code>path</code>进行各种判断，继而进行各类操作  </p><h4 id="Path基本信息"><a href="#Path基本信息" class="headerlink" title="Path基本信息"></a>Path基本信息</h4><ul><li>获取 <code>Path</code>对应节点的 源代码 <code>path.toString()</code>  </li><li>获取 <code>Path</code>对应节点的 类型 <code>path.type</code>  </li></ul><blockquote><p>例: 寻找代码中包含 字符a 的节点  </p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> parser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/parser&quot;</span>);<br><span class="hljs-keyword">const</span> traverse = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/traverse&quot;</span>).default;<br><br><span class="hljs-keyword">var</span> jscode = <span class="hljs-string">`</span><br><span class="hljs-string">    var b = 123;</span><br><span class="hljs-string">    a = b + 1;</span><br><span class="hljs-string">`</span>;<br><br><span class="hljs-keyword">const</span> visitor = &#123;<br>    enter(path)  <span class="hljs-comment">// 此处会遍历所有的节点，并得到对应的路径</span><br>    &#123;<br>        <span class="hljs-keyword">if</span>(path.toString().indexOf(<span class="hljs-string">&#x27;a&#x27;</span>) &gt; -<span class="hljs-number">1</span>)&#123;  <span class="hljs-comment">// 根据路径，得到对应的代码，如果其中包含 字符a 则输出信息</span><br>            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;当前路径类型&#x27;</span>, path.type); <span class="hljs-comment">// 打印当前路径类型</span><br>            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;当前路径源码：&#x27;</span>, path.toString()); <span class="hljs-comment">// 打印当前路径所对应的源代码</span><br>            <span class="hljs-comment">// is + 节点类型全名, 能判断当前路径节点的类型是否是声明的类型</span><br>            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;这是一个变量声明节点:\t&#x27;</span>, path.isVariableDeclaration())<br>            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;--------------------&#x27;</span>)<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">let</span> ast = parser.parse(jscode);<br>traverse(ast, visitor);  <span class="hljs-comment">// traverse会遍历所有的节点</span><br></code></pre></td></tr></table></figure><p>会得到如下的结果  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs bash">当前路径类型 Program<br>当前路径源码： var b = 123;<br>a = b + 1;<br>这是一个变量声明节点: <span class="hljs-literal">false</span><br>--------------------<br>当前路径类型 VariableDeclaration<br>当前路径源码： var b = 123;<br>这是一个变量声明节点: <span class="hljs-literal">true</span><br>--------------------<br>当前路径类型 ExpressionStatement<br>当前路径源码： a = b + 1;<br>这是一个变量声明节点: <span class="hljs-literal">false</span><br>--------------------<br>当前路径类型 AssignmentExpression<br>当前路径源码： a = b + 1<br>这是一个变量声明节点: <span class="hljs-literal">false</span><br>--------------------<br>当前路径类型 Identifier<br>当前路径源码： a<br>这是一个变量声明节点: <span class="hljs-literal">false</span><br>--------------------<br></code></pre></td></tr></table></figure><p>此处是对源代码进行判断，所以<code>var</code>这种关键词也是会被认为是包含<code>a</code>的  </p><h3 id="使用-节点-进行寻路"><a href="#使用-节点-进行寻路" class="headerlink" title="使用 节点 进行寻路"></a>使用 节点 进行寻路</h3><blockquote><p>例子：根据特点寻找语法树中的节点</p><ul><li>特点：这个节点是一个 变量声明节点  </li></ul></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> parser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/parser&quot;</span>);<br><span class="hljs-keyword">const</span> traverse = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/traverse&quot;</span>).default;<br><br><span class="hljs-keyword">var</span> jscode = <span class="hljs-string">&quot;var a = 123;&quot;</span>;<br><br><span class="hljs-keyword">const</span> visitor = &#123;<br>    <span class="hljs-comment">// 这里的 VariableDeclaration 表明 需要的是 变量声明节点 </span><br>    VariableDeclaration(path)<br>    &#123;   <span class="hljs-comment">// 获取到 路径path 后，可以根据path的信息来进一步进行判断</span><br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;当前路径 源码:\n&#x27;</span>, path.toString());<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;当前路径 节点:\n&#x27;</span>, path.node.toString())<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;当前路径 父级节点:\n&#x27;</span>, path.parent.toString());<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;当前路径 父级路径:\n&#x27;</span>, path.parentPath.toString())<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;当前路径 类型:\n&#x27;</span>, path.type)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> ast = parser.parse(jscode);  <span class="hljs-comment">// 解析语法树</span><br>traverse(ast, visitor);  <span class="hljs-comment">// 遍历以进行操作</span><br></code></pre></td></tr></table></figure><p>由于直接输出<code>Node</code>会显示非常多的信息，此处用<code>toString()</code>意思意思<br>得到的输出结果：  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">当前路径 源码:<br> var a = 123;<br>当前路径 节点:<br> [object Object]<br>当前路径 父级节点:<br> [object Object]<br>当前路径 父级路径:<br> var a = 123;<br>当前路径 类型:<br> VariableDeclaration<br></code></pre></td></tr></table></figure><p>这里用了一个 <code>VariableDeclaration</code>（变量声明节点）来表述特点，更多得节点类型可以查看 <a href="https://github.com/babel/babylon/blob/master/ast/spec.md#node-objects">Github-Babel-节点类型文档</a>  </p><p><strong>注意：所有符合你描述的特点的节点都会进行声明中的操作</strong>（此处为输出信息）<br>由于此处只有一句声明语句的代码，所以随意给出一个合适的特点就能轻松到达目标节点<br>如果代码量大，又希望只改动部分，那么最好给出更多的语句以精确修改目标  </p><h2 id="用AST生成代码-AST→Code"><a href="#用AST生成代码-AST→Code" class="headerlink" title="用AST生成代码 AST→Code"></a>用AST生成代码 AST→Code</h2><p>尽管你现在可能还并不知道如何对语法树节点进行操作<br>但根据AST生成代码的方法还是要学会的，要不然最终结果长什么样都不知道  </p><p>可以使用<code>@babel/generator</code>来实现 根据AST生成代码的这个过程  </p><blockquote><p>例：根据AST生成代码以查看修改结果  </p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> parser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/parser&quot;</span>);<br><span class="hljs-keyword">const</span> traverse = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/traverse&quot;</span>).default;<br><span class="hljs-keyword">const</span> generator = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/generator&quot;</span>).default;<br><br><span class="hljs-keyword">const</span> jscode = <span class="hljs-string">&#x27;function squire()&#123;var n = 3; return n*n;&#125;&#x27;</span>;<br><span class="hljs-keyword">let</span> ast = parser.parse(jscode);<br><br><span class="hljs-keyword">const</span> visitor = &#123;<br>  <span class="hljs-function"><span class="hljs-title">BinaryExpression</span>(<span class="hljs-params">path</span>)</span> &#123;  <span class="hljs-comment">// 寻找所有 二元表达式节点</span><br>    <span class="hljs-keyword">if</span> (path.node.operator == <span class="hljs-string">&#x27;*&#x27;</span>) &#123;  <span class="hljs-comment">// 并且这个表达式节点的操作是做 乘法 </span><br>      path.node.operator = <span class="hljs-string">&#x27;+&#x27;</span>;  <span class="hljs-comment">// 将操作改为 加</span><br>    &#125;<br>  &#125;<br>&#125;<br><br>traverse(ast, visitor);  <span class="hljs-comment">// 对AST进行操作</span><br><span class="hljs-built_in">console</span>.log(generator(ast)[<span class="hljs-string">&#x27;code&#x27;</span>]);  <span class="hljs-comment">// 使用 generator 利用AST生成对应的代码</span><br></code></pre></td></tr></table></figure><p>运行后会输出结果  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">squire</span></span>() &#123;<br>  var n = 3;<br>  <span class="hljs-built_in">return</span> n + n;<br>&#125;<br></code></pre></td></tr></table></figure><p>此处将所有的表达式乘法转为加法，并且将改变后的AST利用<code>@babel/generator</code>生成出新的代码  </p><h2 id="常用基础操作"><a href="#常用基础操作" class="headerlink" title="常用基础操作"></a>常用基础操作</h2><h3 id="创建节点"><a href="#创建节点" class="headerlink" title="创建节点"></a>创建节点</h3><p><code>@babel/types</code>包含了各个节点的定义<br>可以通过使用<code>@babel/types</code>的类型名，查阅<a href="https://babeljs.io/docs/en/babel-types"><code>@babel/types</code>官方文档</a>，获取对应类型的构造函数，创建对应类型的节点  </p><blockquote><p>例：利用 @babel/types 提供的类来直接创建节点，编写ast内容  </p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> t = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/types&quot;</span>);<br><span class="hljs-keyword">const</span> generator = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/generator&quot;</span>).default;<br><br><span class="hljs-keyword">var</span> callee = t.memberExpression(t.identifier(<span class="hljs-string">&#x27;console&#x27;</span>), t.identifier(<span class="hljs-string">&#x27;log&#x27;</span>)),<br>    args = [t.NumericLiteral(<span class="hljs-number">666</span>)],<br>    call_exp = t.callExpression(callee, args),<br>    exp_statement = t.ExpressionStatement(call_exp)<br><br><span class="hljs-built_in">console</span>.log(generator(exp_statement)[<span class="hljs-string">&#x27;code&#x27;</span>])<br></code></pre></td></tr></table></figure><p>输出结果：  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(<span class="hljs-number">666</span>)<br></code></pre></td></tr></table></figure><h3 id="插入节点"><a href="#插入节点" class="headerlink" title="插入节点"></a>插入节点</h3><p><code>NodePath.insertAfter()</code>方法用于在当前<code>path</code>前面插入节点<br><code>NodePath.insertBefore()</code>方法用于在当前<code>path</code>后面插入节点  </p><blockquote><p>例：向语法树中插入节点  </p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> t = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/types&quot;</span>);<br><span class="hljs-keyword">const</span> parser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/parser&quot;</span>);<br><span class="hljs-keyword">const</span> traverse = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/traverse&quot;</span>).default;<br><span class="hljs-keyword">const</span> generator = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/generator&quot;</span>).default;<br><br><span class="hljs-keyword">const</span> jscode = <span class="hljs-string">`function square(n) &#123;</span><br><span class="hljs-string">  var a = 2;</span><br><span class="hljs-string">&#125;`</span>;<br><br><span class="hljs-keyword">const</span> ast = parser.parse(jscode);<br><span class="hljs-keyword">const</span> visitor = &#123;<br>  <span class="hljs-function"><span class="hljs-title">VariableDeclaration</span>(<span class="hljs-params">path</span>)</span> &#123;  <span class="hljs-comment">// 找到变量声明节点，删除</span><br>    <span class="hljs-keyword">var</span> node = t.NumericLiteral(<span class="hljs-number">1</span>)  <span class="hljs-comment">// 使用 types 来生成一个数字节点</span><br>    path.insertAfter(node)  <span class="hljs-comment">// 在当前path前面插入节点</span><br>    node = t.NumericLiteral(<span class="hljs-number">3</span>)<br>    path.insertBefore(node)  <span class="hljs-comment">// 在当前path后面插入</span><br>  &#125;<br>&#125;<br><br>traverse(ast, visitor);<br><span class="hljs-built_in">console</span>.log(generator(ast)[<span class="hljs-string">&#x27;code&#x27;</span>])<br></code></pre></td></tr></table></figure><p>结果：  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">square</span>(<span class="hljs-params">n</span>) </span>&#123;<br>  <span class="hljs-number">3</span><br>  <span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>;<br>  <span class="hljs-number">1</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="替换节点"><a href="#替换节点" class="headerlink" title="替换节点"></a>替换节点</h3><p><code>NodePath.replaceInline</code> 方法用于替换对应path的节点  </p><blockquote><p>例：寻找计算节点，计算好了以后，生成新的数字节点，替换原本的节点  </p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> t = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/types&quot;</span>);<br><span class="hljs-keyword">const</span> parser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/parser&quot;</span>);<br><span class="hljs-keyword">const</span> traverse = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/traverse&quot;</span>).default;<br><span class="hljs-keyword">const</span> generator = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/generator&quot;</span>).default;<br><br><span class="hljs-keyword">const</span> jscode = <span class="hljs-string">`function square(n) &#123;</span><br><span class="hljs-string">  return 1 + 1;</span><br><span class="hljs-string">&#125;`</span>;<br><br><span class="hljs-keyword">const</span> ast = parser.parse(jscode);<br><span class="hljs-keyword">const</span> visitor = &#123;<br>  <span class="hljs-function"><span class="hljs-title">BinaryExpression</span>(<span class="hljs-params">path</span>)</span> &#123;<br>    <span class="hljs-keyword">var</span> result = <span class="hljs-built_in">eval</span>(path.toString())  <span class="hljs-comment">// 计算表达式结果</span><br>    <span class="hljs-keyword">var</span> node = t.NumericLiteral(result)  <span class="hljs-comment">// 使用 types 来生成一个数字节点</span><br>    path.replaceInline(node);   <span class="hljs-comment">// 用新的节点来替换表达式内容</span><br>  &#125;<br>&#125;<br><br>traverse(ast, visitor);<br><span class="hljs-built_in">console</span>.log(generator(ast)[<span class="hljs-string">&#x27;code&#x27;</span>])<br></code></pre></td></tr></table></figure><p>得到结果：  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">square</span>(<span class="hljs-params">n</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h3><p><code>NodePath.remove()</code>用于删除路径对应的节点<br>由于是对<code>path</code>操作，所以务必注意不要误删  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> parser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/parser&quot;</span>);<br><span class="hljs-keyword">const</span> traverse = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/traverse&quot;</span>).default;<br><span class="hljs-keyword">const</span> generator = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/generator&quot;</span>).default;<br><br><span class="hljs-keyword">const</span> jscode = <span class="hljs-string">`function square(n) &#123;</span><br><span class="hljs-string">  var a = 1;</span><br><span class="hljs-string">  return 1 + 1;</span><br><span class="hljs-string">&#125;`</span>;<br><br><span class="hljs-keyword">const</span> ast = parser.parse(jscode);<br><span class="hljs-keyword">const</span> visitor = &#123;<br>  <span class="hljs-function"><span class="hljs-title">VariableDeclaration</span>(<span class="hljs-params">path</span>)</span> &#123;  <span class="hljs-comment">// 找到变量声明节点，删除</span><br>      path.remove()<br>  &#125;<br>&#125;<br><br>traverse(ast, visitor);<br><span class="hljs-built_in">console</span>.log(generator(ast)[<span class="hljs-string">&#x27;code&#x27;</span>])<br></code></pre></td></tr></table></figure><p>得到结果：  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">square</span>(<span class="hljs-params">n</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="作用域Scope-与-被绑定量Binding"><a href="#作用域Scope-与-被绑定量Binding" class="headerlink" title="作用域Scope 与 被绑定量Binding"></a>作用域Scope 与 被绑定量Binding</h1><h2 id="词汇描述"><a href="#词汇描述" class="headerlink" title="词汇描述"></a>词汇描述</h2><ul><li><p><strong>作用域scope</strong> - 有效范围<br>作用域（<code>scope</code>，或译作有效范围）是名字（<code>name</code>）与实体（<code>entity</code>）的绑定（<code>binding</code>）保持有效的那部分计算机程序<br>不同的编程语言可能有不同的作用域和名字解析。而同一语言内也可能存在多种作用域，随实体的类型变化而不同<br>作用域类别影响变量的绑定方式，根据语言使用静态作用域还是动态作用域变量的取值可能会有不同的结果  </p><blockquote><p>摘自：<a href="https://zh.wikipedia.org/wiki/%E4%BD%9C%E7%94%A8%E5%9F%9F">维基百科-作用域</a>  </p></blockquote></li><li><p><strong>名字绑定binding</strong><br>名字绑定(简称绑定)是把实体（数据 或/且 代码）关联到标识符<br>标识符绑定到实体被称为引用该对象<br>机器语言没有内建的标识符表示方法，但程序设计语言实现了名字与对象的绑定<br>绑定最初是与作用域相关，因为作用域确定了哪个名字绑定到哪个对象——在程序代码中的哪个位置与哪条执行路径  </p><blockquote><p>摘自：<a href="https://zh.wikipedia.org/wiki/%E5%90%8D%E5%AD%97%E7%BB%91%E5%AE%9A">维基百科-名字与绑定</a>  </p></blockquote></li></ul><p><strong>最简易理解</strong>  </p><p>对于复杂程度不高的代码，可以可简单的理解为：</p><ul><li>一个<strong>函数</strong>就是一个<strong>作用域</strong>  </li><li>一个<strong>变量</strong>就是一个<strong>名字绑定</strong>，绑定在<strong>作用域</strong>上  </li></ul><p>这对于复杂的代码可能并不会成立，但用于学习最基本的内容已经足够  </p><h2 id="作用域-Scope"><a href="#作用域-Scope" class="headerlink" title="作用域 Scope"></a>作用域 Scope</h2><p><code>@Babel</code>解析出来的语法树节点对象会包含作用域信息，这个信息会作为节点<code>Node</code>对象的一个属性保存<br>这个属性本身是一个<code>Scope</code>对象，其定义位于<code>node_modules/@babel/traverse/lib/scope/index.js</code>中  </p><blockquote><p>例: 查看基本的 作用域与绑定 信息  </p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> parser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/parser&quot;</span>);<br><span class="hljs-keyword">const</span> traverse = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/traverse&quot;</span>).default;<br><br><span class="hljs-keyword">const</span> jscode = <span class="hljs-string">`</span><br><span class="hljs-string">function squire(i)&#123;</span><br><span class="hljs-string">    return i * i * i;</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">function i()</span><br><span class="hljs-string">&#123;</span><br><span class="hljs-string">    var i = 123;</span><br><span class="hljs-string">    i += 2;</span><br><span class="hljs-string">    return 123;</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">`</span>;<br><span class="hljs-keyword">let</span> ast = parser.parse(jscode);<br><span class="hljs-keyword">const</span> visitor = &#123;<br>    <span class="hljs-string">&quot;FunctionDeclaration&quot;</span>(path)&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;\n\n这里是函数 &quot;</span>, path.node.id.name + <span class="hljs-string">&#x27;()&#x27;</span>)<br>        path.scope.dump();<br>    &#125;<br>&#125;<br><br>traverse(ast, visitor);<br></code></pre></td></tr></table></figure><p>执行 <code>Scope.dump()</code>，会得到自底向上的 作用域与变量信息<br>得到结果：  </p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">这里是函数  squire()<br>------------------------------------------------------------<br># FunctionDeclaration<br><span class="hljs-code"> - i &#123; constant: true, references: 3, violations: 0, kind: &#x27;param&#x27; &#125;</span><br># Program<br><span class="hljs-code"> - squire &#123; constant: true, references: 0, violations: 0, kind: &#x27;hoisted&#x27; &#125;</span><br><span class="hljs-code"> - i &#123; constant: true, references: 0, violations: 0, kind: &#x27;hoisted&#x27; &#125;</span><br>------------------------------------------------------------<br><br><br>这里是函数  i()<br>------------------------------------------------------------<br># FunctionDeclaration<br><span class="hljs-code"> - i &#123; constant: false, references: 0, violations: 1, kind: &#x27;var&#x27; &#125;</span><br># Program<br><span class="hljs-code"> - squire &#123; constant: true, references: 0, violations: 0, kind: &#x27;hoisted&#x27; &#125;</span><br><span class="hljs-code"> - i &#123; constant: true, references: 0, violations: 0, kind: &#x27;hoisted&#x27; &#125;</span><br>------------------------------------------------------------<br></code></pre></td></tr></table></figure><p><strong>输出查看方法</strong>    </p><ul><li><p>每一个作用域都以<code>#</code>标识输出  </p></li><li><p>每一个绑定都以<code>-</code>标识输出  </p></li><li><p>对于单次输出，都是自底向上的<br>先输出当前作用域，再输出父级作用域，再输出父级的父级作用域……</p></li><li><p>对于单个绑定<code>Binding</code>，会输出4种信息  </p><ul><li>constant 变量在声明后，在作用域内是否会被使用  </li><li>references  被引用次数  </li><li>violations  被重新定义的次数  </li><li>kind  函数声明类型。param 参数, hoisted 提升，var 变量， local 内部  </li></ul><p>后续会单独说明<code>Binding</code>对象，此处留个印象即可  </p></li></ul><p><strong>描述</strong><br>此处从两个函数节点输出了其作用域的信息  </p><ul><li>这两个函数都是定义在同一级下的，所以都会输出相同的父级作用域<code>Program</code>的信息  </li><li>你会发现，代码中有非常多个<code>i</code>，有的是函数定义，有的是参数，有的是变量。仔细观察它们的不同之处<br>解释器就是通过 不同层级的作用域 与 绑定定义信息 来区分不同的名称的量的  </li></ul><h2 id="绑定-Binding"><a href="#绑定-Binding" class="headerlink" title="绑定 Binding"></a>绑定 Binding</h2><p><code>Binding</code> 对象用于存储 被绑定在作用域的量 的信息<br>你可以在 <code>@babel/traverse/lib/scope/binding.js</code> 中查看到它的定义  </p><blockquote><p>显示 Binding 的信息  </p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> parser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/parser&quot;</span>);<br><span class="hljs-keyword">const</span> traverse = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/traverse&quot;</span>).default;<br><br><span class="hljs-keyword">const</span> jscode = <span class="hljs-string">`</span><br><span class="hljs-string">function a()&#123;</span><br><span class="hljs-string">    var a = 1;</span><br><span class="hljs-string">    a = a + 1;</span><br><span class="hljs-string">    return a;</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">function b()&#123;</span><br><span class="hljs-string">    var b = 1;</span><br><span class="hljs-string">    var c = 2;</span><br><span class="hljs-string">    b = b - c;</span><br><span class="hljs-string">    return b;</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string"></span><br><span class="hljs-string">`</span>;<br><span class="hljs-keyword">let</span> ast = parser.parse(jscode);<br><span class="hljs-keyword">const</span> visitor = &#123;<br>    <span class="hljs-function"><span class="hljs-title">BlockStatement</span>(<span class="hljs-params">path</span>)</span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;\n此块节点源码：\n&quot;</span>, path.toString())<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;----------------------------------------&#x27;</span>)<br>        <span class="hljs-keyword">var</span> bindings = path.scope.bindings<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;作用域内 被绑定量 数量：&#x27;</span>, <span class="hljs-built_in">Object</span>.keys(bindings).length)<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> binding_ <span class="hljs-keyword">in</span> bindings)&#123;<br>            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;名字：&#x27;</span>, binding_)<br>            binding_ = bindings[binding_];<br>            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;类型：&#x27;</span>, binding_.kind)<br>            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;定义：&#x27;</span>, binding_.identifier)<br>            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;是否会被修改：&#x27;</span>, binding_.constant)<br>            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;被修改信息信息记录&#x27;</span>, binding_.constantViolations)<br>            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;是否会被引用：&#x27;</span>, binding_.referenced)<br>            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;被引用次数&#x27;</span>, binding_.references)<br>            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;被引用信息NodePath记录&#x27;</span>, binding_.referencePaths)<br>        &#125;<br>    &#125;<br>&#125;<br><br>traverse(ast, visitor);<br><br></code></pre></td></tr></table></figure><p>会输出一大堆信息。其对应的意义已经写在代码中，可以自行查看  </p><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>在解混淆中，作用域与绑定 主要用来处理边界的问题<br>即：某个量哪里引用了，在哪里定义  </p><blockquote><p>例：删除所有定义了, 却从未使用的变量  </p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> parser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/parser&quot;</span>);<br><span class="hljs-keyword">const</span> traverse = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/traverse&quot;</span>).default;<br><span class="hljs-keyword">const</span> generator = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/generator&quot;</span>).default;<br><br><span class="hljs-keyword">const</span> jscode = <span class="hljs-string">`</span><br><span class="hljs-string">var a = 1;</span><br><span class="hljs-string">var b = 2;</span><br><span class="hljs-string">function squire()&#123;</span><br><span class="hljs-string">  var c = 3;</span><br><span class="hljs-string">  var d = 4;</span><br><span class="hljs-string">  return a * d;</span><br><span class="hljs-string">  var e = 5;</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">var f = 6;</span><br><span class="hljs-string">`</span>;<br><span class="hljs-keyword">let</span> ast = parser.parse(jscode);<br><span class="hljs-keyword">const</span> visitor = &#123;<br>    VariableDeclarator(path)<br>    &#123;<br>        <span class="hljs-keyword">const</span> func_name = path.node.id.name;<br>        <span class="hljs-keyword">const</span> binding = path.scope.getBinding(func_name);<br>        <span class="hljs-comment">// 如果变量没有被引用过，那么删除也没关系</span><br>        <span class="hljs-comment">//   此处不能用有无修改过进行判断，因为没有被修改过并不意味着没用</span><br>        <span class="hljs-keyword">if</span>(binding &amp;&amp; !binding.referenced)&#123;<br>            path.remove();<br>        &#125;<br>    &#125;,<br>&#125;<br><br><br>traverse(ast, visitor);<br><span class="hljs-built_in">console</span>.log(generator(ast)[<span class="hljs-string">&#x27;code&#x27;</span>]);<br><br></code></pre></td></tr></table></figure><p>得到输出  </p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">squire</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">var</span> d = <span class="hljs-number">4</span>;<br>  <span class="hljs-keyword">return</span> a * d;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里使用了<a href="#Scope_getBinding"><code>Scope.getBinding()</code></a>方法来获取<code>Binding</code>对象, 判断其引用情况来对语法树进行修改  </p><hr><p><strong>相关链接</strong></p><ul><li>蔡老板的教程：<a href="https://wx.zsxq.com/dweb2/index/group/48415254524248">https://wx.zsxq.com/dweb2/index/group/48415254524248</a>  </li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Javascript</tag>
      
      <tag>Babel</tag>
      
      <tag>AST</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Https</title>
    <link href="/post/ff374aa2/"/>
    <url>/post/ff374aa2/</url>
    
    <content type="html"><![CDATA[<h1 id="Https"><a href="#Https" class="headerlink" title="Https"></a>Https</h1><p><code>Http</code>是明文传输的，在传输路径中的任何一个节点都能通过抓包能直接得到信息，毫无安全性  </p><p>人们想到了用加密算法对信息进行加密，使得抓包的人只能看到密文，无法看到明文<br>但这依然有问题，双方 使用固定的加密算法 或 临时约定加密算法，都会使得坏人知道加密方式，从而解码得到明文  </p><p><code>HTTPS</code> 并非是应用层的一种新协议。 只是 <code>HTTP</code> 通信接口部分用<code>SSL</code>（Secure Socket Layer） 和 <code>TLS</code>（Transport Layer Security） 协议代替而已  </p><h1 id="Https通信"><a href="#Https通信" class="headerlink" title="Https通信"></a>Https通信</h1><p><code>Https</code>通信最重要的地方在于 服务器与客户端如何 <strong>安全的</strong> 约定加密算法  </p><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><ul><li>非对称加密  <a href="/post/3b5ddb7/" title="加密算法类别">加密算法类别</a></li></ul><h2 id="SSL流程-四次握手"><a href="#SSL流程-四次握手" class="headerlink" title="SSL流程-四次握手"></a>SSL流程-四次握手</h2><h3 id="一次握手"><a href="#一次握手" class="headerlink" title="一次握手"></a>一次握手</h3><h4 id="1-客户端通过发送-Client-Hello-报文-开始-SSL通信"><a href="#1-客户端通过发送-Client-Hello-报文-开始-SSL通信" class="headerlink" title="1. 客户端通过发送 Client Hello 报文 开始 SSL通信"></a>1. 客户端通过发送 <code>Client Hello 报文</code> 开始 SSL通信</h4><p>报文中包含客户端支持的 <code>SSL版本</code>、 加密组件（CipherSuite） 列表（客户端支持的加密算法 及 密钥长度等）  </p><blockquote><p>维基百科-加密组件-CipherSuite：<a href="https://zh.wikipedia.org/wiki/%E5%AF%86%E7%A0%81%E5%A5%97%E4%BB%B6">链接</a>  </p></blockquote><h3 id="二次握手"><a href="#二次握手" class="headerlink" title="二次握手"></a>二次握手</h3><h4 id="2-服务器可进行-SSL通信-时，会以-Server-Hello-报文-作为应答"><a href="#2-服务器可进行-SSL通信-时，会以-Server-Hello-报文-作为应答" class="headerlink" title="2. 服务器可进行 SSL通信 时，会以 Server Hello 报文 作为应答"></a>2. 服务器可进行 SSL通信 时，会以 <code>Server Hello 报文</code> 作为应答</h4><p>和客户端一样, 在报文中包含 <code>SSL版本</code> 以及 <code>加密组件</code><br>服务器的加密组件内容 是 从接收到的客户端加密组件内 筛选出来的  </p><ul><li>因为是要进行通信的，所以加密组件必须是双方都有的  </li><li>服务器也可以根据客户端的加密组件拒绝相应  </li></ul><h4 id="3-之后服务器发送-Certificate-报文"><a href="#3-之后服务器发送-Certificate-报文" class="headerlink" title="3. 之后服务器发送 Certificate 报文"></a>3. 之后服务器发送 <code>Certificate 报文</code></h4><p>报文中包含公开密钥证书  </p><h4 id="4-最后服务器发送-Server-Hello-Done-报文-通知客户端"><a href="#4-最后服务器发送-Server-Hello-Done-报文-通知客户端" class="headerlink" title="4. 最后服务器发送 Server Hello Done 报文 通知客户端"></a>4. 最后服务器发送 <code>Server Hello Done 报文</code> 通知客户端</h4><p>至此，最初阶段的 SSL握手协商部分结束  </p><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><h4 id="5-客户端以-Client-Key-Exchange-报文作为回应"><a href="#5-客户端以-Client-Key-Exchange-报文作为回应" class="headerlink" title="5. 客户端以 Client Key Exchange 报文作为回应"></a>5. 客户端以 <code>Client Key Exchange 报文</code>作为回应</h4><p>报文中包含通信加密中使用的一种被称为 <code>Pre-mastersecret</code> 的随机密码串<br>该报文已用步骤 3 中的公开密钥进行加密  </p><h4 id="6-接着客户端继续发送-Change-Cipher-Spec-报文"><a href="#6-接着客户端继续发送-Change-Cipher-Spec-报文" class="headerlink" title="6. 接着客户端继续发送 Change Cipher Spec 报文"></a>6. 接着客户端继续发送 <code>Change Cipher Spec 报文</code></h4><p>该报文会提示服务器，在此报文之后的通信会采用<code>Pre-master secret</code> 密钥加密  </p><h4 id="7-客户端发送-Finished-报文"><a href="#7-客户端发送-Finished-报文" class="headerlink" title="7. 客户端发送 Finished 报文"></a>7. 客户端发送 <code>Finished 报文</code></h4><p>该报文包含连接至今全部报文的整体校验值<br>这次握手协商是否能够成功， 要以服务器是否能够正确解密该报文作为判定标准  </p><h3 id="四次握手"><a href="#四次握手" class="headerlink" title="四次握手"></a>四次握手</h3><h4 id="8-服务器同样发送-Change-Cipher-Spec-报文"><a href="#8-服务器同样发送-Change-Cipher-Spec-报文" class="headerlink" title="8. 服务器同样发送 Change Cipher Spec 报文"></a>8. 服务器同样发送 <code>Change Cipher Spec 报文</code></h4><h4 id="9-服务器同样发送-Finished-报文"><a href="#9-服务器同样发送-Finished-报文" class="headerlink" title="9. 服务器同样发送 Finished 报文"></a>9. 服务器同样发送 <code>Finished 报文</code></h4><p>总的来说，SSL会话的建立完成了以下几个工作：</p><p>交换协议版本号，选择一个通信双方都支持的加密方式；对两端实现身份验证；密钥交换。</p><h1 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h1><h2 id="可否修改443端口"><a href="#可否修改443端口" class="headerlink" title="可否修改443端口"></a>可否修改443端口</h2><p><code>Https</code>传输数据，需要服务器开启两个端口<code>80</code>与<code>443</code><br>其中，<code>443</code>端口仅用来建立连接，并不传输真正的数据 </p><p><code>443</code>端口是约定的<code>Https</code>端口，被写入到了浏览器中<br>浏览器在域名中识别到<code>https</code>，就默认请求<code>443</code>  </p><blockquote><p>端口号在服务端是能改的，但浏览器不能改   </p></blockquote><p>如果你修改了<code>https</code>端口，又没有特别指定访问端口。那么用户会无法用浏览器访问（浏览器访问<code>443</code>发现无响应）  </p>]]></content>
    
    
    
    <tags>
      
      <tag>Https</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>部署高匿代理-Squid</title>
    <link href="/post/b9157208/"/>
    <url>/post/b9157208/</url>
    
    <content type="html"><![CDATA[<h1 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h1><p>用<code>Squid</code>来部署一个高匿代理服务到服务器  </p><h1 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h1><h2 id="安装-Squid-与-Httpd"><a href="#安装-Squid-与-Httpd" class="headerlink" title="安装 Squid 与 Httpd"></a>安装 Squid 与 Httpd</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum install -y openssl squid<br>yum install httpd<br></code></pre></td></tr></table></figure><p><code>Squid</code>自然是服务器主体<br><code>Httpd</code>是用于生成密码文件的  </p><blockquote><p>网上为什么那么多的免费代理，有一部分原因就是因为服务器转发没有设置密码，被黑客扫端口扫出来直接用了  </p></blockquote><h2 id="创建密码文件"><a href="#创建密码文件" class="headerlink" title="创建密码文件"></a>创建密码文件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">htpasswd -c /etc/squid/passwd EvilRecluse<br></code></pre></td></tr></table></figure><blockquote><p>命令说明：  </p></blockquote><ul><li>htpasswd<br><code>htpasswd</code> 用来创建和更新用于基本认证的用户认证密码文件  </li><li>-c<br>创建参数。创建密码文件，如果文件存在，那么内容被清空重写</li><li>/etc/squid/passwd<br>密码文件路径，此处生成文件在<code>squid</code>目录下<code>passwd</code>文件中  </li><li>EvilRecluse<br>用户名，随便填，但要记住  </li></ul><blockquote><p><a href="#%E9%99%84%E5%BD%95">附录：关于htpasswd命令</a></p></blockquote><p>命令输入后会让你输入密码，输入完密码文件就生成了<br>此处生成的密码文件会被用于代理访问，以防端口被扫后就随便访问  </p><h2 id="配置-Squid"><a href="#配置-Squid" class="headerlink" title="配置 Squid"></a>配置 Squid</h2><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs vim"># localnet 网络ip配置<br>acl localnet src <span class="hljs-number">0.0</span>.<span class="hljs-number">0.0</span>/<span class="hljs-number">0</span>    # <span class="hljs-keyword">all</span> network<br>acl localnet src <span class="hljs-number">10.0</span>.<span class="hljs-number">0.0</span>/<span class="hljs-number">8</span>    # RFC1918 possible internal network<br>acl localnet src <span class="hljs-number">172.16</span>.<span class="hljs-number">0.0</span>/<span class="hljs-number">12</span>    # RFC1918 possible internal network<br>acl localnet src <span class="hljs-number">192.168</span>.<span class="hljs-number">0.0</span>/<span class="hljs-number">16</span>    # RFC1918 possible internal network<br>acl localnet src fc00::/<span class="hljs-number">7</span>       # RFC <span class="hljs-number">4193</span> local private network <span class="hljs-built_in">range</span><br>acl localnet src fe80::/<span class="hljs-number">10</span>      # RFC <span class="hljs-number">4291</span> link-local (directly plugged) machines<br><br># SSL_ports SSL端口配置<br>acl SSL_ports port <span class="hljs-number">443</span><br><br># Safe_ports 端口配置<br>acl Safe_ports port <span class="hljs-number">80</span>        # http<br>acl Safe_ports port <span class="hljs-number">21</span>        # ftp<br>acl Safe_ports port <span class="hljs-number">443</span>        # https<br>acl Safe_ports port <span class="hljs-number">70</span>        # gopher<br>acl Safe_ports port <span class="hljs-number">210</span>        # wais<br>acl Safe_ports port <span class="hljs-number">1025</span>-<span class="hljs-number">65535</span>    # unregistered ports<br>acl Safe_ports port <span class="hljs-number">280</span>        # http-mgmt<br>acl Safe_ports port <span class="hljs-number">488</span>        # gss-http<br>acl Safe_ports port <span class="hljs-number">591</span>        # filemaker<br>acl Safe_ports port <span class="hljs-number">777</span>        # multiling http<br><br># CONNECT 连接方法<br>acl CONNECT method CONNECT<br><br># 拒绝所有 非Safe_ports 端口的访问<br>http_access deny !Safe_ports<br># 拒绝所有 非SSL_ports 的连接方法<br>http_access deny CONNECT !SSL_ports<br># 允许<br>http_access allow localhost manager<br>http_access deny manager<br><br># http访问端口为 <span class="hljs-number">65000</span> 注意！！！<br># 以后要用代理就靠这个端口了<br>http_port <span class="hljs-number">65000</span><br><br># squid启动目录<br>coredump_dir /var/spool/squid<br><br># 缓存新旧刷新相关配置<br>refresh_pattern ^ftp:        <span class="hljs-number">1440</span>    <span class="hljs-number">20</span>%    <span class="hljs-number">10080</span><br>refresh_pattern ^gopher:    <span class="hljs-number">1440</span>    <span class="hljs-number">0</span>%    <span class="hljs-number">1440</span><br>refresh_pattern -i (/cgi-bin/|\?) <span class="hljs-number">0</span>    <span class="hljs-number">0</span>%    <span class="hljs-number">0</span><br>refresh_pattern .        <span class="hljs-number">0</span>    <span class="hljs-number">20</span>%    <span class="hljs-number">4320</span><br><br># via 用于检测转发循环，设置禁止则可以避免循环<br>via off<br><br># 转发头部标识删除<br>forwarded_for <span class="hljs-keyword">delete</span><br>forwarded_for off<br><br># 包含特定头部的请求禁止访问<br>request_header_access From deny <span class="hljs-keyword">all</span><br>request_header_access Server deny <span class="hljs-keyword">all</span><br>request_header_access WWW-Authenticate deny <span class="hljs-keyword">all</span><br>request_header_access Link deny <span class="hljs-keyword">all</span><br>request_header_access Cache-Control deny <span class="hljs-keyword">all</span><br>request_header_access Proxy-Connection deny <span class="hljs-keyword">all</span><br>request_header_access <span class="hljs-keyword">X</span>-Cache deny <span class="hljs-keyword">all</span><br>request_header_access <span class="hljs-keyword">X</span>-Cache-Lookup deny <span class="hljs-keyword">all</span><br>request_header_access Via deny <span class="hljs-keyword">all</span><br>request_header_access <span class="hljs-keyword">X</span>-Forwarded-For deny <span class="hljs-keyword">all</span><br>request_header_access Pragma deny <span class="hljs-keyword">all</span><br>request_header_access Keep-Alive deny <span class="hljs-keyword">all</span><br><br># 关闭squid的缓存功能<br>acl NCACHE method GET<br>no_cache deny NCACHE<br><br># 用户认证<br>auth_param basic program /usr/lib64/squid/basic_ncsa_auth /etc/squid/passwd<br>acl EvilRecluse proxy_auth REQUIRED<br>http_access allow EvilRecluse<br></code></pre></td></tr></table></figure><h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><p><a id="附录"></a></p><ul><li><a href="https://www.cnblogs.com/wj78080458/p/10847976.html">htpasswd命令详细</a>  </li><li><a href="https://blog.csdn.net/wangpengqi/article/details/9224841">关于Squild via</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>服务器</tag>
      
      <tag>Squid</tag>
      
      <tag>代理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>特殊想法-奇思妙想</title>
    <link href="/post/undefined/"/>
    <url>/post/undefined/</url>
    
    <content type="html"><![CDATA[<ul><li><p>浏览器xpath插件不支持基于指定节点 </p></li><li><p>Babel抽象语法树函数内无法分辨 外部参数 是可变量还是不可变量  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">z</span>(<span class="hljs-params">x</span>)</span>&#123;x=x+<span class="hljs-number">1</span>&#125;<br>z(a);<br><span class="hljs-built_in">console</span>.log(a);<br><span class="hljs-comment">// -------------------------------------</span><br><span class="hljs-keyword">var</span> a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">z</span>(<span class="hljs-params">x</span>)</span>&#123;x.push(<span class="hljs-number">4</span>)&#125;<br>z(a);<br><span class="hljs-built_in">console</span>.log(a);<br></code></pre></td></tr></table></figure><p>你无法判断可以不可删除z函数，因为它的计算可能会影响a</p></li><li><p>Babel, 在调用<code>path.evaluate</code> 方法时，它只处理了<code>string&quot;.length</code>这种方式的表达式，而 <code>&quot;string&quot;[&quot;length&quot;]</code>并未直接处理</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>奇思妙想</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MessagePack</title>
    <link href="/post/d52eeddc/"/>
    <url>/post/d52eeddc/</url>
    
    <content type="html"><![CDATA[<h1 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h1><p><code>MessagePack</code>是一种有效的二进制序列化格式<br>相比与于JSON，它处理起来更快，生成的文件也更小<br>小整数被编码为一个字节，典型的短字符串除字符串本身外仅需要一个额外的字节<br><img src="/MessagePack/20201130085302466.png">  </p><p>但是这东西的问题其实也很多  </p><ul><li>兼容性问题。不同语言的客户端的不同版本经常发生兼容性  </li><li>对于二进制安全需求，json有base64方案。事实上，浏览器就对base64友好  </li><li>对于rpc序列化需求，高性能有protobuf，后面有json，并没有很大的优势  </li></ul><p>官网：<a href="https://msgpack.org/">https://msgpack.org/</a>  </p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pip install msgpack<br></code></pre></td></tr></table></figure><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="pack-amp-unpack-打包与解包"><a href="#pack-amp-unpack-打包与解包" class="headerlink" title="pack &amp; unpack 打包与解包"></a>pack &amp; unpack 打包与解包</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> msgpack<br><span class="hljs-comment"># 打包函数packb，类似于json.dumps</span><br>msgpack.packb([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], use_bin_type=<span class="hljs-literal">True</span>)<br><span class="hljs-comment"># 此处得到结果：&#x27;\x93\x01\x02\x03&#x27;</span><br><br><span class="hljs-comment"># 解包函数unpackb，类似于json.loads</span><br>msgpack.unpackb(_, raw=<span class="hljs-literal">False</span>)<br><span class="hljs-comment"># 此处得到结果：[1, 2, 3]</span><br></code></pre></td></tr></table></figure><p>此处的解包函数得到的结果是一个<code>List</code>，如果希望得到的是<code>tunple</code>可以添加参数  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">msgpack.unpackb(<span class="hljs-string">b&#x27;\x93\x01\x02\x03&#x27;</span>, use_list=<span class="hljs-literal">False</span>, raw=<span class="hljs-literal">False</span>)<br>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><h2 id="Streaming-unpacking-流解包"><a href="#Streaming-unpacking-流解包" class="headerlink" title="Streaming unpacking  流解包"></a>Streaming unpacking  流解包</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> msgpack<br><span class="hljs-keyword">from</span> io <span class="hljs-keyword">import</span> BytesIO<br><br><span class="hljs-comment"># 向流中写入一些内容以用作试验</span><br>buf = BytesIO()<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">100</span>):<br>    buf.write(msgpack.packb(i, use_bin_type=<span class="hljs-literal">True</span>))<br><br>buf.seek(<span class="hljs-number">0</span>)<br><br>unpacker = msgpack.Unpacker(buf, raw=<span class="hljs-literal">False</span>)<br><span class="hljs-keyword">for</span> unpacked <span class="hljs-keyword">in</span> unpacker:<br>    print(unpacked)<br></code></pre></td></tr></table></figure><p>解包函数可以从流（或从通过其feed方法提供的字节）中解出多个对象  </p><h2 id="自定义类型"><a href="#自定义类型" class="headerlink" title="自定义类型"></a>自定义类型</h2><p>使用<code>ext</code>能够扩充打包/解包的类型  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> msgpack<br><span class="hljs-keyword">import</span> array<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">default</span>(<span class="hljs-params">obj</span>):</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(obj, array.array) <span class="hljs-keyword">and</span> obj.typecode == <span class="hljs-string">&#x27;d&#x27;</span>:<br>        <span class="hljs-keyword">return</span> msgpack.ExtType(<span class="hljs-number">42</span>, obj.tostring())<br>    <span class="hljs-keyword">raise</span> TypeError(<span class="hljs-string">&quot;Unknown type: %r&quot;</span> % (obj,))<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">ext_hook</span>(<span class="hljs-params">code, data</span>):</span><br>    <span class="hljs-keyword">if</span> code == <span class="hljs-number">42</span>:<br>        a = array.array(<span class="hljs-string">&#x27;d&#x27;</span>)<br>        a.fromstring(data)<br>        <span class="hljs-keyword">return</span> a<br>    <span class="hljs-keyword">return</span> ExtType(code, data)<br><br>data = array.array(<span class="hljs-string">&#x27;d&#x27;</span>, [<span class="hljs-number">1.2</span>, <span class="hljs-number">3.4</span>])<br>packed = msgpack.packb(data, default=default, use_bin_type=<span class="hljs-literal">True</span>)<br>unpacked = msgpack.unpackb(packed, ext_hook=ext_hook, raw=<span class="hljs-literal">False</span>)<br>print(data == unpacked)<br><span class="hljs-comment"># True</span><br></code></pre></td></tr></table></figure><h2 id="解包控制"><a href="#解包控制" class="headerlink" title="解包控制"></a>解包控制</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> io <span class="hljs-keyword">import</span> BytesIO<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">distribute</span>(<span class="hljs-params">unpacker, get_worker</span>):</span><br>    nelems = unpacker.read_map_header()<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(nelems):<br>        <span class="hljs-comment"># Select a worker for the given key</span><br>        key = unpacker.unpack()<br>        worker = get_worker(key)<br><br>        <span class="hljs-comment"># Send the value as a packed message to worker</span><br>        bytestream = BytesIO()<br>        unpacker.skip(bytestream.write)<br>        worker.send(bytestream.getvalue())<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>MessagePack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python-UUID</title>
    <link href="/post/7db30d0/"/>
    <url>/post/7db30d0/</url>
    
    <content type="html"><![CDATA[<h1 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h1><p>UUID（Universally Unique Identifier）是通用唯一识别码，在许多领域用作标识<br>常用的数据库也可以用它来作为主键，原理上它是可以对任何东西进行唯一的编码  </p><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>如果你想要的只是一个唯一的ID，你应该用 <code>uuid1()</code>或<code>uuid4()</code>，但是要注意，<code>uuid1()</code>可能会危害隐私.  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> uuid<br> <br><span class="hljs-built_in">print</span> uuid.uuid1()<br><span class="hljs-comment"># bf1dfacf-67d8-11e8-9a23-408d5c985711</span><br><span class="hljs-built_in">print</span> uuid.uuid3(uuid.NAMESPACE_DNS, <span class="hljs-string">&#x27;yuanlin&#x27;</span>)<br><span class="hljs-comment"># ddb366f5-d4bc-3a20-ac68-e13c0560058f</span><br><span class="hljs-built_in">print</span> uuid.uuid4()<br><span class="hljs-comment"># 144d622b-e83a-40ea-8ca1-66af8a86261c</span><br><span class="hljs-built_in">print</span> uuid.uuid5(uuid.NAMESPACE_DNS, <span class="hljs-string">&#x27;yuanlin&#x27;</span>)<br><span class="hljs-comment"># 4a47c18d-037a-5df6-9e12-20b643c334d3</span><br></code></pre></td></tr></table></figure><table><thead><tr><th>函数</th><th>生成方法</th><th>信息</th></tr></thead><tbody><tr><td>uuid1()</td><td>根据当前的时间戳和MAC地址生成</td><td>最后的12个字符408d5c985711对应的就是MAC地址。暴露MAC地址，可能造成安全隐患</td></tr><tr><td>uuid3()</td><td>根据指定的 <code>namespace</code> 和 具体的字符串 通过MD5生成</td><td><code>namespace</code>内唯一</td></tr><tr><td>uuid4()</td><td>基于随机数</td><td>存在相同的可能性</td></tr><tr><td>uuid5()</td><td>根据指定的 <code>namespace</code> 和 具体的字符串 通过SHA1生成</td><td><code>namespace</code>内唯一</td></tr></tbody></table>]]></content>
    
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>uuid</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis-Redlock-锁-Redis分布式锁</title>
    <link href="/post/d84e1cb8/"/>
    <url>/post/d84e1cb8/</url>
    
    <content type="html"><![CDATA[<h1 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h1><p>官方算法文章：<a href="https://redis.io/topics/distlock">https://redis.io/topics/distlock</a><br>redlock-py pypi: <a href="https://pypi.org/project/redlock-py/">https://pypi.org/project/redlock-py/</a><br>redlock-py github: <a href="https://github.com/SPSCommerce/redlock-py">https://github.com/SPSCommerce/redlock-py</a>  </p><h1 id="安全和可靠性保证"><a href="#安全和可靠性保证" class="headerlink" title="安全和可靠性保证"></a>安全和可靠性保证</h1><p>实现高效分布式锁的基础  </p><ul><li>一致性<br>互斥。不管任何时候，只有一个客户端能持有同一个锁  </li><li>分区可容忍性<br>不会死锁，最终一定会得到锁，就算一个持有锁的客户端宕掉或者发生网络分区  </li><li>可用性<br>只要大多数<code>Redis</code>节点正常工作，客户端应该都能获取和释放锁  </li></ul><h1 id="锁的基础"><a href="#锁的基础" class="headerlink" title="锁的基础"></a>锁的基础</h1><p><code>Redis</code>中本身包含一些命令可以用来实现锁的功能，比如<code>SETNX</code><br>思路:<br>如果 <code>key</code> 不存在，将 <code>key</code> 设置为 <code>value</code><br>如果 <code>key</code> 已存在，则 <code>SETNX</code> 不做任何动作  </p><ol><li>客户端A请求服务器设置key的值，如果设置成功就表示加锁成功  </li><li>客户端B也去请求服务器设置key的值，如果返回失败，那么就代表加锁失败  </li><li>客户端A执行代码完成，删除锁  </li><li>客户端B在等待一段时间后在去请求设置key的值，设置成功  </li><li>客户端B执行代码完成，删除锁  </li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-variable">$redis</span>-&gt;setNX(<span class="hljs-variable">$key</span>, <span class="hljs-variable">$value</span>);<br><span class="hljs-variable">$redis</span>-&gt;expire(<span class="hljs-variable">$key</span>, <span class="hljs-variable">$ttl</span>);<br></code></pre></td></tr></table></figure><blockquote><h3 id="过期时间"><a href="#过期时间" class="headerlink" title="过期时间"></a>过期时间</h3><p>如果请求执行因为某些原因意外退出了，导致创建了锁但是没有删除锁，那么这个锁将一直存在，以至于以后缓存再也得不到更新。<br>为 <code>key</code> 设置过期时间能够确保锁最终能够得到释放    </p></blockquote><blockquote><h3 id="请求与等待-的循环"><a href="#请求与等待-的循环" class="headerlink" title="请求与等待 的循环"></a>请求与等待 的循环</h3><p>程序不能因为发现资源被锁上了就直接停止<br>过于频繁的请求会让服务器压力变大<br>等待的时间应该为一个合理的随机数，因为如果多个客户端同时重试，那么可能会导致谁都无法拿到锁的情况出现  </p></blockquote><p>但是用来设置过期时间的 <code>Expire</code>命令 并不是原子性操作了, 所以需要设置<code>事务</code>来确保原子性  </p><ol><li>客户端A请求服务器设置key的值，如果设置成功就表示加锁成功</li><li>客户端B也去请求服务器设置key的值，如果返回失败，那么就代表加锁失败</li><li>客户端A执行代码完成，删除锁</li><li>客户端B在等待一段时间后在去请求设置key的值，设置成功</li><li>客户端B执行代码完成，删除锁</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-variable">$redis</span>-&gt;<span class="hljs-built_in">set</span>(<span class="hljs-variable">$key</span>, <span class="hljs-variable">$value</span>, array(<span class="hljs-string">&#x27;nx&#x27;</span>, <span class="hljs-string">&#x27;ex&#x27;</span> =&gt; <span class="hljs-variable">$ttl</span>));  //ex表示秒<br></code></pre></td></tr></table></figure><h2 id="关于键的值"><a href="#关于键的值" class="headerlink" title="关于键的值"></a>关于键的值</h2><p>值会被填入一个随机数，且必须在所有获取锁请求的客户端里保持唯一<br>键值是用来保证能安全地释放锁的，删除前需要做对比。单纯的用<code>DEL</code>指令有可能造成一个客户端删除了其他客户端的锁  </p><blockquote><p>例: 为什么要设置一个特殊的值  </p><ol><li>A客户端拿到了锁，被某个操作阻塞了很长时间，过了超时时间后自动释放了这个锁  </li><li>B客户端来了，申请，拿到了这个锁  </li><li>A客户端操作结束，尝试删除这个其实已经被其他客户端拿到的锁  <blockquote><p>如果此时没有设置随机数作校对，那么会删掉B的锁  </p></blockquote></li></ol></blockquote><h1 id="Redlock算法"><a href="#Redlock算法" class="headerlink" title="Redlock算法"></a>Redlock算法</h1><p>假设有<code>N</code>个<code>Redis master</code>节点  </p><blockquote><p><strong><code>N</code>是个奇数</strong><br>因为流程中有 <strong>过半数</strong> 这种判断，如果是偶数，那么将无法完成判断<br>节点越多，越能避免部分节点宕机造成的影响，但也越浪费资源    </p></blockquote><ol><li><p>获取当前时间（单位是毫秒）  </p></li><li><p>用 相同的<code>key</code>和随机值 在<code>N</code>个节点上逐一请求锁<br>客户端在每个<code>master</code>上请求锁时，会有一个比总的 <code>锁释放时间</code> 小很多的 <code>连接超时时间</code>  </p><blockquote><p>比如:如果锁自动释放时间是10秒钟，那每个节点锁请求的超时时间可能是5-50毫秒的范围  </p></blockquote><p>设置<strong>连接超时时间</strong> 可以防止一个客户端在某个宕掉的<code>master</code>节点上阻塞过长时间（避免<strong>总连接时间</strong>接近/超过<strong>锁释放时间</strong>）  </p></li><li><p>客户端计算第二步中获取锁所花的总时间  </p></li><li><p>进行判断<br>只有当客户端在过半数<code>master</code>节点上成功获取了锁，而且 <code>总共消耗的时间</code> 不超过 <code>锁释放时间</code>，这个锁才会被认为是获取成功  </p></li></ol><ul><li>如果锁获取成功了<br>那现在锁自动释放时间就是最初的锁释放时间减去之前获取锁所消耗的时间  </li><li>如果锁获取失败了<br>客户端会到每个<code>master</code>节点上释放锁，即便是那些他认为没有获取成功的锁  </li></ul><p>客户端如果没有在多数节点获取到锁，一定要尽快在获取锁成功的节点上释放锁，这样就没必要等到<code>key</code>超时后才能重新获取这个锁（但是如果网络分区的情况发生而且客户端无法连接到<code>Redis</code>节点时，会损失等待key超时这段时间的系统可用性）  </p><h1 id="扩展锁"><a href="#扩展锁" class="headerlink" title="扩展锁"></a>扩展锁</h1><p>如果客户端做的工作都是由一些小的步骤组成，那么就有可能使用更小的默认锁有效时间，而且扩展这个算法来实现一个锁扩展机制<br>客户端如果在执行计算期间发现锁快要超时了，客户端可以给所有服务实例发送一个命令，让<code>master</code>端延长锁的时间<br>只要这个锁的 <code>key</code> 还存在而且值还等于客户端获取时的那个值。 客户端应当只有在 失效时间内无法延长锁时 再去重新获取锁（基本上这个和获取锁的算法是差不多的）  </p><h1 id="安全性的论证"><a href="#安全性的论证" class="headerlink" title="安全性的论证"></a>安全性的论证</h1><p>可以观察不同场景下的情况来理解这个算法为什么是安全的。 </p><p>假设客户端可以在大多数节点都获取到锁，这样所有的节点都会包含一个有相同存活时间的<code>key</code>。需要注意的是，这个<code>key</code>是在不同时间点设置的，所以这些key也会在不同的时间超时  </p><p>假设最坏情况下：  </p><ul><li>第一个<code>key</code>是在<code>T1</code>时间设置的（客户端连接到第一个服务器时的时间）  </li><li>最后一个<code>key</code>是在<code>T2</code>时间设置的（客户端收到最后一个服务器返回结果的时间）  </li></ul><p>从<code>T2</code>时间开始，确认最早超时的<code>key</code>至少也会存在的时间为  </p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">MIN_VALIDITY</span> = TTL - (T<span class="hljs-number">2</span>-T<span class="hljs-number">1</span>) - CLOCK_DRIFT<br></code></pre></td></tr></table></figure><ul><li>TTL: 锁超时时间  </li><li>（T2-T1）: 最晚获取到的锁的耗时  </li><li>CLOCK_DRIFT: 是不同进程间时钟差异，这个是用来补偿前面的(T2-T1）  </li></ul><p>其他的<code>key</code>都会在这个时间点之后才会超时，所以我们可以确定这些<code>key</code>在这个时间点之前至少都是同时存在的  </p><ul><li><p>无法抢占<br>在过半数<code>master</code>节点的<code>key</code>都<code>set</code>了的时间段内，其他客户端无法抢占这个锁<br>因为在 <code>(N/2)+1</code> 个 <code>master</code> 端的 <code>key</code> 已经存在的情况下不可能再在<code>(N/2)+1</code>个<code>master</code>端上获取锁成功，所以如果一个锁获取成功了，就不可能同时重新获取这个锁成功（不然就违反了分布式锁互斥原则）</p></li><li><p>多个客户端同时尝试获取锁时不会都同时成功<br>如果一个 <strong>客户端获取过半数节点锁的耗时</strong> 接近甚至超过 <strong>锁的最大有效时间</strong>，那么系统会认为这个锁是无效的同时会释放这些节点上的锁，所以仅仅需要考虑获取 <strong>过半数节点所的耗时</strong> 小于 <strong>锁有效时间</strong> 的情况，而在这种情况下，根据我们前面的证明，在<code>MIN_VALIDITY</code>时间内，没有客户端能重新获取锁成功  </p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Redis</tag>
      
      <tag>分布式</tag>
      
      <tag>锁</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>正则表达式-断言-预查</title>
    <link href="/post/2cccdedc/"/>
    <url>/post/2cccdedc/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>文章默认以从左向右，从前到后描述方向<br>有些翻译会将 <strong>assert</strong> 翻译作预查，有些则翻译为断言  </p><blockquote><p>我更喜欢断言这种翻译，所以后文我都用这个词  </p></blockquote><h1 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h1><p>断言是正则表达式的一种用法<br>主要是在表达式的某个位置发出向某个方向的声明断言判断<br>如果不符合断言所描述的场景，那么就认为匹配失败  </p><blockquote><p>仅作理解用的举例：  </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">为什么不问问这个神奇的海螺呢？<br></code></pre></td></tr></table></figure><blockquote><blockquote><p>例1：”海螺”这个词前面是”神奇的”这个词<br>那么这个断言是符合句子中的场景的，因为“海螺”前面确实是”神奇的”这个词  </p></blockquote></blockquote><blockquote><p><span></span></p><blockquote><p>例2：”神奇的”后面是”烤肉”这个词<br>那么这个断言是不符合句子中的场景的，因为”神奇的”后面不是“烤肉”，而是“海螺”  </p></blockquote></blockquote><h2 id="断言肯否-肯定positive-否定negative"><a href="#断言肯否-肯定positive-否定negative" class="headerlink" title="断言肯否 - 肯定positive/否定negative"></a>断言肯否 - 肯定positive/否定negative</h2><blockquote><p>断言肯定与否定举例  </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">接招吧DIO！半径30米的绿宝石飞溅！！！<br></code></pre></td></tr></table></figure><blockquote><p>肯定断言：“绿宝石飞溅”前面是”半径30米”<br>否定断言：“绿宝石飞溅”前面不是”半径30米”  </p></blockquote><h2 id="断言方向-正向look-ahead-反向look-behind"><a href="#断言方向-正向look-ahead-反向look-behind" class="headerlink" title="断言方向 - 正向look ahead/反向look behind"></a>断言方向 - 正向look ahead/反向look behind</h2><p>断言只有两个场景场景，即：断言在描述场景前/后<br>这对应着正则表达式的两种类型的断言  </p><ul><li>正向断言<br>对前文的断言。断言当前文本前面(没)有什么  </li><li>反向断言<br>对后文的断言。断言当前文本后面(没)有什么  </li></ul><blockquote><p>不知为什么有些文章会将这个方向说成与肯否弄反，此处采用维基百科的说法  </p></blockquote><h2 id="非获取匹配-零宽"><a href="#非获取匹配-零宽" class="headerlink" title="非获取匹配 - 零宽"></a>非获取匹配 - 零宽</h2><p>指匹配pattern但不获取匹配的子字符串（shy groups），也就是说这是一个非获取匹配，不存储匹配的子字符串用于向后引用<br>简单来说就是，断言的内容只用作判断，最终返回的内容不会包含断言的内容  </p><h2 id="语言限制"><a href="#语言限制" class="headerlink" title="语言限制"></a>语言限制</h2><p>不同语言不同库可能对正则表达式的断言声明有着不同的限制<br>比如：</p><ul><li><code>JavaScript</code>中并不支持后行断言  </li><li><code>Python</code>中并不支持变长后行断言  </li></ul><blockquote><p>也许未来会支持也不一定，不过现在的情况是这样的  </p></blockquote><h1 id="正则表达式断言"><a href="#正则表达式断言" class="headerlink" title="正则表达式断言"></a>正则表达式断言</h1><table><thead><tr><th>表达式</th><th>方向</th><th>肯否</th><th>描述</th><th>举例</th></tr></thead><tbody><tr><td>(?=pattern)</td><td>正向</td><td>肯定</td><td>零宽度正先行断言<br>仅当子表达式 pattern 在 此位置的右侧匹配时才继续匹配。</td><td>\w+(?=\d) <br>与后跟数字的单词匹配，而不与该数字匹配。</td></tr><tr><td>(?!pattern)</td><td>正向</td><td>否定</td><td>零宽度负先行断言<br>仅当子表达式 pattern 不在 此位置的右侧匹配时才继续匹配。</td><td>/w+(?!/d) <br>与后不跟数字的单词匹配，而不与该数字匹配 。</td></tr><tr><td>(?&lt;=pattern)</td><td>反向</td><td>肯定</td><td>零宽度正后发断言<br>仅当子表达式 pattern 在 此位置的左侧匹配时才继续匹配。</td><td>(?&lt;=19)99 <br>与跟在 19 后面的 99 的实例匹配。</td></tr><tr><td>(?&lt;!pattern)</td><td>反向</td><td>否定</td><td>零宽度负后发断言<br>仅当子表达式 pattern 不在此位置的左侧匹配时才继续匹配。</td><td>(?&lt;!19)99 <br>与不跟在 19 后面的 99 的实例匹配</td></tr></tbody></table><hr><p>参考<br>维基百科-正则表达式: <a href="https://zh.wikipedia.org/wiki/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F">https://zh.wikipedia.org/wiki/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F</a>  </p>]]></content>
    
    
    
    <tags>
      
      <tag>正则</tag>
      
      <tag>断言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue-前端</title>
    <link href="/post/8c57192e/"/>
    <url>/post/8c57192e/</url>
    
    <content type="html"><![CDATA[<h1 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h1><p><code>Vue</code> (读音 <code>/vjuː/</code>) 是一套用于构建用户界面的渐进式框架<br>与其它大型框架不同的是，<code>Vue</code> 被设计为可以自底向上逐层应用<br><code>Vue</code> 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合  </p><blockquote><ul><li>渐进式<br>指你可以让已有的项目，一点一点的用来<code>Vue</code>取代实现，不用担心<code>Vue</code>框架的排它性<br>一些框架可能会强制你使用它的一些东西，使得这个框架与其它框架难以集成到一起  </li><li>组件化应用<br>组件系统是 <code>Vue</code> 的另一个重要概念，因为它是一种抽象，允许我们使用小型、独立和通常可复用的组件构建大型应用<br><img src="/Vue-%E5%89%8D%E7%AB%AF/20201118041814431.png">  </li></ul></blockquote><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><blockquote><p>Vue 不支持 IE8 及以下版本，因为 Vue 使用了 IE8 无法模拟的 ECMAScript 5 特性  </p></blockquote><h2 id="直接用-lt-script-gt-CDN引入"><a href="#直接用-lt-script-gt-CDN引入" class="headerlink" title="直接用 &lt;script&gt;CDN引入"></a>直接用 <code>&lt;script&gt;</code>CDN引入</h2><p>对于制作原型或学习，你可以这样使用最新版本</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>对于生产环境，我们推荐链接到一个明确的版本号和构建文件，以避免新版本造成的不可预期的破坏：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdn.jsdelivr.net/npm/vue@2.6.12&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="NPM"><a href="#NPM" class="headerlink" title="NPM"></a>NPM</h2><p>在用 <code>Vue</code> 构建大型应用时推荐使用 <code>NPM</code> 安装。<code>NPM</code> 能很好地和<code>webpack</code>打包器配合使用  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install vue<br></code></pre></td></tr></table></figure><h3 id="对不同构建版本的解释"><a href="#对不同构建版本的解释" class="headerlink" title="对不同构建版本的解释"></a>对不同构建版本的解释</h3><p>在 <code>NPM</code> 包的 <code>dist/</code> 目录会找到很多不同的 <code>Vue.js</code> 构建版本  </p><table><thead><tr><th></th><th>UMD</th><th>CommonJS</th><th>ES Module <br>(基于构建工具使用)</th><th>ES Module <br>(直接用于浏览器)</th></tr></thead><tbody><tr><td>完整版</td><td>vue.js</td><td>vue.common.js</td><td>vue.esm.js</td><td>vue.esm.browser.js</td></tr><tr><td>只包含运行时版</td><td>vue.runtime.js</td><td>vue.runtime.common.js</td><td>vue.runtime.esm.js</td><td></td></tr><tr><td>完整版 (生产环境)</td><td>vue.min.js</td><td></td><td></td><td>vue.esm.browser.min.js</td></tr><tr><td>只包含运行时版 (生产环境)</td><td>vue.runtime.min.js</td><td></td><td></td><td></td></tr></tbody></table><ul><li>完整版：同时包含编译器和运行时的版本。</li><li>编译器：用来将模板字符串编译成为 JavaScript 渲染函数的代码。</li><li>运行时：用来创建 Vue 实例、渲染并处理虚拟 DOM 等的代码。基本上就是除去编译器的其它一切。</li></ul><blockquote><p>版本类型说明</p><ul><li>UMD：UMD 版本可以通过 <code>&lt;script&gt;</code> 标签直接用在浏览器中  </li><li>CommonJS：CommonJS 版本用来配合老的打包工具<code>webpack 1</code>  </li><li>ES Module：为打包工具提供的 ESM  <ul><li>为诸如 <code>webpack 2</code> 提供的现代打包工具<br>ESM 格式被设计为可以被静态分析，所以打包工具可以利用这一点来进行“tree-shaking”并将用不到的代码排除出最终的包。<br>为这些打包工具提供的默认文件 (<code>pkg.module</code>) 是只有运行时的 ES Module 构建 (<code>vue.runtime.esm.js</code>)  </li><li>为浏览器提供的 ESM (2.6+)<br>用于在现代浏览器中通过 <code>&lt;script type=&quot;module&quot;&gt;</code> 直接导入  </li></ul></li></ul></blockquote><h2 id="浏览器调试插件Vue-Devtools"><a href="#浏览器调试插件Vue-Devtools" class="headerlink" title="浏览器调试插件Vue Devtools"></a>浏览器调试插件Vue Devtools</h2><p>Github: <a href="https://github.com/vuejs/vue-devtools#vue-devtools">https://github.com/vuejs/vue-devtools#vue-devtools</a><br>寻找对应自己浏览器版本的调试插件安装即可  </p><h1 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h1><p>创建一个<code>HTML</code>文件，在文件中引入<code>Vue</code>的CDN来使用<code>Vue</code>  </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 开发环境版本，包含了有帮助的命令行警告 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>HTML中设置一个标签用于显示数据</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span></span><br><span class="xml">    </span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">message</span>&#125;&#125;</span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>编写模板代码</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="javascript">    <span class="hljs-keyword">var</span> app = <span class="hljs-keyword">new</span> Vue(&#123;</span><br><span class="javascript">        el:<span class="hljs-string">&#x27;#app&#x27;</span>,</span><br>        data:&#123;<br><span class="javascript">            message:<span class="hljs-string">&quot;Hello World&quot;</span></span><br>        &#125;<br>    &#125;)<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p><code>Vue.js</code> 的核心是一个允许采用简洁的模板语法来声明式地将数据渲染进 DOM 的系统  </p></blockquote><p>这样就已经成功创建了第一个 <code>Vue</code> 应用！看起来这跟渲染一个字符串模板非常类似，但是 <code>Vue</code> 在背后做了大量工作<br>现在数据和 <code>DOM</code> 已经被建立了关联，所有东西都是响应式的。  </p><blockquote><p>要怎么确认呢？打开你的浏览器的控制台 (就在这个页面打开)，并修改 app.message 的值<br><img src="/Vue-%E5%89%8D%E7%AB%AF/1.gif"><br>你将看到上例相应地更新  </p></blockquote><p>注意我们不再和 <code>HTML</code> 直接交互了<br>一个 <code>Vue</code> 应用会将其挂载到一个 <code>DOM</code> 元素上 (对于这个例子是 <code>#app</code>) 然后对其进行完全控制。那个 <code>HTML</code> 是我们的入口，但其余都会发生在新创建的 <code>Vue</code> 实例内部  </p><h2 id="其它的绑定"><a href="#其它的绑定" class="headerlink" title="其它的绑定"></a>其它的绑定</h2><p>除了文本插值，我们还可以像这样来绑定元素 attribute  </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app-2&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">v-bind:title</span>=<span class="hljs-string">&quot;message&quot;</span>&gt;</span><br>    鼠标悬停几秒钟查看此处动态绑定的提示信息！<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="javascript">    <span class="hljs-keyword">var</span> app2 = <span class="hljs-keyword">new</span> Vue(&#123;</span><br><span class="javascript">      el: <span class="hljs-string">&#x27;#app-2&#x27;</span>,</span><br>      data: &#123;<br><span class="javascript">        message: <span class="hljs-string">&#x27;页面加载于 &#x27;</span> + <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().toLocaleString()</span><br>      &#125;<br>    &#125;)<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这里我们遇到了一点新东西。你看到的 <code>v-bind attribute</code> 被称为指令。指令带有前缀 <code>v-</code>，以表示它们是 <code>Vue</code> 提供的特殊 <code>attribute</code>。它们会在渲染的 DOM 上应用特殊的响应式行为<br>在这里，该指令的意思是：“将这个元素节点的 <code>title attribute</code> 和 <code>Vue</code> 实例的 <code>message property</code> 保持一致”  </p><blockquote><p>类似的，这个内容也是响应式的<br><img src="/Vue-%E5%89%8D%E7%AB%AF/2.gif">  </p></blockquote><h2 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h2><p>控制切换一个元素是否显示  </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app-3&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;seen&quot;</span>&gt;</span>现在你看到我了<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="javascript">    <span class="hljs-keyword">var</span> app3 = <span class="hljs-keyword">new</span> Vue(&#123;</span><br><span class="javascript">      el: <span class="hljs-string">&#x27;#app-3&#x27;</span>,</span><br>      data: &#123;<br><span class="javascript">        seen: <span class="hljs-literal">true</span></span><br>      &#125;<br>    &#125;)<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="/Vue-%E5%89%8D%E7%AB%AF/3.gif"><br>在控制台输入 <code>app3.seen = false</code>，你会发现之前显示的消息消失了。</p><p>这个例子演示了我们不仅可以把数据绑定到 <code>DOM</code> 文本或 <code>attribute</code>，还可以绑定到 <code>DOM</code> 结构  </p><h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><p><code>v-for</code> 指令可以绑定数组的数据来渲染一个项目列表  </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app-4&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">ol</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;todo in todos&quot;</span>&gt;</span><br>      &#123;&#123; todo.text &#125;&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">ol</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="javascript">    <span class="hljs-keyword">var</span> app4 = <span class="hljs-keyword">new</span> Vue(&#123;</span><br><span class="javascript">      el: <span class="hljs-string">&#x27;#app-4&#x27;</span>,</span><br>      data: &#123;<br>        todos: [<br><span class="javascript">          &#123; <span class="hljs-attr">text</span>: <span class="hljs-string">&#x27;学习 JavaScript&#x27;</span> &#125;,</span><br><span class="javascript">          &#123; <span class="hljs-attr">text</span>: <span class="hljs-string">&#x27;学习 Vue&#x27;</span> &#125;,</span><br><span class="javascript">          &#123; <span class="hljs-attr">text</span>: <span class="hljs-string">&#x27;整个牛项目&#x27;</span> &#125;</span><br>        ]<br>      &#125;<br>    &#125;)<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="/Vue-%E5%89%8D%E7%AB%AF/4.gif">  </p><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><h3 id="事件监听器"><a href="#事件监听器" class="headerlink" title="事件监听器"></a>事件监听器</h3><p>可以用 <code>v-on</code> 指令添加一个事件监听器，通过它调用在 <code>Vue</code> 实例中定义的方法</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app-5&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">v-on:click</span>=<span class="hljs-string">&quot;reverseMessage&quot;</span>&gt;</span>反转消息<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="javascript">    <span class="hljs-keyword">var</span> app5 = <span class="hljs-keyword">new</span> Vue(&#123;</span><br><span class="javascript">      el: <span class="hljs-string">&#x27;#app-5&#x27;</span>,</span><br>      data: &#123;<br><span class="javascript">        message: <span class="hljs-string">&#x27;Hello Vue.js!&#x27;</span></span><br>      &#125;,<br>      methods: &#123;<br><span class="javascript">        reverseMessage: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><br><span class="javascript">          <span class="hljs-built_in">this</span>.message = <span class="hljs-built_in">this</span>.message.split(<span class="hljs-string">&#x27;&#x27;</span>)</span><br>          <br><span class="javascript">          .reverse().join(<span class="hljs-string">&#x27;&#x27;</span>)</span><br>        &#125;<br>      &#125;<br>    &#125;)<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="/Vue-%E5%89%8D%E7%AB%AF/5.gif"><br>注意在 <code>reverseMessage</code> 方法中，我们更新了应用的状态，但没有触碰 <code>DOM</code><br>所有的 <code>DOM</code> 操作都由 <code>Vue</code> 来处理，你编写的代码只需要关注逻辑层面即可  </p><h2 id="双向绑定"><a href="#双向绑定" class="headerlink" title="双向绑定"></a>双向绑定</h2><p><code>Vue</code> 提供了 <code>v-model</code> 指令，它能轻松实现表单输入和应用状态之间的双向绑定  </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app-6&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;message&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="javascript">    <span class="hljs-keyword">var</span> app6 = <span class="hljs-keyword">new</span> Vue(&#123;</span><br><span class="javascript">      el: <span class="hljs-string">&#x27;#app-6&#x27;</span>,</span><br>      data: &#123;<br><span class="javascript">        message: <span class="hljs-string">&#x27;Hello Vue!&#x27;</span></span><br>      &#125;<br>    &#125;)<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><p>组件系统是 <code>Vue</code> 的另一个重要概念，因为它是一种抽象，允许我们使用小型、独立和通常可复用的组件构建大型应用<br><img src="/Vue-%E5%89%8D%E7%AB%AF/20201118041814431.png"><br>在 <code>Vue</code> 里，一个组件本质上是一个拥有预定义选项的一个 <code>Vue</code> 实例。在 <code>Vue</code> 中注册组件很简单：  </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app-7&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">ol</span>&gt;</span><br>      <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">        现在我们为每个 todo-item 提供 todo 对象</span><br><span class="hljs-comment">        todo 对象是变量，即其内容可以是动态的。</span><br><span class="hljs-comment">        我们也需要为每个组件提供一个“key”，稍后再作详细解释。</span><br><span class="hljs-comment">      --&gt;</span><br>      <span class="hljs-comment">&lt;!-- 使用 v-bind 指令将待办项传到循环输出的每个组件中 --&gt;</span><br>      &lt;todo-item<br>        v-for=&quot;item in groceryList&quot;<br>        v-bind:todo=&quot;item&quot;<br>        v-bind:key=&quot;item.id&quot; <br>      &gt;<span class="hljs-tag">&lt;/<span class="hljs-name">todo-item</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">ol</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="javascript">    <span class="hljs-comment">// 定义名为 todo-item 的新组件</span></span><br><span class="javascript">    Vue.component(<span class="hljs-string">&#x27;todo-item&#x27;</span>, &#123;</span><br><span class="javascript">        <span class="hljs-comment">// todo-item 组件接受一个&quot;prop&quot;，类似于一个自定义 attribute。</span></span><br><span class="javascript">        <span class="hljs-comment">// 这个 prop 名为 todo。</span></span><br><span class="javascript">        props: [<span class="hljs-string">&#x27;todo&#x27;</span>],</span><br><span class="handlebars"><span class="xml">        template: &#x27;<span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">todo.text</span> &#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>&#x27;</span></span><br>    &#125;)<br><br><span class="javascript">    <span class="hljs-keyword">var</span> app7 = <span class="hljs-keyword">new</span> Vue(&#123;</span><br><span class="javascript">        el: <span class="hljs-string">&#x27;#app-7&#x27;</span>,</span><br>        data: &#123;<br>            groceryList: [<br><span class="javascript">                &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">text</span>: <span class="hljs-string">&#x27;蔬菜&#x27;</span> &#125;,</span><br><span class="javascript">                &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">text</span>: <span class="hljs-string">&#x27;奶酪&#x27;</span> &#125;,</span><br><span class="javascript">                &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">text</span>: <span class="hljs-string">&#x27;随便其它什么人吃的东西&#x27;</span> &#125;</span><br>            ]<br>        &#125;<br>    &#125;)<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>附带的观察整个流程（并非是运行流程），便于理解  </p><ol><li><code>&lt;script&gt;</code>初始化  <ol><li>声明自定义的组件<code>&lt;todo-item&gt;</code>  </li><li>初始化数据 <code>groceryList</code>  </li></ol></li><li><code>HTML</code>里的<code>&lt;todo-item&gt;</code>  <ol><li><code>v-for</code>遍历<code>groceryList</code>中拿到数据,命名为<code>item</code>  </li><li>``v-bind:todo=”item”相当于 <code>组件.todo = item</code>  </li><li><code>todo-item</code>根据定义的<code>template</code>计算出内容回填  </li></ol></li></ol></blockquote><p>尽管这只是一个刻意设计的例子，但是我们已经设法将应用分割成了两个更小的单元。<br>子单元通过<code>prop</code>接口与父单元进行了良好的解耦<br>现在可以进一步改进 <code>&lt;todo-item&gt;</code> 组件，提供更为复杂的模板和逻辑，而不会影响到父单元  </p><h1 id="Vue实例"><a href="#Vue实例" class="headerlink" title="Vue实例"></a>Vue实例</h1><p>每个 <code>Vue</code> 应用都是通过用 <code>Vue</code> 函数创建一个新的 <code>Vue</code> 实例开始的  </p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> <span class="hljs-type">Vue</span>(&#123;<br>  <span class="hljs-comment">// 选项</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>虽然没有完全遵循 <a href="https://zh.wikipedia.org/wiki/MVVM">MVVM</a> 模型，但是 <code>Vue</code> 的设计也受到了它的启发。因此在文档中经常会使用 <code>vm</code> (<code>ViewModel</code> 的缩写) 这个变量名表示 <code>Vue</code> 实例<br>当创建一个 <code>Vue</code> 实例时，你可以传入一个选项对象。这个篇章主要描述的就是如何使用这些选项来创建你想要的行为。作为参考，你也可以在 <a href="https://cn.vuejs.org/v2/api/#%E9%80%89%E9%A1%B9-%E6%95%B0%E6%8D%AE">API 文档</a> 中浏览完整的选项列表  </p><p>一个 <code>Vue</code> 应用由一个通过 <code>new Vue</code> 创建的根 <code>Vue</code> 实例，以及可选的嵌套的、可复用的组件树组成  </p><blockquote><p>举个例子，一个 todo 应用的组件树可以是这样的：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plain">根实例<br>└─ TodoList<br>   ├─ TodoItem<br>   │  ├─ TodoButtonDelete<br>   │  └─ TodoButtonEdit<br>   └─ TodoListFooter<br>      ├─ TodosButtonClear<br>      └─ TodoListStatistics<br></code></pre></td></tr></table></figure><p>所有的 Vue 组件都是 Vue 实例，并且接受相同的选项对象 (一些根实例特有的选项除外)  </p><h2 id="数据与方法"><a href="#数据与方法" class="headerlink" title="数据与方法"></a>数据与方法</h2><p>当一个 <code>Vue</code> 实例被创建时，它将 <code>data</code> 对象中的所有的 <code>property</code> 加入到 <code>Vue</code> 的响应式系统中<br>当这些 <code>property</code> 的值发生改变时，视图将会产生“响应”，即匹配更新为新的值  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 我们的数据对象</span><br><span class="hljs-keyword">var</span> data = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">1</span> &#125;<br><br><span class="hljs-comment">// 该对象被加入到一个 Vue 实例中</span><br><span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> Vue(&#123;<br>  data: data<br>&#125;)<br><br><span class="hljs-comment">// 获得这个实例上的 property</span><br><span class="hljs-comment">// 返回源数据中对应的字段</span><br>vm.a == data.a <span class="hljs-comment">// =&gt; true</span><br><br><span class="hljs-comment">// 设置 property 也会影响到原始数据</span><br>vm.a = <span class="hljs-number">2</span><br>data.a <span class="hljs-comment">// =&gt; 2</span><br><br><span class="hljs-comment">// ……反之亦然</span><br>data.a = <span class="hljs-number">3</span><br>vm.a <span class="hljs-comment">// =&gt; 3</span><br></code></pre></td></tr></table></figure><p>当这些数据改变时，视图会进行重渲染。值得注意的是只有当实例被创建时就已经存在于 <code>data</code> 中的 <code>property</code> 才是响应式的  </p><blockquote><p>也就是说如果你在创建以后再去添加一个新的 <code>property</code>，比如：  </p></blockquote><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">vm.b</span> = <span class="hljs-string">&#x27;hi&#x27;</span><br></code></pre></td></tr></table></figure><blockquote><p>那么对 <code>b</code> 的改动将不会触发任何视图的更新  </p></blockquote><p>如果你知道你会在晚些时候需要一个 <code>property</code>，但是一开始它为空或不存在，那么你需要设置一些初始值，以确保它是响应式的  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript">data: &#123;<br>  newTodoText: <span class="hljs-string">&#x27;&#x27;</span>,<br>  visitCount: <span class="hljs-number">0</span>,<br>  hideCompletedTodos: <span class="hljs-literal">false</span>,<br>  todos: [],<br>  error: <span class="hljs-literal">null</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="冻结"><a href="#冻结" class="headerlink" title="冻结"></a>冻结</h3><p><code>Object.freeze()</code>会阻止修改现有的 <code>property</code>，也意味着响应系统无法再追踪变化  </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;&#123; foo &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 这里的 `foo` 不会更新！ --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">v-on:click</span>=<span class="hljs-string">&quot;foo = &#x27;baz&#x27;&quot;</span>&gt;</span>Change it<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="javascript">    <span class="hljs-keyword">var</span> obj = &#123;</span><br><span class="javascript">      foo: <span class="hljs-string">&#x27;bar&#x27;</span></span><br>    &#125;<br><br><span class="javascript">    <span class="hljs-built_in">Object</span>.freeze(obj)</span><br><br><span class="javascript">    <span class="hljs-keyword">new</span> Vue(&#123;</span><br><span class="javascript">      el: <span class="hljs-string">&#x27;#app&#x27;</span>,</span><br>      data: obj<br>    &#125;)<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="前缀"><a href="#前缀" class="headerlink" title="前缀$"></a>前缀<code>$</code></h3><p>除了数据 <code>property</code>，<code>Vue</code> 实例还暴露了一些有用的实例 <code>property</code> 与方法。它们都有前缀 <code>$</code>，以便与用户定义的 <code>property</code> 区分开来  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> data = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">1</span> &#125;<br><span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> Vue(&#123;<br>  el: <span class="hljs-string">&#x27;#example&#x27;</span>,<br>  data: data<br>&#125;)<br><br>vm.$data === data <span class="hljs-comment">// =&gt; true</span><br>vm.$el === <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;example&#x27;</span>) <span class="hljs-comment">// =&gt; true</span><br><br><span class="hljs-comment">// $watch 是一个实例方法</span><br>vm.$watch(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">newValue, oldValue</span>) </span>&#123;<br>  <span class="hljs-comment">// 这个回调将在 `vm.a` 改变后调用</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>可以在 <a href="https://cn.vuejs.org/v2/api/#%E5%AE%9E%E4%BE%8B-property">API</a> 中查阅到完整的实例 <code>property</code> 和方法的列表  </p><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><h4 id="生命周期钩子"><a href="#生命周期钩子" class="headerlink" title="生命周期钩子"></a>生命周期钩子</h4><p>每个<code>Vue</code>实例在被创建时都要经过一系列的初始化过程  </p><blockquote><p>例如，需要设置数据监听、编译模板、将实例挂载到 <code>DOM</code> 并在数据变化时更新 <code>DOM</code> 等  </p></blockquote><p>同时在这个过程中也会运行一些叫做生命周期钩子的函数，这给了用户在不同阶段添加自己的代码的机会  </p><p>比如 <code>created</code> 钩子可以用来在一个实例被创建之后执行代码：  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">new</span> Vue(&#123;<br>  data: &#123;<br>    a: <span class="hljs-number">1</span><br>  &#125;,<br>  created: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-comment">// `this` 指向 vm 实例</span><br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;a is: &#x27;</span> + <span class="hljs-built_in">this</span>.a)<br>  &#125;<br>&#125;)<br><span class="hljs-comment">// =&gt; &quot;a is: 1&quot;</span><br></code></pre></td></tr></table></figure><p>也有一些其它的钩子，在实例生命周期的不同阶段被调用。如 <code>mounted</code>、<code>updated</code> 和 <code>destroyed</code><br>生命周期钩子的 <code>this</code> 上下文指向调用它的 <code>Vue</code> 实例  </p><blockquote><h4 id="不要在选项-property-或回调上使用箭头函数"><a href="#不要在选项-property-或回调上使用箭头函数" class="headerlink" title="不要在选项 property 或回调上使用箭头函数"></a>不要在选项 <code>property</code> 或回调上使用箭头函数</h4><blockquote><p>比如<br>created: () =&gt; console.log(this.a)<br>vm.$watch(‘a’, newValue =&gt; this.myMethod())。</p></blockquote><p>因为箭头函数并没有 <code>this</code>，<code>this</code> 会作为变量一直向上级词法作用域查找，直至找到为止<br>这经常导致 <code>Uncaught TypeError: Cannot read property of undefined</code> 或 <code>Uncaught TypeError: this.myMethod is not a function</code> 之类的错误  </p></blockquote><h4 id="生命周期图例"><a href="#生命周期图例" class="headerlink" title="生命周期图例"></a>生命周期图例</h4><p><img src="/Vue-%E5%89%8D%E7%AB%AF/lifecycle.png"><br>图例上说明了可以使用的钩子函数（红框红字）与生命周期过程<br>以后遇到问题可以作为参考  </p><h1 id="模板语法"><a href="#模板语法" class="headerlink" title="模板语法"></a>模板语法</h1><p><code>Vue.js</code> 使用了基于 <code>HTML</code> 的模板语法，允许开发者声明式地将 <code>DOM</code> 绑定至底层 <code>Vue</code> 实例的数据。所有 <code>Vue.js</code> 的模板都是合法的 <code>HTML</code>，所以能被遵循规范的浏览器和 <code>HTML</code> 解析器解析  </p><p>在底层的实现上，<code>Vue</code> 将模板编译成虚拟 <code>DOM</code> 渲染函数。结合响应系统，<code>Vue</code> 能够智能地计算出最少需要重新渲染多少组件，并把 <code>DOM</code> 操作次数减到最少  </p><h2 id="插值"><a href="#插值" class="headerlink" title="插值"></a>插值</h2><p>顾名思义，就是往<code>HTML</code>中插入一些内容，以填充页面    </p><h3 id="普通文本"><a href="#普通文本" class="headerlink" title="普通文本"></a>普通文本</h3><blockquote><h5 id="“Mustache”语法-双大括号"><a href="#“Mustache”语法-双大括号" class="headerlink" title="“Mustache”语法 (双大括号)"></a>“Mustache”语法 (双大括号)</h5><p>向HTML中插入变量的值  </p></blockquote><p>数据绑定最常见的形式就是使用“Mustache”语法 (双大括号) 的文本插值  </p><ul><li>无法对元素属性使用  </li><li>插入的HTML内容不会被当做元素，只会当做普通字符串  </li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>Message: &#123;&#123; msg &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br></code></pre></td></tr></table></figure><p><code>Mustache</code> 标签将会被替代为对应数据对象上 <code>msg property</code> 的值。无论何时，绑定的数据对象上 <code>msg property</code> 发生了改变，插值处的内容都会更新  </p><h3 id="插值固定"><a href="#插值固定" class="headerlink" title="插值固定"></a>插值固定</h3><blockquote><h5 id="v-once-指令"><a href="#v-once-指令" class="headerlink" title="v-once 指令"></a><a href="https://cn.vuejs.org/v2/api/#v-once">v-once 指令</a></h5><p>用于影响插值，在此指令范围内的文本插值后不会因其原本变量值改变而改变  </p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">v-once</span>&gt;</span>这个将不会改变: &#123;&#123; msg &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="HTML内容"><a href="#HTML内容" class="headerlink" title="HTML内容"></a>HTML内容</h3><blockquote><h5 id="v-html-指令"><a href="#v-html-指令" class="headerlink" title="v-html 指令"></a><a href="https://cn.vuejs.org/v2/api/#v-html">v-html 指令</a></h5><p>用于插入HTML内容  </p></blockquote><p>双大括号会将数据解释为普通文本，要插入HTML内容，需要用这个<code>v-html 指令</code>  </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Using mustaches: &#123;&#123; rawHtml &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Using v-html directive: <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">v-html</span>=<span class="hljs-string">&quot;rawHtml&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这个 <code>span</code> 的内容将会被替换成为 <code>property</code> 值 <code>rawHtml</code>，直接作为 HTML——会忽略解析 <code>property</code> 值中的数据绑定  </p><p>注意，你不能使用 <code>v-html</code> 来复合局部模板，因为 <code>Vue</code> 不是基于字符串的模板引擎。反之，对于用户界面 (UI)，组件更适合作为可重用和可组合的基本单位  </p><blockquote><p>你的站点上动态渲染的任意 <code>HTML</code> 可能会非常危险，因为它很容易导致 <code>XSS 攻击</code>。请只对可信内容使用 <code>HTML</code> 插值，绝不要对用户提供的内容使用插值  </p></blockquote><h3 id="元素属性插值"><a href="#元素属性插值" class="headerlink" title="元素属性插值"></a>元素属性插值</h3><blockquote><h5 id="v-bind-指令"><a href="#v-bind-指令" class="headerlink" title="v-bind 指令"></a>v-bind 指令</h5><p>用于绑定内容与目标元素的属性  </p></blockquote><p><code>Mustache 语法</code>不能作用在 <code>HTML attribute</code> 上，遇到这种情况应该使用 <code>v-bind 指令</code>  </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-bind:id</span>=<span class="hljs-string">&quot;dynamicId&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>对于布尔 <code>attribute</code> (它们只要存在就意味着值为 <code>true</code>)，<code>v-bind</code> 工作起来略有不同  </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">v-bind:disabled</span>=<span class="hljs-string">&quot;isButtonDisabled&quot;</span>&gt;</span>Button<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br></code></pre></td></tr></table></figure><p>如果<code>isButtonDisabled</code> 的值是 <code>null</code>、<code>undefined</code> 或 <code>false</code>，则 <code>disabled attribute</code> 甚至不会被包含在渲染出来的 <code>&lt;button&gt;</code> 元素中  </p><h3 id="JavaScript-表达式"><a href="#JavaScript-表达式" class="headerlink" title="JavaScript 表达式"></a>JavaScript 表达式</h3><p>实际上，对于所有的数据绑定，<code>Vue.js</code> 都提供了完全的 <code>JavaScript</code> 表达式支持  </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html">&#123;&#123; number + 1 &#125;&#125;<br>&#123;&#123; ok ? &#x27;YES&#x27; : &#x27;NO&#x27; &#125;&#125;<br>&#123;&#123; message.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;) &#125;&#125;<br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-bind:id</span>=<span class="hljs-string">&quot;&#x27;list-&#x27; + id&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这些表达式会在所属 <code>Vue</code> 实例的数据作用域下作为 <code>JavaScript</code> 被解析。有个限制就是，每个绑定都只能包含单个表达式  </p><blockquote><h4 id="下面的例子都不会生效"><a href="#下面的例子都不会生效" class="headerlink" title="下面的例子都不会生效"></a>下面的例子都不会生效</h4><p>这是语句，不是表达式 </p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html">&#123;&#123; var a = 1 &#125;&#125;<br></code></pre></td></tr></table></figure><blockquote><p>流控制也不会生效，请使用三元表达式</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html">&#123;&#123; if (ok) &#123; return message &#125; &#125;&#125;<br></code></pre></td></tr></table></figure><p>模板表达式都被放在沙盒中，只能访问一些<a href="https://github.com/vuejs/vue/blob/v2.6.10/src/core/instance/proxy.js#L9">特定的全局变量</a>，如 <code>Math</code> 和 <code>Date</code><br>你不应该在模板表达式中访问用户定义的全局变量  </p><h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><p>指令 (Directives) 是带有 <code>v-</code> 前缀的特殊 <code>attribute</code><br>指令 <code>attribute</code> 的值预期是单个 <code>JavaScript</code> 表达式 (v-for 是例外情况，稍后我们再讨论)。<br>指令的职责是，当表达式的值改变时，将其产生的连带影响，响应式地作用于 <code>DOM</code>  </p><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p>一些指令能够接收一个“参数”，在指令名称之后以冒号表示  </p><blockquote><p>例: <code>v-bind</code> 指令可以用于响应式地更新 <code>HTML attribute</code>  </p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">v-bind:href</span>=<span class="hljs-string">&quot;url&quot;</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在这里 <code>href</code> 是参数，告知 <code>v-bind</code> 指令将该元素的 <code>href attribute</code> 与表达式 <code>url</code> 的值绑定  </p><blockquote><p>例:  <code>v-on</code> 指令，它用于监听 `DOM 事件  </p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">v-on:click</span>=<span class="hljs-string">&quot;doSomething&quot;</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>在这里参数是监听的事件名  </p></blockquote><h3 id="动态参数"><a href="#动态参数" class="headerlink" title="动态参数"></a>动态参数</h3><p>可以用方括号括起来的 <code>JavaScript</code> 表达式作为一个指令的参数  </p><blockquote><p>例：</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">注意，参数表达式的写法存在一些约束，如之后的“对动态参数表达式的约束”章节所述。</span><br><span class="hljs-comment">--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">v-bind:</span>[<span class="hljs-attr">attributeName</span>]=<span class="hljs-string">&quot;url&quot;</span>&gt;</span> ... <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>如果你的 Vue 实例有一个 data property attributeName，其值为 “href”，那么这个绑定将等价于 v-bind:href  </p></blockquote><p>这里的 <code>attributeName</code> 会被作为一个 <code>JavaScript</code> 表达式进行动态求值，求得的值将会作为最终的参数来使用  </p><p>同样地，你可以使用动态参数为一个动态的事件名绑定处理函数：</p><blockquote><p>例：</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">v-on:</span>[<span class="hljs-attr">eventName</span>]=<span class="hljs-string">&quot;doSomething&quot;</span>&gt;</span> ... <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure><p>当 <code>eventName</code> 的值为 “focus” 时，<code>v-on:[eventName]</code> 将等价于 <code>v-on:focus</code>  </p><h4 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h4><h5 id="对动态参数的值的约束"><a href="#对动态参数的值的约束" class="headerlink" title="对动态参数的值的约束"></a>对动态参数的值的约束</h5><ul><li>null<br>动态参数预期会求出一个字符串，异常情况下值为 <code>null</code><br>这个特殊的 <code>null</code> 值可以被显性地用于移除绑定。任何其它非字符串类型的值都将会触发一个警告。</li></ul><h5 id="对动态参数表达式的约束"><a href="#对动态参数表达式的约束" class="headerlink" title="对动态参数表达式的约束"></a>对动态参数表达式的约束</h5><ul><li><p>特殊符号约束<br>动态参数表达式有一些语法约束，因为某些字符，如空格和引号，放在 <code>HTML attribute</code> 名里是无效的  </p><blockquote><p>例：</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 这会触发一个编译警告 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">v-bind:</span>[&#x27;<span class="hljs-attr">foo</span>&#x27; + <span class="hljs-attr">bar</span>]=<span class="hljs-string">&quot;value&quot;</span>&gt;</span> ... <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure><p>  变通的办法是使用没有空格或引号的表达式，或用计算属性替代这种复杂表达式  </p></li><li><p>大小写约束<br>在 <code>DOM</code> 中使用模板时 (直接在一个 <code>HTML</code> 文件里撰写模板)，还需要避免使用大写字符来命名键名，因为浏览器会把 <code>attribute</code> 名全部强制转为小写  </p><blockquote><p>例：</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">在 DOM 中使用模板时这段代码会被转换为 `v-bind:[someattr]`。</span><br><span class="hljs-comment">除非在实例中有一个名为“someattr”的 property，否则代码不会工作。</span><br><span class="hljs-comment">--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">v-bind:</span>[<span class="hljs-attr">someAttr</span>]=<span class="hljs-string">&quot;value&quot;</span>&gt;</span> ... <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h3><p>修饰符 (modifier) 是以半角句号 <code>.</code> 指明的特殊后缀，用于指出一个指令应该以特殊方式绑定。</p><blockquote><p>例如，.prevent 修饰符告诉 v-on 指令对于触发的事件调用 <code>event.preventDefault()</code>  </p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">v-on:submit.prevent</span>=<span class="hljs-string">&quot;onSubmit&quot;</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="缩写"><a href="#缩写" class="headerlink" title="缩写"></a>缩写</h3><p><code>v-</code> 前缀作为一种视觉提示，用来识别模板中 <code>Vue</code> 特定的 <code>attribute</code><br><code>Vue</code> 为 <code>v-bind</code> 和 <code>v-on</code> 这两个最常用的指令，提供了特定简写  </p></li></ul><h4 id="v-bind-缩写"><a href="#v-bind-缩写" class="headerlink" title="v-bind 缩写"></a>v-bind 缩写</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 完整语法 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">v-bind:href</span>=<span class="hljs-string">&quot;url&quot;</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 缩写 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">:href</span>=<span class="hljs-string">&quot;url&quot;</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 动态参数的缩写 (2.6.0+) --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">:</span>[<span class="hljs-attr">key</span>]=<span class="hljs-string">&quot;url&quot;</span>&gt;</span> ... <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="v-on-缩写"><a href="#v-on-缩写" class="headerlink" title="v-on 缩写"></a>v-on 缩写</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 完整语法 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">v-on:click</span>=<span class="hljs-string">&quot;doSomething&quot;</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 缩写 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;doSomething&quot;</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 动态参数的缩写 (2.6.0+) --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> @[<span class="hljs-attr">event</span>]=<span class="hljs-string">&quot;doSomething&quot;</span>&gt;</span> ... <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure><p>它们看起来可能与普通的 <code>HTML</code> 略有不同，但 <code>:</code> 与 <code>@</code> 对于 <code>attribute</code> 名来说都是合法字符，在所有支持 <code>Vue</code> 的浏览器都能被正确地解析<br>它们不会出现在最终渲染的标记中  </p><h1 id="计算属性和侦听器"><a href="#计算属性和侦听器" class="headerlink" title="计算属性和侦听器"></a>计算属性和侦听器</h1><h2 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h2><h3 id="模板表达式-与-计算属性"><a href="#模板表达式-与-计算属性" class="headerlink" title="模板表达式 与 计算属性"></a>模板表达式 与 计算属性</h3><p>模板内的表达式非常便利，但是设计它们的初衷是用于简单运算的  </p><blockquote><p>在模板中放入太多的逻辑会让模板过重且难以维护  </p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;example&quot;</span>&gt;</span><br>  &#123;&#123; message.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;) &#125;&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>在这个地方，模板不再是简单的声明式逻辑。你必须看一段时间才能意识到，这里是想要显示变量 <code>message</code> 的翻转字符串<br>当你想要在模板中多包含此处的翻转字符串时，就会更加难以处理  </p></blockquote><p>对于任何复杂逻辑，你都应当使用计算属性  </p><h3 id="计算属性-1"><a href="#计算属性-1" class="headerlink" title="计算属性"></a>计算属性</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;example&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Original message: &quot;&#123;&#123; message &#125;&#125;&quot;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Computed reversed message: &quot;&#123;&#123; reversedMessage &#125;&#125;&quot;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="javascript">    <span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> Vue(&#123;</span><br><span class="javascript">      el: <span class="hljs-string">&#x27;#example&#x27;</span>,</span><br>      data: &#123;<br><span class="javascript">        message: <span class="hljs-string">&#x27;Hello&#x27;</span></span><br>      &#125;,<br>      computed: &#123;<br><span class="javascript">        <span class="hljs-comment">// 声明了一个计算属性 reversedMessage</span></span><br><span class="javascript">        <span class="hljs-comment">// 计算属性的 getter</span></span><br><span class="javascript">        reversedMessage: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><br><span class="javascript">          <span class="hljs-comment">// `this` 指向 vm 实例</span></span><br><span class="javascript">          <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.message.split(<span class="hljs-string">&#x27;&#x27;</span>).reverse().join(<span class="hljs-string">&#x27;&#x27;</span>)</span><br>        &#125;<br>      &#125;<br>    &#125;)<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这里声明了一个 “计算反转的<code>vm.message</code>字符串的函数” 传入到 计算属性 <code>reversedMessage</code><br>提供的函数将用作 <code>property</code> <code>vm.reversedMessage</code> 的 <code>getter</code> 函数<br>计算属性 <code>reversedMessage</code> 的结果是响应式的  </p><blockquote><p><code>reversedMessage</code> 的值始终取决于 <code>vm.message</code> 的值<br><img src="/Vue-%E5%89%8D%E7%AB%AF/6.gif">  </p></blockquote><p>你可以像绑定普通 <code>property</code> 一样在模板中绑定计算属性<br><code>Vue</code> 知道 <code>vm.reversedMessage</code> 依赖于 <code>vm.message</code>，因此当 <code>vm.message</code> 发生改变时，所有依赖 <code>vm.reversedMessage</code> 的绑定也会更新<br>而且最妙的是我们已经以声明的方式创建了这种依赖关系：<code>计算属性</code>的 <code>getter</code> 函数是没有副作用 (<code>side effect</code>) 的，这使它更易于测试和理解  </p><h4 id="计算属性的-setter"><a href="#计算属性的-setter" class="headerlink" title="计算属性的 setter"></a>计算属性的 setter</h4><p>计算属性默认只有 <code>getter</code>，不过在需要时你也可以提供一个 <code>setter</code>  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript">computed: &#123;<br>  fullName: &#123;<br>    <span class="hljs-comment">// getter</span><br>    get: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.firstName + <span class="hljs-string">&#x27; &#x27;</span> + <span class="hljs-built_in">this</span>.lastName<br>    &#125;,<br>    <span class="hljs-comment">// setter</span><br>    set: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">newValue</span>) </span>&#123;<br>      <span class="hljs-keyword">var</span> names = newValue.split(<span class="hljs-string">&#x27; &#x27;</span>)<br>      <span class="hljs-built_in">this</span>.firstName = names[<span class="hljs-number">0</span>]<br>      <span class="hljs-built_in">this</span>.lastName = names[names.length - <span class="hljs-number">1</span>]<br>    &#125;<br>  &#125;<br>&#125;<br><span class="hljs-comment">// ...</span><br></code></pre></td></tr></table></figure><p>运行 <code>vm.fullName = &#39;John Doe&#39;</code> 时，<code>setter</code> 会被调用<br>因此<code>vm.firstName</code> 和 <code>vm.lastName</code> 也会相应地被更新。</p><h4 id="计算属性缓存-与-方法"><a href="#计算属性缓存-与-方法" class="headerlink" title="计算属性缓存 与 方法"></a>计算属性缓存 与 方法</h4><p>你可能会想到：通过 在表达式中调用方法 来达到和 计算属性 同样的效果  </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Reversed message: &quot;&#123;&#123; reversedMessage() &#125;&#125;&quot;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 在组件中</span><br>methods: &#123;<br>  reversedMessage: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.message.split(<span class="hljs-string">&#x27;&#x27;</span>).reverse().join(<span class="hljs-string">&#x27;&#x27;</span>)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>两种方式的最终结果确实是完全相同的<br>不同的是 <code>计算属性</code> 是基于它们的响应式依赖进行缓存的。只在相关响应式依赖发生改变时它们才会重新求值  </p><p>只要 <code>message</code> 还没有发生改变，多次访问 <code>reversedMessage</code> 计算属性会立即返回之前的计算结果，而会再次执行函数  </p><blockquote><h4 id="可能造成的问题"><a href="#可能造成的问题" class="headerlink" title="可能造成的问题"></a>可能造成的问题</h4><p>下面的 <code>计算属性</code> 将不再更新，因为 <code>Date.now()</code> 不是响应式依赖  </p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">computed: &#123;<br>  now: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Date</span>.now()<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><table><thead><tr><th></th><th>计算属性</th><th>方法</th></tr></thead><tbody><tr><td>更新结果</td><td>依赖更新时更新<br>否则从缓存中得到上次的计算结果</td><td>每次运行都更新</td></tr><tr><td>资源消耗</td><td>小</td><td>大</td></tr><tr><td>速度</td><td>较快</td><td>较慢</td></tr></tbody></table><h4 id="计算属性-vs-侦听属性"><a href="#计算属性-vs-侦听属性" class="headerlink" title="计算属性 vs 侦听属性"></a>计算属性 vs 侦听属性</h4><p><code>Vue</code> 提供了一种更通用的方式来观察和响应 Vue 实例上的数据变动：侦听属性(<code>watch</code>)<br>但通常<code>计算属性</code> 能够取代 命令式的 <code>watch</code>回调，并且让代码更优美  </p><blockquote><p>例：姓更变 或 名更变 时 自动计算全名  </p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;demo&quot;</span>&gt;</span>&#123;&#123; fullName &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><blockquote><p>此处用<code>watch</code>实现  </p></blockquote></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="javascript">    <span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> Vue(&#123;</span><br><span class="javascript">      el: <span class="hljs-string">&#x27;#demo&#x27;</span>,</span><br>      data: &#123;<br><span class="javascript">        firstName: <span class="hljs-string">&#x27;Foo&#x27;</span>,</span><br><span class="javascript">        lastName: <span class="hljs-string">&#x27;Bar&#x27;</span>,</span><br><span class="javascript">        fullName: <span class="hljs-string">&#x27;Foo Bar&#x27;</span></span><br>      &#125;,<br>      watch: &#123;<br><span class="javascript">        <span class="hljs-comment">// 因为要监听两个变量，所以定义了两个</span></span><br><span class="javascript">        firstName: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">val</span>) </span>&#123;</span><br><span class="javascript">          <span class="hljs-built_in">this</span>.fullName = val + <span class="hljs-string">&#x27; &#x27;</span> + <span class="hljs-built_in">this</span>.lastName</span><br>        &#125;,<br><span class="javascript">        lastName: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">val</span>) </span>&#123;</span><br><span class="javascript">          <span class="hljs-built_in">this</span>.fullName = <span class="hljs-built_in">this</span>.firstName + <span class="hljs-string">&#x27; &#x27;</span> + val</span><br>        &#125;<br>      &#125;<br>    &#125;)<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p><span></span></p><blockquote><p>此处用 <code>计算属性</code>实现  </p></blockquote></blockquote><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> Vue(&#123;<br>  el: <span class="hljs-string">&#x27;#demo&#x27;</span>,<br>  data: &#123;<br>    firstName: <span class="hljs-string">&#x27;Foo&#x27;</span>,<br>    lastName: <span class="hljs-string">&#x27;Bar&#x27;</span><br>  &#125;,<br>  computed: &#123;<br>    fullName: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>&#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.firstName + <span class="hljs-string">&#x27; &#x27;</span> + <span class="hljs-keyword">this</span>.lastName<br>    &#125;<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><blockquote><p>对比而言，<code>计算属性</code> 的代码就优美很多  </p></blockquote><h3 id="侦听器"><a href="#侦听器" class="headerlink" title="侦听器"></a>侦听器</h3><p><code>Vue</code> 通过 <code>watch</code> 选项提供了一个更通用的方法，来响应数据的变化<br>当需要在数据变化时执行异步或开销较大的操作时，这个方式是最有用的。  </p><blockquote><p>例：异步<code>Ajax</code>请求</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;watch-example&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><br>    Ask a yes/no question:<br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;question&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;&#123; answer &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>使用 <code>watch</code> 选项允许我们执行异步操作 (访问一个 API)，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的  </p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 因为 AJAX 库和通用工具的生态已经相当丰富，Vue 核心代码没有重复 --&gt;</span><br><span class="hljs-comment">&lt;!-- 提供这些功能以保持精简。这也可以让你自由选择自己更熟悉的工具。 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdn.jsdelivr.net/npm/axios@0.12.0/dist/axios.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdn.jsdelivr.net/npm/lodash@4.13.1/lodash.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript"><span class="hljs-keyword">var</span> watchExampleVM = <span class="hljs-keyword">new</span> Vue(&#123;</span><br><span class="javascript">  el: <span class="hljs-string">&#x27;#watch-example&#x27;</span>,</span><br>  data: &#123;<br><span class="javascript">    question: <span class="hljs-string">&#x27;&#x27;</span>,</span><br><span class="javascript">    answer: <span class="hljs-string">&#x27;I cannot give you an answer until you ask a question!&#x27;</span></span><br>  &#125;,<br>  watch: &#123;<br><span class="javascript">    <span class="hljs-comment">// 如果 `question` 发生改变，这个函数就会运行</span></span><br><span class="javascript">    question: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">newQuestion, oldQuestion</span>) </span>&#123;</span><br><span class="javascript">      <span class="hljs-built_in">this</span>.answer = <span class="hljs-string">&#x27;Waiting for you to stop typing...&#x27;</span></span><br><span class="javascript">      <span class="hljs-built_in">this</span>.debouncedGetAnswer()</span><br>    &#125;<br>  &#125;,<br><span class="javascript">  created: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><br><span class="javascript">    <span class="hljs-comment">// `_.debounce` 是一个通过 Lodash 限制操作频率的函数。</span></span><br><span class="javascript">    <span class="hljs-comment">// 在这个例子中，我们希望限制访问 yesno.wtf/api 的频率</span></span><br><span class="javascript">    <span class="hljs-comment">// AJAX 请求直到用户输入完毕才会发出。想要了解更多关于</span></span><br><span class="javascript">    <span class="hljs-comment">// `_.debounce` 函数 (及其近亲 `_.throttle`) 的知识，</span></span><br><span class="javascript">    <span class="hljs-comment">// 请参考：https://lodash.com/docs#debounce</span></span><br><span class="javascript">    <span class="hljs-built_in">this</span>.debouncedGetAnswer = _.debounce(<span class="hljs-built_in">this</span>.getAnswer, <span class="hljs-number">500</span>)</span><br>  &#125;,<br>  methods: &#123;<br><span class="javascript">    getAnswer: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><br><span class="javascript">      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.question.indexOf(<span class="hljs-string">&#x27;?&#x27;</span>) === -<span class="hljs-number">1</span>) &#123;</span><br><span class="javascript">        <span class="hljs-built_in">this</span>.answer = <span class="hljs-string">&#x27;Questions usually contain a question mark. ;-)&#x27;</span></span><br><span class="javascript">        <span class="hljs-keyword">return</span></span><br>      &#125;<br><span class="javascript">      <span class="hljs-built_in">this</span>.answer = <span class="hljs-string">&#x27;Thinking...&#x27;</span></span><br><span class="javascript">      <span class="hljs-keyword">var</span> vm = <span class="hljs-built_in">this</span></span><br><span class="javascript">      axios.get(<span class="hljs-string">&#x27;https://yesno.wtf/api&#x27;</span>)</span><br><span class="javascript">        .then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">response</span>) </span>&#123;</span><br>          vm.answer = _.capitalize(response.data.answer)<br>        &#125;)<br><span class="javascript">        .catch(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">error</span>) </span>&#123;</span><br><span class="javascript">          vm.answer = <span class="hljs-string">&#x27;Error! Could not reach the API. &#x27;</span> + error</span><br>        &#125;)<br>    &#125;<br>  &#125;<br>&#125;)<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>除了 <code>watch</code> 选项之外，还可以使用命令式的 <a href="https://cn.vuejs.org/v2/api/#vm-watch"><code>vm.$watch</code> API</a>  </p><h1 id="Class-与-Style绑定"><a href="#Class-与-Style绑定" class="headerlink" title="Class 与 Style绑定"></a>Class 与 Style绑定</h1><p>操作元素的 <code>class</code> 列表和内联样式是数据绑定的一个常见需求。它们都是 <code>attribute</code>，所以可以用 <code>v-bind</code> 处理它们<br>在将 <code>v-bind</code> 用于 <code>class</code> 和 <code>style</code> 时，<code>Vue.js</code> 做了专门的增强。表达式结果的类型除了字符串之外，还可以是对象或数组  </p><h2 id="绑定-HTML-Class"><a href="#绑定-HTML-Class" class="headerlink" title="绑定 HTML Class"></a>绑定 HTML Class</h2><h3 id="对象语法"><a href="#对象语法" class="headerlink" title="对象语法"></a>对象语法</h3><h4 id="多字段设置"><a href="#多字段设置" class="headerlink" title="多字段设置"></a>多字段设置</h4><p>可以传给 <code>v-bind:class</code> 多个字段，以动态地切换 <code>class</code>  </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> </span><br><span class="hljs-tag">    <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;static&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">v-bind:class</span>=<span class="hljs-string">&quot;&#123; active: isActive &#125;&quot;</span></span><br><span class="hljs-tag">&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p><code>v-bind:class</code> 指令也可以与普通的 <code>class</code> <code>attribute</code> 共存，最终得到的结果会是它们拼接在一起的样子    </p><blockquote><p>多字段来动态切换Class  </p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs html">&lt;div<br>    id=&quot;example&quot;<br>    class=&quot;static&quot;<br>    v-bind:class=&quot;&#123; active: isActive, &#x27;text-danger&#x27;: hasError &#125;&quot;<br>&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="javascript">    <span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> Vue(&#123;</span><br><span class="javascript">        el: <span class="hljs-string">&#x27;#example&#x27;</span>,</span><br>    data: &#123;<br><span class="javascript">        isActive: <span class="hljs-literal">true</span>,</span><br><span class="javascript">        hasError: <span class="hljs-literal">false</span></span><br>    &#125;<br>&#125;)<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>会得到这样的渲染结果 <code>static activate</code><br><img src="/Vue-%E5%89%8D%E7%AB%AF/20201124085448963.png"><br>类似的，这样设置的样式是响应式的，如果修改<code>isActive</code>与<code>hasError</code>设置的内容也会相应的做出改变  </p></blockquote><h4 id="单对象"><a href="#单对象" class="headerlink" title="单对象"></a>单对象</h4><p>与上面的多个字段类似，可以在一个对象中设置多个属性（作为字段），来进行<code>class</code>的切换  </p><blockquote><p>单个对象来动态切换class</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs html">&lt;div<br>    id=&quot;example&quot;<br>    class=&quot;static&quot;<br>    v-bind:class=&quot;classObject&quot;<br>&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="javascript"><span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> Vue(&#123;</span><br><span class="javascript">    el: <span class="hljs-string">&#x27;#example&#x27;</span>,</span><br>    data: &#123;<br>        classObject: &#123;<br><span class="javascript">            active: <span class="hljs-literal">true</span>,</span><br><span class="javascript">            <span class="hljs-string">&#x27;text-danger&#x27;</span>: <span class="hljs-literal">false</span></span><br>        &#125;<br>    &#125;<br>&#125;)<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>会得到和上面的例子一样的的结果  </p></blockquote><h2 id="数组语法"><a href="#数组语法" class="headerlink" title="数组语法"></a>数组语法</h2><p>可以把一个数组传给 <code>v-bind:class</code>，以应用一个 <code>class</code> 列表  </p><blockquote><p>数组来动态切换class</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> </span><br><span class="hljs-tag">    <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;example&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">v-bind:class</span>=<span class="hljs-string">&quot;[activeClass, errorClass]&quot;</span></span><br><span class="hljs-tag">&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="javascript"><span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> Vue(&#123;</span><br><span class="javascript">    el: <span class="hljs-string">&#x27;#example&#x27;</span>,</span><br>    data: &#123;<br><span class="javascript">        activeClass: <span class="hljs-string">&#x27;active&#x27;</span>,</span><br><span class="javascript">        errorClass: <span class="hljs-string">&#x27;text-danger&#x27;</span></span><br>    &#125;<br>&#125;)<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>最终渲染结果为<code>class=&quot;active text-danger&quot;</code><br><img src="/Vue-%E5%89%8D%E7%AB%AF/20201124092827386.png">  </p></blockquote><p>你可以在数组中填入表达式，但这会造成内容的不美观，不建议那样做  </p><h2 id="绑定内联样式-style"><a href="#绑定内联样式-style" class="headerlink" title="绑定内联样式 style"></a>绑定内联样式 style</h2><p><code>v-bind:style</code> 的对象语法十分直观——看着非常像 <code>CSS</code>，但其实是一个 <code>JavaScript</code> 对象<br><code>CSS property</code> 名可以用驼峰式 (camelCase) 或短横线分隔 (kebab-case，记得用引号括起来) 来命名  </p><h3 id="多字段设置style"><a href="#多字段设置style" class="headerlink" title="多字段设置style"></a>多字段设置style</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> </span><br><span class="hljs-tag">    <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;example&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">v-bind:style</span>=<span class="hljs-string">&quot;&#123; color: activeColor, fontSize: fontSize + &#x27;px&#x27; &#125;&quot;</span>&gt;</span>Hello<br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="javascript"><span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> Vue(&#123;</span><br><span class="javascript">    el: <span class="hljs-string">&#x27;#example&#x27;</span>,</span><br>    data: &#123;<br><span class="javascript">        activeColor: <span class="hljs-string">&#x27;red&#x27;</span>,</span><br>        fontSize: 30<br>    &#125;<br>&#125;)<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>最终得到的<code>style=&quot;color: red; font-size: 30px;&quot;</code><br><img src="/Vue-%E5%89%8D%E7%AB%AF/20201124094841954.png">  </p></blockquote><h3 id="对象设置Style"><a href="#对象设置Style" class="headerlink" title="对象设置Style"></a>对象设置Style</h3><p>类似的，<code>v-bind:style</code>可以在一个或多个对象中设置属性（作为字段），来进行<code>style</code>的设置  </p><blockquote><p>单个对象设置 style</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> </span><br><span class="hljs-tag">    <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;example&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">v-bind:style</span>=<span class="hljs-string">&quot;styleObject&quot;</span>&gt;</span>Hello<br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="javascript"><span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> Vue(&#123;</span><br><span class="javascript">    el: <span class="hljs-string">&#x27;#example&#x27;</span>,</span><br>    data: &#123;<br>        styleObject: &#123;<br><span class="javascript">            color: <span class="hljs-string">&#x27;red&#x27;</span>,</span><br><span class="javascript">            fontSize: <span class="hljs-string">&#x27;30px&#x27;</span></span><br>        &#125;<br>    &#125;<br>&#125;)<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>得到的结果与上个例子一致: <code>style=&quot;color: red; font-size: 30px;&quot;</code>  </p></blockquote><p>对于希望设置多个对象到元素上时，需要用数组括起来  </p><blockquote><p>多个对象设置 style  </p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> </span><br><span class="hljs-tag">    <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;example&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">v-bind:style</span>=<span class="hljs-string">&quot;[colorStyleObject, fontStyleObject]&quot;</span>&gt;</span>Hello<br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="javascript"><span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> Vue(&#123;</span><br><span class="javascript">    el: <span class="hljs-string">&#x27;#example&#x27;</span>,</span><br>    data: &#123;<br>        colorStyleObject: &#123;<br><span class="javascript">            color: <span class="hljs-string">&#x27;red&#x27;</span></span><br>        &#125;,<br>        fontStyleObject:&#123;<br><span class="javascript">            fontSize: <span class="hljs-string">&#x27;30px&#x27;</span></span><br>        &#125;<br>    &#125;<br>&#125;)<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>得到的结果与上个例子一致: <code>style=&quot;color: red; font-size: 30px;&quot;</code>  </p></blockquote><h3 id="自动添加前缀"><a href="#自动添加前缀" class="headerlink" title="自动添加前缀"></a>自动添加前缀</h3><p>当 <code>v-bind:style</code> 使用需要添加浏览器引擎前缀的 <code>CSS property</code> 时，如 <code>transform</code>，<code>Vue.js</code> 会自动侦测并添加相应的前缀  </p><h3 id="多重值"><a href="#多重值" class="headerlink" title="多重值"></a>多重值</h3><p>可以为 <code>style</code> 绑定中的 <code>property</code> 提供一个包含多个值的数组，常用于提供多个带前缀的值，这样写只会渲染数组中最后一个被浏览器支持的值  </p><blockquote><p>包含多个值的 preoperty 数组</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">:style</span>=<span class="hljs-string">&quot;&#123; display: [&#x27;-webkit-box&#x27;, &#x27;-ms-flexbox&#x27;, &#x27;flex&#x27;] &#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>如果此处浏览器支持不带浏览器前缀的 flexbox，那么就只会渲染 display: flex  </p></blockquote><h1 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h1><h2 id="v-if-与-v-else"><a href="#v-if-与-v-else" class="headerlink" title="v-if 与 v-else"></a>v-if 与 v-else</h2><p><code>v-if</code> 指令用于条件性地渲染一块内容<br>这块内容只会在指令的表达式返回 <code>truthy</code> 值的时候被渲染  </p><p><code>v-else</code> 指令来表示 <code>v-if</code> 的 “else 块”<br><code>v-else</code> 元素必须紧跟在带 <code>v-if</code> 或者 <code>v-else-if</code> 的元素的后面，否则它将不会被识别  </p><blockquote><p><code>v-if</code>与<code>v-else</code>的基本使用方式  </p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;example&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;is_awesome&quot;</span>&gt;</span>Vue is awesome!<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">v-else</span>&gt;</span>Oh no 😢<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="javascript">  <span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> Vue(&#123;</span><br><span class="javascript">    el: <span class="hljs-string">&#x27;#example&#x27;</span>,</span><br>    data: &#123;<br><span class="javascript">      is_awesome: <span class="hljs-literal">true</span></span><br>    &#125;<br>  &#125;)<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p><img src="/Vue-%E5%89%8D%E7%AB%AF/7.gif"><br>依旧，这个渲染是响应式的，而且在状态发生改变之前，页面上不会有多余的元素（并不是hide，而是完全没有）  </p></blockquote><h3 id="v-if-与-v-for-一起使用"><a href="#v-if-与-v-for-一起使用" class="headerlink" title="v-if 与 v-for 一起使用"></a>v-if 与 v-for 一起使用</h3><p>不推荐同时使用 <code>v-if</code> 和 <code>v-for</code>。请查阅<a href="https://cn.vuejs.org/v2/style-guide/#%E9%81%BF%E5%85%8D-v-if-%E5%92%8C-v-for-%E7%94%A8%E5%9C%A8%E4%B8%80%E8%B5%B7-%E5%BF%85%E8%A6%81">风格指南</a>以获取更多信息<br>当 <code>v-if</code> 与 <code>v-for</code> 一起使用时，<code>v-for</code> 具有比 <code>v-if</code> 更高的优先级。请查阅<a href="https://cn.vuejs.org/v2/guide/list.html#v-for-with-v-if">列表渲染指南</a>以获取详细信息。</p><h2 id="v-else-if"><a href="#v-else-if" class="headerlink" title="v-else-if"></a>v-else-if</h2><p><code>v-else-if</code>，顾名思义，其作用就相当于马上在<code>else</code>后接一个<code>if</code>判断<br>类似于 <code>v-else</code>，<code>v-else-if</code> 也必须紧跟在带 <code>v-if</code> 或者 <code>v-else-if</code> 的元素之后  </p><blockquote><p><code>v-else-if</code>的使用方式  </p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;example&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;type === &#x27;A&#x27;&quot;</span>&gt;</span>A<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-else-if</span>=<span class="hljs-string">&quot;type === &#x27;B&#x27;&quot;</span>&gt;</span>B<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-else-if</span>=<span class="hljs-string">&quot;type === &#x27;C&#x27;&quot;</span>&gt;</span>C<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-else</span>&gt;</span>Not A/B/C<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="javascript">  <span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> Vue(&#123;</span><br><span class="javascript">    el: <span class="hljs-string">&#x27;#example&#x27;</span>,</span><br>    data: &#123;<br><span class="javascript">      type: <span class="hljs-string">&#x27;A&#x27;</span></span><br>    &#125;<br>  &#125;)<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p><img src="/Vue-%E5%89%8D%E7%AB%AF/8.gif">  </p></blockquote><h2 id="用-key-管理可复用的元素"><a href="#用-key-管理可复用的元素" class="headerlink" title="用 key 管理可复用的元素"></a>用 key 管理可复用的元素</h2><p><code>Vue</code> 会尽可能高效地渲染元素，通常会复用已有元素而不是从头开始渲染  这么做除了使 <code>Vue</code> 变得非常快之外，还有其它一些现象    </p><blockquote><p>尽可能复用：用户在不同的登录方式之间切换    </p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;example&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;loginType === &#x27;username&#x27;&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span>Username<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;Enter your username&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-else</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span>Email<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;Enter your email address&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="javascript">  <span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> Vue(&#123;</span><br><span class="javascript">    el: <span class="hljs-string">&#x27;#example&#x27;</span>,</span><br>    data: &#123;<br><span class="javascript">      loginType: <span class="hljs-string">&#x27;username&#x27;</span></span><br>    &#125;<br>  &#125;)<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p><img src="/Vue-%E5%89%8D%E7%AB%AF/9.gif"><br>切换 <code>loginType</code> 将不会清除用户已经输入的内容<br>两个模板都使用了相同的元素<code>&lt;input&gt;</code>。因为<code>vue</code>总是希望尽可能复用，这个元素不会被替换掉(此处仅替换了它的 <code>placeholder</code>属性)<br>这会造成一些问题，一般切换输入类型都需要将已输入内容清空，而这里没清<br>如果不希望<code>vue</code>最大程度复用，那么可以为元素添加<code>key</code>属性<br>需要注意，<code>key</code>属性需要一个唯一值  </p></blockquote><blockquote><p>独立的key：用户在不同的登录方式之间切换    </p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs html">  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;example&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;loginType === &#x27;username&#x27;&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span>Username<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;Enter your username&quot;</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;username-input&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-else</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span>Email<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;Enter your email address&quot;</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;email-input&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="javascript">    <span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> Vue(&#123;</span><br><span class="javascript">      el: <span class="hljs-string">&#x27;#example&#x27;</span>,</span><br>      data: &#123;<br><span class="javascript">        loginType: <span class="hljs-string">&#x27;username&#x27;</span></span><br>      &#125;<br>    &#125;)<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p><img src="/Vue-%E5%89%8D%E7%AB%AF/10.gif"><br>在设置了<code>key</code>后，模板内容会被重新渲染后才放到页面上。所以输入的内容消失了    </p></blockquote><h2 id="v-show"><a href="#v-show" class="headerlink" title="v-show"></a>v-show</h2><p>另一个用于根据条件展示元素的选项是 <code>v-show</code> 指令<br>用法与 <code>v-if</code> 类似，都是表达式返回 <code>truthy</code> 值的时候被渲染<br>不同的是带有 <code>v-show</code> 的元素始终会被渲染并保留在 <code>DOM</code> 中<br><code>v-show</code> 只是简单地切换元素的 <code>CSS property display</code>  </p><p><strong>注意，<code>v-show</code> 不支持 <code>&lt;template&gt;</code> 元素，也不支持 <code>v-else</code></strong>  </p><blockquote><p><code>v-show</code>的使用  </p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;example&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">v-show</span>=<span class="hljs-string">&quot;is_awesome&quot;</span>&gt;</span>Vue is awesome!<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="javascript">  <span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> Vue(&#123;</span><br><span class="javascript">    el: <span class="hljs-string">&#x27;#example&#x27;</span>,</span><br>    data: &#123;<br><span class="javascript">      is_awesome: <span class="hljs-literal">true</span></span><br>    &#125;<br>  &#125;)<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p><img src="/Vue-%E5%89%8D%E7%AB%AF/11.gif">  </p></blockquote><h2 id="v-if-对比-v-show"><a href="#v-if-对比-v-show" class="headerlink" title="v-if 对比 v-show"></a>v-if 对比 v-show</h2><p><code>v-if</code> 是“真正”的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。</p><p><code>v-if</code> 也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。</p><p>相比之下，<code>v-show</code> 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 <code>CSS</code> 进行切换。</p><p>一般来说，<code>v-if</code> 有更高的切换开销，而 <code>v-show</code> 有更高的初始渲染开销  因此，如果需要非常频繁地切换，则使用 <code>v-show</code> 较好；如果在运行时条件很少改变，则使用 <code>v-if</code> 较好  </p><h1 id="列表渲染"><a href="#列表渲染" class="headerlink" title="列表渲染"></a>列表渲染</h1><h2 id="v-for-对应数组"><a href="#v-for-对应数组" class="headerlink" title="v-for 对应数组"></a>v-for 对应数组</h2><p>可以用 <code>v-for</code> 指令基于一个数组来渲染一个列表<br><code>v-for</code> 指令需要使用 <code>item in items</code> 形式的特殊语法，其中 <code>items</code> 是源数据数组，而 <code>item</code> 则是被迭代的数组元素的别名  </p><blockquote><p><code>v-for</code>对应数组到元素  </p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;example-1&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;item in items&quot;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;item.message&quot;</span>&gt;</span><br>    &#123;&#123; item.message &#125;&#125;<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="javascript">  <span class="hljs-keyword">var</span> example1 = <span class="hljs-keyword">new</span> Vue(&#123;</span><br><span class="javascript">    el: <span class="hljs-string">&#x27;#example-1&#x27;</span>,</span><br>    data: &#123;<br>      items: [<br><span class="javascript">        &#123; <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;Foo&#x27;</span> &#125;,</span><br><span class="javascript">        &#123; <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;Bar&#x27;</span> &#125;</span><br>      ]<br>    &#125;<br>  &#125;)<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>VSCode-json文件注释报错</title>
    <link href="/post/f31007a7/"/>
    <url>/post/f31007a7/</url>
    
    <content type="html"><![CDATA[<h1 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h1><p>默认的情况下，用<code>VSCode</code>打开有注释的<code>JSON</code>文件的话，会显示不允许有注释的错误<br><img src="/VSCode-json%E6%96%87%E4%BB%B6%E6%B3%A8%E9%87%8A%E6%8A%A5%E9%94%99/20201111105657326.png"></p><h1 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h1><p>实际上这是标准的问题<br>标准的<code>JSON</code>并不允许注释的存在，所以报错是理所当然的<br><code>JSONC</code>(JSON with Comments)才是允许写注释的标准  </p><blockquote><p>注释方法与C一样  </p></blockquote><h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><h2 id="对单文件"><a href="#对单文件" class="headerlink" title="对单文件"></a>对单文件</h2><p>更改<code>JSON</code>标准为<code>JSONC</code>  </p><ol><li>打开标准选择<br><img src="/VSCode-json%E6%96%87%E4%BB%B6%E6%B3%A8%E9%87%8A%E6%8A%A5%E9%94%99/20201111110252392.png">  </li><li>设置标准为 JSONC<br><img src="/VSCode-json%E6%96%87%E4%BB%B6%E6%B3%A8%E9%87%8A%E6%8A%A5%E9%94%99/20201111110339930.png">  </li></ol><h2 id="对所有-json文件"><a href="#对所有-json文件" class="headerlink" title="对所有.json文件"></a>对所有.json文件</h2><p>在用户设置中设置JSONC为默认  </p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs json">&quot;files.associations&quot;: &#123;<br>    &quot;*.json&quot;: &quot;jsonc&quot;<br>&#125;,<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>JSON</tag>
      
      <tag>VSCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python-大JSON文件读取-ijson</title>
    <link href="/post/aaf3dbde/"/>
    <url>/post/aaf3dbde/</url>
    
    <content type="html"><![CDATA[<h1 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h1><p>在学过一些<code>Python</code>的日常使用方法以后，你应该已经知道了<code>Python</code>自带的<code>json</code>库，它能处理一些<code>json</code>数据  </p><blockquote><p>例如：</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">json.loads()  <span class="hljs-comment"># str读取</span><br>json.dumps()  <span class="hljs-comment"># 转为str</span><br></code></pre></td></tr></table></figure><p>但在面对一个体量很大的 <code>JSON</code> 文件时，无论是写还是读都会非常吃力<br>专门用于处理大 <code>JSON</code> 的库是 <code>ijson</code>  </p><h2 id="ijson"><a href="#ijson" class="headerlink" title="ijson"></a>ijson</h2><p><code>Ijson</code>是具有标准<code>Python</code>迭代器接口的迭代<code>JSON</code>解析器  </p><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p>pypi: <a href="https://pypi.org/project/ijson/">https://pypi.org/project/ijson/</a>  </p><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pip install ijson<br></code></pre></td></tr></table></figure><p>版本需求：3.5+</p><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><figure class="highlight"><figcaption><span>说明中使用的json文件.json</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs JSON">&#123;<br>  <span class="hljs-attr">&quot;earth&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;europe&quot;</span>: [<br>      &#123;&quot;name&quot;: &quot;Paris&quot;, &quot;type&quot;: &quot;city&quot;, &quot;info&quot;: &#123; ... &#125;&#125;,<br>      &#123;&quot;name&quot;: &quot;Thames&quot;, &quot;type&quot;: &quot;river&quot;, &quot;info&quot;: &#123; ... &#125;&#125;,<br>      <span class="hljs-comment">// ...</span><br>    ],<br>    &quot;america&quot;: [<br>      &#123;&quot;name&quot;: &quot;Texas&quot;, &quot;type&quot;: &quot;state&quot;, &quot;info&quot;: &#123; ... &#125;&#125;,<br>      <span class="hljs-comment">// ...</span><br>    ]<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="常用用法-ijson-items"><a href="#常用用法-ijson-items" class="headerlink" title="常用用法 ijson.items"></a>常用用法 ijson.items</h3><p>最常见的用法：让<code>ijson</code>从<code>JSON</code>流中 获取前缀下的内容。并转换为<code>Python</code>对象  </p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs prolog">import ijson<br><br>f = open(<span class="hljs-string">&#x27;file.json&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>)<br># 相当于获取json[<span class="hljs-string">&#x27;earth&#x27;</span>][<span class="hljs-string">&#x27;europe&#x27;</span>]下的内容<br>objects = ijson.items(f, <span class="hljs-string">&#x27;earth.europe.item&#x27;</span>)<br>cities = (o for o in objects if o[<span class="hljs-string">&#x27;type&#x27;</span>] == <span class="hljs-string">&#x27;city&#x27;</span>)<br>for city in cities:<br>    do_something_with(city)<br></code></pre></td></tr></table></figure><h3 id="只获取值-ijson-kvitems"><a href="#只获取值-ijson-kvitems" class="headerlink" title="只获取值 ijson.kvitems"></a>只获取值 ijson.kvitems</h3><p>如果你只需要values，而不需要key，可以用<code>ijson.kvitems</code><br>这个函数的处理效率比<code>ijson.items</code>要高  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> ijson<br><br>f = urlopen(<span class="hljs-string">&#x27;http://.../&#x27;</span>)<br>european_places = ijson.kvitems(f, <span class="hljs-string">&#x27;earth.europe.item&#x27;</span>)<br>names = (v <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> european_places <span class="hljs-keyword">if</span> k == <span class="hljs-string">&#x27;name&#x27;</span>)<br><span class="hljs-keyword">for</span> name <span class="hljs-keyword">in</span> names:<br>    do_something_with(name)<br></code></pre></td></tr></table></figure><h3 id="asyncio支持"><a href="#asyncio支持" class="headerlink" title="asyncio支持"></a><code>asyncio</code>支持</h3><p>方法也可以异步进行  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> asyncio<br><span class="hljs-keyword">import</span> ijson<br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span>():</span><br>    f = <span class="hljs-keyword">await</span> async_urlopen(<span class="hljs-string">&#x27;http://..../&#x27;</span>)<br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">for</span> <span class="hljs-built_in">object</span> <span class="hljs-keyword">in</span> ijson.items(f, <span class="hljs-string">&#x27;earth.europe.item&#x27;</span>):<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">object</span>[<span class="hljs-string">&#x27;type&#x27;</span>] == <span class="hljs-string">&#x27;city&#x27;</span>:<br>            do_something_with(city)<br>asyncio.run(run())<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>ijson</tag>
      
      <tag>JSON</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python-asyncio-协程</title>
    <link href="/post/2d2478f5/"/>
    <url>/post/2d2478f5/</url>
    
    <content type="html"><![CDATA[<h1 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h1><p><code>asyncio</code>是用来编写 <code>并发</code> 代码的库，使用 <code>async/await</code> 语法<br><code>asyncio</code> 被用作多个提供高性能 <code>Python</code> 异步框架的基础，包括网络和网站服务，数据库连接库，分布式任务队列等等  </p><blockquote><p><code>asyncio</code> 往往是构建 <code>IO密集型</code> 和高层级 <code>结构化</code> 网络代码的最佳选择  </p></blockquote><h2 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h2><p><code>asyncio</code>官网：<a href="https://docs.python.org/zh-cn/3/library/asyncio.html">https://docs.python.org/zh-cn/3/library/asyncio.html</a>  </p><p><code>asyncio</code>提供一组 <code>高层级</code>API 用于:<br>并发地 运行 <code>Python 协程</code> 并对其执行过程实现完全控制;  </p><ul><li>执行 <code>网络 IO 和 IPC</code>;  </li><li>控制 <code>子进程</code>;  </li><li>通过 <code>队列</code> 实现分布式任务;  </li><li><code>同步</code> 并发代码;  </li></ul><p>此外，还有一些 <code>低层级</code> API 以支持 库和框架的开发者 实现:  </p><ul><li>创建和管理 <code>事件循环</code>，以提供异步 API 用于 <code>网络化</code>, 运行 <code>子进程</code>，处理 <code>OS 信号</code> 等等;  </li><li>使用 <code>transports</code> 实现高效率协议;  </li><li>通过 async/await 语法 <code>桥接</code> 基于回调的库和代码  </li></ul><h1 id="协程与任务"><a href="#协程与任务" class="headerlink" title="协程与任务"></a>协程与任务</h1><h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><p><code>协程</code> 通过 <code>async/await</code> 语法进行声明，是编写 <code>asyncio</code> 应用的推荐方式  </p><blockquote><p>协程基础</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> asyncio<br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    print(<span class="hljs-string">&#x27;hello&#x27;</span>)<br>    <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">1</span>)<br>    print(<span class="hljs-string">&#x27;world&#x27;</span>)<br><br>    asyncio.run(main())<br></code></pre></td></tr></table></figure><blockquote><p>结果</p></blockquote><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">hello</span><br><span class="hljs-attribute">world</span><br></code></pre></td></tr></table></figure><blockquote><p>注意：简单地调用一个协程并不会将其加入执行日程  </p></blockquote><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul><li>协程函数: 定义形式为 <code>async def</code> 的函数  </li><li>协程对象: 调用 <code>协程函数</code> 所返回的对象  </li></ul><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><p>要真正运行一个协程，<code>asyncio</code> 提供了三种主要机制:  </p><ul><li><a href="https://docs.python.org/zh-cn/3/library/asyncio-task.html#asyncio.run"><code>asyncio.run()</code></a> 函数直接运行<br><code>asyncio.run()</code>是用来运行协程的最高层级的入口，案例见上</li><li>串行运行<br>没有特别设置的情况下，连续 <code>await</code> 一个或多个协程能让它串行运行，<a id="BackExampleJustAwait" href="#ExampleJustAwait">案例</a>  </li><li>并发运行<br><code>asyncio.create_task()</code> 函数用来作为 <code>asyncio</code> 任务 的多个协程，<a id="BackExampleCreateTaskMostBasing" href="#ExampleCreateTaskMostBasing">案例</a>  </li></ul><h2 id="可等待对象"><a href="#可等待对象" class="headerlink" title="可等待对象"></a>可等待对象</h2><p>如果一个对象可以在 <code>await</code> 语句中使用，那么它就是 可等待对象<br>许多 <code>asyncio API</code> 都被设计为接受可等待对象  </p><p>可等待 对象有三种主要类型：协程、任务、Future  </p><h3 id="可等待对象-协程"><a href="#可等待对象-协程" class="headerlink" title="可等待对象 - 协程"></a>可等待对象 - 协程</h3><p><code>Python</code> <code>协程</code>属于 <code>可等待</code> 对象，因此可以在其他协程中被等待  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> asyncio<br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">nested</span>():</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">42</span><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    <span class="hljs-comment"># 如果一个协程创建出来，但是没有被 await ,那么它根本就不会被执行</span><br>    nested()<br>    <span class="hljs-comment"># await 以后才会被执行</span><br>    print(<span class="hljs-keyword">await</span> nested())  <span class="hljs-comment"># 将会输出42</span><br><br>asyncio.run(main())<br></code></pre></td></tr></table></figure><h3 id="可等待对象-Task-任务"><a href="#可等待对象-Task-任务" class="headerlink" title="可等待对象 - Task 任务"></a>可等待对象 - Task 任务</h3><p><code>Task</code> 被用来设置日程以便 <code>并发</code> 执行协程。</p><p>当一个协程通过 <a href="https://docs.python.org/zh-cn/3/library/asyncio-task.html#asyncio.create_task"><code>asyncio.create_task()</code></a> 等函数被打包为一个 <code>Task</code>，该协程将自动排入日程准备立即运行:  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> asyncio<br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">nested</span>():</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">42</span><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    <span class="hljs-comment"># 利用 协程函数 nested() 创建了一个 Task</span><br>    <span class="hljs-comment"># 这个 Task 会被 协程 main() 立即执行</span><br>    task = asyncio.create_task(nested())<br>    <span class="hljs-keyword">await</span> task<br><br>asyncio.run(main())<br></code></pre></td></tr></table></figure><h4 id="名字-与-计算结果"><a href="#名字-与-计算结果" class="headerlink" title="名字 与 计算结果"></a>名字 与 计算结果</h4><ul><li>名字<br>可以为<code>Task</code>对象设置一个名字，用来辨识不同的对象<br>名字可以在创建的时候通过参数设置, 也可以通过<code>set_name()</code>方法进行设置  </li><li>获取计算结果<br>可以通过<code>result()</code>方法来获取<code>Task</code>运行完毕以后得到的计算结果  </li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> asyncio<br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">nested</span>():</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">42</span><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    task = asyncio.create_task(nested())<br>    <span class="hljs-comment"># 设置 Task 的名字。其实也可以在创建的时候传参来设置</span><br>    task.set_name(<span class="hljs-string">&#x27;My_name_is_Task&#x27;</span>)<br>    <span class="hljs-keyword">await</span> task<br>    print(<span class="hljs-string">&#x27;Task 的名字为:&#x27;</span>, task.get_name())<br>    print(<span class="hljs-string">&#x27;Task 的计算结果为:&#x27;</span>, task.result())<br><br>asyncio.run(main())<br></code></pre></td></tr></table></figure><h4 id="运行完毕-与-取消"><a href="#运行完毕-与-取消" class="headerlink" title="运行完毕 与 取消"></a>运行完毕 与 取消</h4><ul><li>是否运行完毕<br>查看 <code>Task</code> 是否运行完毕可以用<code>done()</code>方法<br>如果 <code>Task</code> 对象 <strong>已完成</strong> 则返回 <code>True</code><br>当 <code>Task</code> 所封包的协程返回一个值、引发一个异常或 <code>Task</code> 本身被取消时，会被认为 <strong>已完成</strong>  </li><li>取消<br>要取消一个正在运行的 <code>Task</code> 对象可使用 <code>cancel()</code> 方法<br>调用此方法将使该 <code>Task</code> 对象抛出一个 <code>CancelledError</code> 异常给打包的协程  </li><li>查看是否被取消<br>使用<code>cancelled()</code>方法可以查看<code>Task</code>是否已经被取消运行  </li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> asyncio<br><span class="hljs-keyword">from</span> random <span class="hljs-keyword">import</span> randint<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">nested</span>():</span><br>    a = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>):<br>        <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">1</span>)<br>        a += randint(<span class="hljs-number">1</span>,<span class="hljs-number">10</span>)<br>        print(<span class="hljs-string">&#x27;nested -&gt; &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(a))<br>    <span class="hljs-keyword">return</span> a<br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">using_cancel</span>():</span><br>    _task = asyncio.create_task(nested())<br>    <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">2</span>)  <span class="hljs-comment"># 等待,以验证真的是运行以后再取消</span><br>    _task.cancel()<br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-keyword">await</span> _task<br>    <span class="hljs-keyword">except</span> asyncio.CancelledError:<br>        <span class="hljs-keyword">if</span> _task.cancelled():  <span class="hljs-comment"># cancelled() 可被用来检测 Task 对象是否被取消。</span><br>            print(<span class="hljs-string">&quot;task 已经被取消了&quot;</span>)<br><br>        <span class="hljs-keyword">if</span> _task.done():  <span class="hljs-comment"># done()方法 返回 Task 是否已经完成  </span><br>            print(<span class="hljs-string">&#x27;task 已经完成&#x27;</span>)<br>            <br></code></pre></td></tr></table></figure><h3 id="可等待对象-Future-对象"><a href="#可等待对象-Future-对象" class="headerlink" title="可等待对象 - Future 对象"></a>可等待对象 - Future 对象</h3><p><a href="https://docs.python.org/zh-cn/3/library/asyncio-future.html#asyncio.Future"><code>Future</code></a> 是一种特殊的 <code>低层级</code> 可等待对象，表示一个异步操作的 <code>最终结果</code>  </p><p>当一个 <code>Future 对象</code> 被等待，这意味着协程将保持等待直到该 <code>Future</code> 对象在其他地方操作完毕  </p><p>在 <code>asyncio</code> 中需要 <code>Future</code> 对象以便允许通过 <code>async/await</code> 使用基于回调的代码  </p><p>通常情况下 没有必要 在应用层级的代码中创建 <code>Future 对象</code>  </p><h2 id="运行-asyncio-程序"><a href="#运行-asyncio-程序" class="headerlink" title="运行 asyncio 程序"></a>运行 asyncio 程序</h2><p><code>asyncio.run(coro, *, debug=False)</code><br>执行 <code>coroutine</code> coro 并返回结果。</p><p>此函数会运行传入的协程，负责管理 <code>asyncio</code> 事件循环，终结异步生成器，并关闭线程池。</p><p>当有其他 <code>asyncio</code> 事件循环在同一线程中运行时，此函数不能被调用。</p><p>如果 <code>debug</code> 为 <code>True</code>，事件循环将以调试模式运行。</p><p>此函数总是会创建一个新的事件循环并在结束时关闭之。它应当被用作 <code>asyncio</code> 程序的主入口点，理想情况下应当只被调用一次。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">1</span>)<br>    print(<span class="hljs-string">&#x27;hello&#x27;</span>)<br><br>asyncio.run(main())<br></code></pre></td></tr></table></figure><h2 id="创建任务"><a href="#创建任务" class="headerlink" title="创建任务"></a>创建任务</h2><p><code>asyncio.create_task(coro, *, name=None)</code><br>将 <code>协程函数coro</code> 打包为一个 <code>Task</code> 排入日程准备执行，函数执行后，会返回一个 <code>Task</code> 对象  </p><p>如果 参数<code>name</code> 不为 <code>None</code>，它将使用 <code>Task.set_name()</code> 来设为任务的名称  </p><p>该任务会在 <code>get_running_loop()</code> 返回的循环中执行，如果当前线程没有在运行的循环则会引发 <code>RuntimeError</code>  </p><blockquote><p>此函数 在 <code>Python 3.7</code> 中被加入。在 <code>Python 3.7</code> 之前，可以改用低层级的 <code>asyncio.ensure_future()</code> 函数。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">coro</span>():</span><br>    ...<br><br><span class="hljs-comment"># In Python 3.7+</span><br>task = asyncio.create_task(coro())<br>...<br><br><span class="hljs-comment"># This works in all Python versions but is less readable</span><br>task = asyncio.ensure_future(coro())<br></code></pre></td></tr></table></figure><h2 id="休眠"><a href="#休眠" class="headerlink" title="休眠"></a>休眠</h2><p><code>coroutine asyncio.sleep(delay, result=None, *)</code><br>阻塞 <code>delay</code> 指定的秒数<br>如果指定了 <code>result</code>，则当协程完成时将其返回给调用者。<br><code>sleep()</code> 总是会挂起当前任务，以允许其他任务运行。  </p><blockquote><p>以下协程示例运行 5 秒，每秒显示一次当前日期:  </p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> asyncio<br><span class="hljs-keyword">import</span> datetime<br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">display_date</span>():</span><br>    loop = asyncio.get_running_loop()<br>    end_time = loop.time() + <span class="hljs-number">5.0</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        print(datetime.datetime.now())<br>        <span class="hljs-keyword">if</span> (loop.time() + <span class="hljs-number">1.0</span>) &gt;= end_time:<br>            <span class="hljs-keyword">break</span><br>        <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">1</span>)<br><br>asyncio.run(display_date())<br></code></pre></td></tr></table></figure><h2 id="并发运行"><a href="#并发运行" class="headerlink" title="并发运行"></a>并发运行</h2><p><code>awaitable asyncio.gather(*aws,  return_exceptions=False)</code><br>并发 运行<code>aws</code> 序列中的 可等待对象  </p><p>如果 <code>aws</code> 中的某个可等待对象为协程，它将自动作为一个<code>Task</code>加入日程  </p><p>如果所有可等待对象都成功完成，结果将是一个由所有返回值聚合而成的列表。结果值的顺序与 <code>aws</code> 中可等待对象的顺序一致  </p><ul><li>return_exceptions<ul><li>如果 <code>return_exceptions</code> 为 <code>False</code> (默认)，所引发的首个异常会立即传播给等待 <code>gather()</code> 的任务<br><code>aws</code> 序列中的其他可等待对象 不会被取消 并将继续运行  </li><li>如果 <code>return_exceptions</code> 为 <code>True</code>，异常会和成功的结果一样处理，并聚合至结果列表。</li></ul></li></ul><p>如果 <code>gather()</code> 被取消，所有被提交 (尚未完成) 的可等待对象也会 被取消。</p><p>如果 <code>aws</code> 序列中的任一 <code>Task</code> 或 <code>Future</code> 对象 被取消，它将被当作引发了 <code>CancelledError</code> 一样处理 – 在此情况下 <code>gather()</code> 调用 不会 被取消。这是为了防止一个已提交的 <code>Task/Future</code> 被取消导致其他 <code>Tasks/Future</code> 也被取消  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> asyncio<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">factorial</span>(<span class="hljs-params">name, number</span>):</span><br>    <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    计算阶乘</span><br><span class="hljs-string">    &#x27;&#x27;&#x27;</span><br>    f = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>, number + <span class="hljs-number">1</span>):<br>        print(<span class="hljs-string">f&quot;Task <span class="hljs-subst">&#123;name&#125;</span>: Compute factorial(<span class="hljs-subst">&#123;i&#125;</span>)...&quot;</span>)<br>        <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">1</span>)<br>        f *= i<br>    print(<span class="hljs-string">f&quot;Task <span class="hljs-subst">&#123;name&#125;</span>: <span class="hljs-subst">&#123;number&#125;</span>的阶乘 = <span class="hljs-subst">&#123;f&#125;</span>&quot;</span>)<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    <span class="hljs-comment"># Schedule three calls *concurrently*:</span><br>    <span class="hljs-keyword">await</span> asyncio.gather(<br>        factorial(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-number">2</span>),<br>        factorial(<span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-number">3</span>),<br>        factorial(<span class="hljs-string">&quot;C&quot;</span>, <span class="hljs-number">4</span>),<br>    )<br><br>asyncio.run(main())<br></code></pre></td></tr></table></figure><h2 id="屏蔽取消操作"><a href="#屏蔽取消操作" class="headerlink" title="屏蔽取消操作"></a>屏蔽取消操作</h2><p><code>awaitable asyncio.shield(aw, *, loop=None)</code><br>保护一个 <code>可等待对象</code> 防止其被 <code>取消</code><br>如果 <code>aw</code> 是一个协程，它将自动作为任务加入日程  </p><p>以下语句:<br><code>res = await shield(something())</code><br>相当于:<br><code>res = await something()</code><br>不同之处 在于如果包含它的协程被取消，在 something() 中运行的任务不会被取消<br>从<code>something()</code> 的角度看来，取消操作并没有发生。然而其调用者已被取消，因此 “await” 表达式仍然会引发 <code>CancelledError</code>  </p><p>如果通过其他方式取消 <code>something()</code> (例如在其内部操作) 则 <code>shield()</code> 也会取消。</p><p>如果希望完全忽略取消操作 (不推荐) 则 <code>shield()</code> 函数需要配合一个 <code>try/except</code> 代码段  </p><h2 id="超时"><a href="#超时" class="headerlink" title="超时"></a>超时</h2><p><code>coroutine asyncio.wait_for(aw, timeout, *, loop=None)</code><br>等待 <code>aw</code> 可等待对象 完成，指定 <code>timeout</code> 秒数后超时  <a id="asyncio_wait_for"></a><br>如果 <code>aw</code> 是一个协程，它将自动作为任务加入日程<br><code>timeout</code> 可以为 <code>None</code>，也可以为 <code>float</code> 或 <code>int</code> 型数值表示的等待秒数。如果 <code>timeout</code> 为 <code>None</code>，则等待直到完成<br>如果发生超时，任务将取消并引发 <code>asyncio</code>.<code>TimeoutError</code><br>要避免任务 取消，可以加上 <code>shield()</code>  </p><p>此函数将等待直到 <code>Future</code> 确实被取消，所以总等待时间可能超过 <code>timeout</code>。 如果在取消期间发生了异常，异常将会被传播  </p><p>如果等待被取消，则 <code>aw</code> 指定的对象也会被取消  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">eternity</span>():</span><br>    <span class="hljs-comment"># Sleep for one hour</span><br>    <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">3600</span>)<br>    print(<span class="hljs-string">&#x27;yay!&#x27;</span>)<br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    <span class="hljs-comment"># Wait for at most 1 second</span><br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-keyword">await</span> asyncio.wait_for(eternity(), timeout=<span class="hljs-number">1.0</span>)<br>    <span class="hljs-keyword">except</span> asyncio.TimeoutError:<br>        print(<span class="hljs-string">&#x27;timeout!&#x27;</span>)<br><br>asyncio.run(main())<br></code></pre></td></tr></table></figure><h2 id="简单等待"><a href="#简单等待" class="headerlink" title="简单等待"></a>简单等待</h2><h3 id="wait"><a href="#wait" class="headerlink" title="wait"></a>wait</h3><p><code>coroutine asyncio.wait(aws, *, loop=None, timeout=None, return_when=ALL_COMPLETED)</code><br>运行 <code>aws</code> 的可等待对象。阻塞直到触发<code>return_when</code>设置的条件<br>返回两个 <code>Task/Future</code> 集合: (done, pending)  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">done, pending = <span class="hljs-keyword">await</span> asyncio.wait(aws)<br></code></pre></td></tr></table></figure><p>如指定 <code>timeout (float 或 int 类型)</code> 则它将被用于控制返回之前等待的最长秒数  </p><p>请注意此函数不会引发 <code>asyncio.TimeoutError</code><br>当超时发生时，未完成的 <code>Future</code> 或 <code>Task</code> 将在指定秒数后被返回  </p><p><code>return_when</code> 指定此函数应在何时返回。它必须为以下常数之一  </p><table><thead><tr><th>常数</th><th>描述</th></tr></thead><tbody><tr><td>FIRST_COMPLETED</td><td>函数将在任意可等待对象结束或取消时返回</td></tr><tr><td>FIRST_EXCEPTION</td><td>函数将在任意可等待对象因引发异常而结束时返回。当没有引发任何异常时它就相当于 <code>ALL_COMPLETED</code></td></tr><tr><td>ALL_COMPLETED</td><td>函数将在所有可等待对象结束或取消时返回</td></tr></tbody></table><p>与 <code>wait_for()</code> 不同，<code>wait()</code> 在超时发生时不会取消可等待对象  </p><h3 id="as-completed"><a href="#as-completed" class="headerlink" title="as_completed"></a>as_completed</h3><p><code>asyncio.as_completed(aws, *, loop=None, timeout=None)</code><br>运行 <code>aws</code> 的可等待对象。返回可迭代的协程<br>如果在所有 <code>Future</code> 对象完成前发生超时则将引发 <code>asyncio.TimeoutError</code>  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> asyncio<br><span class="hljs-keyword">from</span> random <span class="hljs-keyword">import</span> randint<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span>():</span><br>    <span class="hljs-keyword">return</span> randint(<span class="hljs-number">1</span>,<span class="hljs-number">100</span>)<br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    the_futures = []<br>    the_futures.append(asyncio.ensure_future(foo()))<br>    the_futures.append(asyncio.ensure_future(foo()))<br>    the_futures.append(asyncio.ensure_future(foo()))<br>    the_futures.append(asyncio.ensure_future(foo()))<br>    <br>    <span class="hljs-keyword">for</span> coro <span class="hljs-keyword">in</span> asyncio.as_completed(the_futures):<br>        earliest_result = <span class="hljs-keyword">await</span> coro<br>        print(earliest_result)<br>asyncio.run(main())<br></code></pre></td></tr></table></figure><h1 id="同步原语"><a href="#同步原语" class="headerlink" title="同步原语"></a>同步原语</h1><p>章节官方文档: <a href="https://docs.python.org/zh-cn/3/library/asyncio-sync.html">https://docs.python.org/zh-cn/3/library/asyncio-sync.html</a>  </p><blockquote><p>原语<br>所谓原语，一般是指由若干条指令组成的程序段，用来实现某个特定功能，在执行过程中不可被中断<br>在操作系统中，某些被进程调用的操作，如队列操作、对信号量的操作、检查启动外设操作等，一旦开始执行，就不能被中断，否则就会出现操作错误，造成系统混乱  </p></blockquote><p><code>asyncio</code> 同步原语被设计为与 <code>threading</code> 模块的类似，但有两个关键注意事项:</p><ul><li><strong><code>asyncio</code> 原语不是线程安全的</strong>，因此它们不应被用于 <code>OS</code> 线程同步 (而应当使用 <code>threading</code>)；</li><li>这些同步原语的方法不接受 <code>timeout</code> 参数；请使用 <a href="#asyncio_wait_for"><code>asyncio.wait_for()</code></a> 函数来执行带有超时的操作  </li></ul><h2 id="Lock-锁"><a href="#Lock-锁" class="headerlink" title="Lock 锁"></a>Lock 锁</h2><p><code>class asyncio.Lock(*)</code><br>实现一个用于 <code>asyncio</code> 任务的互斥锁。 非线程安全<br><code>asyncio</code> 锁可被用来保证对共享资源的独占访问<br>推荐<a href="#ExampleAsyncWithRunLock">通过 <code>async with</code> 语句来使用 <code>Lock</code></a><a id="AsyncWithRunLock"></a>  </p><table><thead><tr><th>方法</th><th>信息</th><th>特殊</th></tr></thead><tbody><tr><td>coroutine acquire()</td><td>获取锁<br>此方法会等待直至锁为 <code>unlocked</code>，将其设为 <code>locked</code> 并返回 <code>True</code><br>当有一个以上的协程在 <code>acquire()</code> 中被阻塞则会等待解锁，最终只有一个协程会被执行</td><td><strong>公平的</strong>的获取: <br>等待的协程服从先等先服务原则</td></tr><tr><td>release()</td><td>释放锁<br>当锁为 <code>locked</code> 时，将其设为 <code>unlocked</code> 并返回</td><td>如果锁为 <code>unlocked</code>，则会引发 <code>RuntimeError</code></td></tr><tr><td>locked()</td><td>如果锁为 <code>locked</code> 则返回 <code>True</code></td><td></td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> asyncio<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">using_toilet</span>(<span class="hljs-params">toilet_lock, name:<span class="hljs-built_in">str</span></span>):</span><br>    print(<span class="hljs-string">&#x27;&#123;&#125; 尝试获取厕所使用权&#x27;</span>.<span class="hljs-built_in">format</span>(name))<br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> toilet_lock:<br>        print(<span class="hljs-string">&#x27;&#123;&#125; 正在使用厕所&#x27;</span>.<span class="hljs-built_in">format</span>(name))<br>        <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">4</span>)<br>    print(<span class="hljs-string">&#x27;&#123;&#125; 厕所使用完毕&#x27;</span>.<span class="hljs-built_in">format</span>(name))<br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">using_toilet_without_lock</span>(<span class="hljs-params">name:<span class="hljs-built_in">str</span></span>):</span><br>    print(<span class="hljs-string">&#x27;&#123;&#125; 尝试获取厕所使用权&#x27;</span>.<span class="hljs-built_in">format</span>(name))<br>    print(<span class="hljs-string">&#x27;&#123;&#125; 正在使用厕所&#x27;</span>.<span class="hljs-built_in">format</span>(name))<br>    <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">4</span>)<br>    print(<span class="hljs-string">&#x27;&#123;&#125; 厕所使用完毕&#x27;</span>.<span class="hljs-built_in">format</span>(name))<br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    print(<span class="hljs-string">&#x27;\n并行无锁&#x27;</span>)<br>    futures = asyncio.wait([<br>        using_toilet_without_lock(name)<br>        <span class="hljs-keyword">for</span> name <span class="hljs-keyword">in</span> [<span class="hljs-string">&#x27;DIO&#x27;</span>, <span class="hljs-string">&#x27;JOJO&#x27;</span>, <span class="hljs-string">&#x27;XISA&#x27;</span>]<br>    ])<br>    <span class="hljs-keyword">await</span> asyncio.ensure_future(futures)<br><br>    print(<span class="hljs-string">&#x27;\n并行有锁&#x27;</span>)<br>    toilet_lock = asyncio.Lock()<br>    futures = asyncio.wait([<br>        using_toilet(toilet_lock, name)<br>        <span class="hljs-keyword">for</span> name <span class="hljs-keyword">in</span> [<span class="hljs-string">&#x27;DIO&#x27;</span>, <span class="hljs-string">&#x27;JOJO&#x27;</span>, <span class="hljs-string">&#x27;XISA&#x27;</span>]<br>    ])<br>    <span class="hljs-keyword">await</span> asyncio.ensure_future(futures)<br><br><br>asyncio.run(main())<br></code></pre></td></tr></table></figure><h2 id="Event-事件"><a href="#Event-事件" class="headerlink" title="Event 事件"></a>Event 事件</h2><p><code>class asyncio.Event(*)</code><br>事件对象。 该对象不是线程安全的。</p><p><code>asyncio</code> 事件可被用来通知多个 <code>asyncio</code> 任务已经有事件发生。</p><p><code>Event</code> 对象会管理一个内部旗标，该旗标初始时将被设为 <code>false</code>  </p><ul><li><code>set()</code> 方法将其设为 <code>true</code>  </li><li><code>clear()</code> 方法将其设为 <code>false</code>  </li><li><code>wait()</code> 方法会阻塞直至该旗标被设为 <code>true</code>  </li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> asyncio<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">waiter</span>(<span class="hljs-params">event</span>):</span><br>    print(<span class="hljs-string">&#x27;意大利炮已上膛，等待发射命令中......&#x27;</span>)<br>    <span class="hljs-keyword">await</span> event.wait()<br>    print(<span class="hljs-string">&#x27;开炮！！！开炮！！！开炮！！！&#x27;</span>)<br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    event = asyncio.Event()  <span class="hljs-comment"># 创建一个Event对象</span><br>    <span class="hljs-comment"># create_task 生成一个 Task，这个 Task 立即执行</span><br>    <span class="hljs-comment"># 然后碰到event.wait()会一直等待，直到 Event 被 set</span><br>    waiter_task = asyncio.create_task(waiter(event))<br><br>    <span class="hljs-comment"># 等待3秒后，set Event</span><br>    <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">3</span>)<br>    event.<span class="hljs-built_in">set</span>()<br><br>    <span class="hljs-comment"># 虽然说在Event set了以后，Task会运行进行直到运行完毕  </span><br>    <span class="hljs-comment"># 但加个等待以确保100% 完成是个好习惯</span><br>    <span class="hljs-keyword">await</span> waiter_task<br><br>asyncio.run(main())<br></code></pre></td></tr></table></figure><h2 id="Condition-条件"><a href="#Condition-条件" class="headerlink" title="Condition 条件"></a>Condition 条件</h2><p><code>asyncio</code> 条件原语可被任务用于等待某个事件发生，然后获取对共享资源的独占访问  </p><p>在本质上，<code>Condition</code> 对象合并了 <code>Event</code> 和 <code>Lock</code> 的功能<br>多个 <code>Condition</code> 对象有可能共享一个 <code>Lock</code>，这允许关注于共享资源的特定状态的不同任务实现对共享资源的协同独占访问  </p><p>可选的 <code>lock</code> 参数必须为 <code>Lock</code> 对象或 <code>None</code>。 在后一种情况下会自动创建一个新的 <code>Lock</code> 对象。</p><p>推荐<a href="#ExampleAsyncWithRunCondition">通过 <code>async with</code> 语句来使用 <code>Condition</code></a><a id="AsyncWithRunCondition"></a>  </p><p>|方法|信息|特殊|<br>|–|–|<br>|coroutine acquire()|获取下层的锁<br>此方法会等待直至下层的锁为 <code>unlocked</code>，将其设为 <code>locked</code> 并返回 <code>True</code>|<br>|notify(n=1)|唤醒最多 <code>n</code> 个正在等待此条件的任务（默认为 1 个）<br>如果没有任务正在等待则此方法为空操作。<br>锁必须在此方法被调用前被获取并在随后被快速释放<br>|如果通过一个 <code>unlocked</code> 锁调用则会引发 <code>RuntimeError</code>|<br>|locked()|如果下层的锁已被获取则返回 <code>True</code>||<br>|notify_all()|唤醒所有正在等待此条件的任务。此方法的行为类似于 <code>notify()</code>，但会唤醒所有正在等待的任务。锁必须在此方法被调用前被获取并在随后被快速释放| 如果通过一个 <code>unlocked</code> 锁调用则会引发 <code>RuntimeError</code>|<br>|release()|释放下层的锁|当在未锁定的锁上发起调用时，会引发 <code>RuntimeError</code>|<br>|coroutine wait()|等待直至收到通知<br>这个方法会释放下层的锁，然后保持阻塞直到被 <code>notify()</code> 或 <code>notify_all()</code> 调用所唤醒。 <br>一旦被唤醒，<code>Condition</code> 会重新获取它的锁并且此方法将返回 <code>True</code>|当此方法被调用时如果调用方任务未获得锁，则会引发 <code>RuntimeError</code>|<br>|coroutine wait_for(predicate)|等待直到目标值变为 <code>true</code><br>目标必须为一个可调用对象，其结果将被解读为一个布尔值。 最终的值将为返回值。|</p><h2 id="Semaphore-信号量"><a href="#Semaphore-信号量" class="headerlink" title="Semaphore 信号量"></a>Semaphore 信号量</h2><p>信号量会管理一个内部计数器，该计数器会随每次 <code>acquire()</code> 调用递减并随每次 <code>release()</code> 调用递增。计数器的值永远不会降到零以下<br>当 <code>acquire()</code> 发现其值为零时，它将保持阻塞直到有某个任务调用了 <code>release()</code>  </p><p>可选的 <code>value</code> 参数用来为内部计数器赋初始值 (默认值为 1)。 如果给定的值小于 <code>0</code> 则会引发 <code>ValueError</code>  </p><table><thead><tr><th>方法</th><th>信息</th></tr></thead><tbody><tr><td>coroutine acquire()</td><td>获取一个信号量。<br>如果内部计数器的值大于零，则将其减一并立即返回 <code>True</code><br> 如果其值为零，则会等待直到 <code>release()</code> 并调用并返回 <code>True</code></td></tr><tr><td>locked()</td><td>如果信号量对象无法被立即获取则返回 <code>True</code></td></tr><tr><td>release()</td><td>释放一个信号量对象，将内部计数器的值加1<br>可以唤醒一个正在等待获取信号量对象的任务。<br>不同于 <code>BoundedSemaphore</code>，<code>Semaphore</code> 允许执行的 <code>release()</code> 调用多于 <code>acquire()</code> 调用</td></tr></tbody></table><h2 id="BoundedSemaphore"><a href="#BoundedSemaphore" class="headerlink" title="BoundedSemaphore"></a>BoundedSemaphore</h2><p><code>class asyncio.BoundedSemaphore(value=1, *)</code><br>绑定的信号量对象<br><code>BoundedSemaphore</code> 是特殊版本的 <code>Semaphore</code>，如果在 <code>release()</code> 中内部计数器值增加到初始 <code>value</code> 以上它将引发一个 <code>ValueError</code>  </p><h1 id="未完成"><a href="#未完成" class="headerlink" title="未完成"></a>未完成</h1><p>位置：<a href="https://docs.python.org/zh-cn/3/library/asyncio-subprocess.html">https://docs.python.org/zh-cn/3/library/asyncio-subprocess.html</a>  </p><hr><h1 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h1><h2 id="串行等待运行"><a href="#串行等待运行" class="headerlink" title="串行等待运行"></a>串行等待运行</h2><p><a id="ExampleJustAwait"></a></p><blockquote><p>以下代码段会在等待 1 秒后打印 “hello”，然后 再次 等待 2 秒后打印 “world  </p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> asyncio<br><span class="hljs-keyword">import</span> time<br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">say_after</span>(<span class="hljs-params">delay, what</span>):</span><br>    <span class="hljs-keyword">await</span> asyncio.sleep(delay)<br>    print(what)<br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    print(<span class="hljs-string">f&quot;started at <span class="hljs-subst">&#123;time.strftime(<span class="hljs-string">&#x27;%X&#x27;</span>)&#125;</span>&quot;</span>)<br>    <span class="hljs-comment"># 直接运行并等待执行完毕（简单来说就是串行执行的协程）</span><br>    <span class="hljs-keyword">await</span> say_after(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;hello&#x27;</span>)<br>    <span class="hljs-keyword">await</span> say_after(<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;world&#x27;</span>)<br>    print(<span class="hljs-string">f&quot;finished at <span class="hljs-subst">&#123;time.strftime(<span class="hljs-string">&#x27;%X&#x27;</span>)&#125;</span>&quot;</span>)<br><br>asyncio.run(main())<br></code></pre></td></tr></table></figure><pre><code>&gt;预期的输出:  </code></pre><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">started</span> at <span class="hljs-number">17</span>:<span class="hljs-number">13</span>:<span class="hljs-number">52</span><br><span class="hljs-attribute">hello</span><br><span class="hljs-attribute">world</span><br><span class="hljs-attribute">finished</span> at <span class="hljs-number">17</span>:<span class="hljs-number">13</span>:<span class="hljs-number">55</span><br></code></pre></td></tr></table></figure><center>[Back](#BackExampleJustAwait)</center><h2 id="asyncio-create-task-基础并行运行"><a href="#asyncio-create-task-基础并行运行" class="headerlink" title="asyncio.create_task 基础并行运行"></a>asyncio.create_task 基础并行运行</h2><p><a id="ExampleCreateTaskMostBasing"></a></p><blockquote><p>等待到两个协程都执行完毕，因为是并行的，预计会用两秒钟  </p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> asyncio<br><span class="hljs-keyword">import</span> time<br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">say_after</span>(<span class="hljs-params">delay, what</span>):</span><br>    <span class="hljs-keyword">await</span> asyncio.sleep(delay)<br>    print(what)<br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    task1 = asyncio.create_task(say_after(<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;world&#x27;</span>))<br>    task2 = asyncio.create_task(say_after(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;hello&#x27;</span>))<br>    print(<span class="hljs-string">f&quot;started at <span class="hljs-subst">&#123;time.strftime(<span class="hljs-string">&#x27;%X&#x27;</span>)&#125;</span>&quot;</span>)<br><br>    <span class="hljs-comment"># 等待到两个协程都执行完毕，因为是并行的，预计会用两秒钟</span><br>    <span class="hljs-keyword">await</span> task1<br>    <span class="hljs-keyword">await</span> task2<br>    print(<span class="hljs-string">f&quot;finished at <span class="hljs-subst">&#123;time.strftime(<span class="hljs-string">&#x27;%X&#x27;</span>)&#125;</span>&quot;</span>)<br><br>asyncio.run(main())<br></code></pre></td></tr></table></figure><center>[Back](#BackExampleCreateTaskMostBasing)</center><h2 id="async-with-运行Lock"><a href="#async-with-运行Lock" class="headerlink" title="async with 运行Lock"></a><code>async with</code> 运行<code>Lock</code></h2><p><a id="ExampleAsyncWithRunLock"></a>通过<code>async with</code>来运行<code>Lock</code>能够能够让代码更加美观  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">lock = asyncio.Lock()<br><br><span class="hljs-comment"># ... later</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> lock:<br>    <span class="hljs-comment"># access shared state</span><br></code></pre></td></tr></table></figure><p>这等价于:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">lock = asyncio.Lock()<br><br><span class="hljs-comment"># ... later</span><br><span class="hljs-keyword">await</span> lock.acquire()<br><span class="hljs-keyword">try</span>:<br>    <span class="hljs-comment"># access shared state</span><br><span class="hljs-keyword">finally</span>:<br>    lock.release()<br><br>lock = asyncio.Lock()<br></code></pre></td></tr></table></figure><center>[Back](#AsyncWithRunLock)</center><h2 id="async-with-运行Condition"><a href="#async-with-运行Condition" class="headerlink" title="async with 运行Condition"></a><code>async with</code> 运行<code>Condition</code></h2><p><a id="ExampleAsyncWithRunCondition"></a>通过<code>async with</code>来运行<code>Lock</code>能够能够让代码更加美观  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">cond = asyncio.Condition()<br><br><span class="hljs-comment"># ... later</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> cond:<br>    <span class="hljs-keyword">await</span> cond.wait()<br></code></pre></td></tr></table></figure><p>这等价于:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">cond = asyncio.Condition()<br><br><span class="hljs-comment"># ... later</span><br><span class="hljs-keyword">await</span> cond.acquire()<br><span class="hljs-keyword">try</span>:<br>    <span class="hljs-keyword">await</span> cond.wait()<br><span class="hljs-keyword">finally</span>:<br>    cond.release()<br></code></pre></td></tr></table></figure><center>[Back](#AsyncWithRunCondition)</center>]]></content>
    
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>协程</tag>
      
      <tag>asyncio</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Scrapy-DownloaderMiddleware-下载中间件</title>
    <link href="/post/7e3517c0/"/>
    <url>/post/7e3517c0/</url>
    
    <content type="html"><![CDATA[<h1 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h1><p>下载器中间件是介于<code>Scrapy</code>的<code>request</code>/<code>response</code>处理的钩子框架<br>是用于全局修改<code>request</code>和<code>rsponse</code>的一个轻量、底层的系统  </p><h1 id="激活下载器中间件"><a href="#激活下载器中间件" class="headerlink" title="激活下载器中间件"></a>激活下载器中间件</h1><p>要激活下载器中间件组件，将其加入到setting.py的 <code>DOWNLOADER_MIDDLEWARES</code>设置中<br>这个设置是一个<code>dict</code>，键为中间件类的路径，值为其中间件的处理顺序  </p><h1 id="编写下载器中间件"><a href="#编写下载器中间件" class="headerlink" title="编写下载器中间件"></a>编写下载器中间件</h1><p>编写下载器中间件十分简单<br>每个中间件组件是一个定义了以下一个或多个方法的<code>Python类</code>  </p><h2 id="process-request-request-spider"><a href="#process-request-request-spider" class="headerlink" title="process_request(request, spider)"></a>process_request(request, spider)</h2><p>当每个<code>request</code>通过下载中间件时，该方法被调用  </p><p>此函数必须返回/抛出其中之一: </p><ul><li>返回 None  </li><li>返回一个 Response </li><li>返回一个 Request </li><li>抛出 IgnoreRequest</li></ul><h3 id="返回-None"><a href="#返回-None" class="headerlink" title="返回 None"></a>返回 None</h3><p><code>Scrapy</code>将继续处理该<code>request</code>，执行其他的中间件的相应方法，直到合适的下载器处理函数(download handler)被调用， 该<code>request</code>被执行(其response被下载)  </p><h3 id="返回一个-Response"><a href="#返回一个-Response" class="headerlink" title="返回一个 Response"></a>返回一个 Response</h3><p>这个<code>Response</code>将作为最终的<code>Response</code>返回。不会再将它传给其他的中间件的<code>process_request()</code><br>这个<code>Response</code>，会像普通的<code>Response</code>一样。传给每一个中间件的<code>process_response()</code>方法进行处理  </p><h3 id="返回一个-Request"><a href="#返回一个-Request" class="headerlink" title="返回一个 Request"></a>返回一个 Request</h3><p><code>Scrapy</code>停止调用 <code>process_request</code>方法并重新调度返回的<code>request</code>。当新返回的<code>request</code>被执行后， 相应地中间件链将会根据下载的<code>response</code>被调用  </p><h3 id="抛出-IgnoreRequest"><a href="#抛出-IgnoreRequest" class="headerlink" title="抛出 IgnoreRequest"></a>抛出 IgnoreRequest</h3><p>中间件的<code>process_exception()</code>方法会被调用<br>如果没有任何一个方法处理该异常， 则<code>request</code>的<code>errback(Request.errback)</code>方法会被调用<br>如果没有代码处理抛出的异常， 则该异常被忽略且不记录  </p><h2 id="process-response-request-response-spider"><a href="#process-response-request-response-spider" class="headerlink" title="process_response(request, response, spider)"></a>process_response(request, response, spider)</h2><p>此函数必须返回以下之一:   </p><ul><li>返回一个<code>Response</code>对象  </li><li>返回一个 Request 对象  </li><li>抛 IgnoreRequest 异常  </li></ul><h3 id="返回一个-Response-1"><a href="#返回一个-Response-1" class="headerlink" title="返回一个 Response"></a>返回一个 Response</h3><p>(可以与传入的response相同，也可以是全新的对象)<br>该<code>response</code>会被在链中的其他中间件的 <code>process_response()</code>方法处理，直到所有中间件处理完就返回  </p><h3 id="返回一个-Request-对象"><a href="#返回一个-Request-对象" class="headerlink" title="返回一个 Request 对象"></a>返回一个 Request 对象</h3><p>中间件链停止，返回的request会被重新调度下载  </p><h3 id="抛出一个-IgnoreRequest-异常"><a href="#抛出一个-IgnoreRequest-异常" class="headerlink" title="抛出一个 IgnoreRequest 异常"></a>抛出一个 IgnoreRequest 异常</h3><p>调用<code>request</code>的<code>errback(Request.errback)</code><br>如果没有代码处理抛出的异常，则该异常被忽略且不记录(不同于其他异常那样)   </p><h2 id="process-exception-request-exception-spider"><a href="#process-exception-request-exception-spider" class="headerlink" title="process_exception(request, exception, spider)"></a>process_exception(request, exception, spider)</h2><p>当下载处理器或下载中间件抛出异常(包括<code>IgnoreRequest</code>异常)时，会调用<code>process_exception()</code>  </p><p><code>process_exception()</code> 应该返回以下之一:  </p><ul><li>返回 None  </li><li>一个 Response 对象  </li><li>一个 Request 对象  </li></ul><h3 id="返回-None-1"><a href="#返回-None-1" class="headerlink" title="返回 None"></a>返回 None</h3><p><code>Scrapy</code>将会继续处理该异常，接着调用已安装的其他中间件的 <code>process_exception()</code>方法，直到所有中间件都被调用完毕，则调用默认的异常处理。</p><h3 id="返回一个-Response-对象"><a href="#返回一个-Response-对象" class="headerlink" title="返回一个 Response 对象"></a>返回一个 Response 对象</h3><p>已安装的中间件链的<code>process_response()</code>方法被调用。<code>Scrapy</code>将不会调用任何其他中间件的<code>process_exception()</code> 方法。</p><h3 id="返回一个-Request-对象-1"><a href="#返回一个-Request-对象-1" class="headerlink" title="返回一个 Request 对象"></a>返回一个 Request 对象</h3><p>返回的<code>request</code>将会被重新调用下载。这将停止中间件的 <code>process_exception()</code>方法执行，就如返回一个<code>response</code>的那样  </p><h1 id="官方下载中间件"><a href="#官方下载中间件" class="headerlink" title="官方下载中间件"></a>官方下载中间件</h1><p>Github地址：<a href="https://github.com/scrapy/scrapy/tree/master/scrapy/downloadermiddlewares">https://github.com/scrapy/scrapy/tree/master/scrapy/downloadermiddlewares</a><br>你能够在这里查看到官方给出的一些下载中间件<br>中间件包括失败重试，代理等一些实用的功能  </p>]]></content>
    
    
    
    <tags>
      
      <tag>Scrapy</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>VSCode-用户代码片段</title>
    <link href="/post/ad65409c/"/>
    <url>/post/ad65409c/</url>
    
    <content type="html"><![CDATA[<h1 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h1><p>在编写代码的过程中使用用户代码片段能使得代码编写速度更快<br><img src="https://i.loli.net/2020/11/05/bS1ApLRPkV8o76e.gif" alt="ajax-snippet.gif"><br>VSCode文档-用户代码片段：<a href="https://code.visualstudio.com/docs/editor/userdefinedsnippets">https://code.visualstudio.com/docs/editor/userdefinedsnippets</a>  </p><h1 id="创建用户代码片段"><a href="#创建用户代码片段" class="headerlink" title="创建用户代码片段"></a>创建用户代码片段</h1><h2 id="创建代码片段文件"><a href="#创建代码片段文件" class="headerlink" title="创建代码片段文件"></a>创建代码片段文件</h2><p>文件-&gt;首选项-&gt;用户片段<br><img src="/VSCode-%E7%94%A8%E6%88%B7%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5/open_user_snippets.gif"><br>点击以后会出现一些选项，可以打开以前的代码片段文件进行修改，或者新建一个代码片段文件  </p><h2 id="代码片段文件"><a href="#代码片段文件" class="headerlink" title="代码片段文件"></a>代码片段文件</h2><p>代码片段的编写语法就和<code>JSON</code>一样<br>支持编写C语言类型的注释（也就是”//“注释）<br>一个代码片段文件可以编写任意个代码片段  </p><h2 id="编写代码片段"><a href="#编写代码片段" class="headerlink" title="编写代码片段"></a>编写代码片段</h2><p>在代码片段文件中写入用户代码片段<br>此处我以Python头举例  </p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br><span class="hljs-attr">&quot;Python-Commom&quot;</span>: &#123;<br><span class="hljs-attr">&quot;scope&quot;</span>: <span class="hljs-string">&quot;python&quot;</span>,<br><span class="hljs-attr">&quot;description&quot;</span>: <span class="hljs-string">&quot;Python声明头部，包含编码，解释器指定，文件信息&quot;</span>,<br><span class="hljs-attr">&quot;prefix&quot;</span>: [<span class="hljs-string">&quot;header&quot;</span>],<br><span class="hljs-attr">&quot;body&quot;</span>: [<br><span class="hljs-string">&quot;#!/usr/bin/env python&quot;</span>,<br><span class="hljs-string">&quot;# -*- encoding: utf-8 -*-&quot;</span>,<br><span class="hljs-string">&quot;&#x27;&#x27;&#x27;&quot;</span>,<br><span class="hljs-string">&quot;@File    :   $TM_FILENAME&quot;</span>,<br><span class="hljs-string">&quot;@Time    :   $CURRENT_YEAR-$CURRENT_MONTH-$CURRENT_DATE&quot;</span>,<br><span class="hljs-string">&quot;@Contact :   https://github.com/RecluseXU&quot;</span>,<br><span class="hljs-string">&quot;@Desc    :   $1&quot;</span>,<br><span class="hljs-string">&quot;&#x27;&#x27;&#x27;&quot;</span>,<br><span class="hljs-string">&quot;&quot;</span>,<br><span class="hljs-string">&quot;# here put the import lib&quot;</span>,<br><span class="hljs-string">&quot;$0&quot;</span>,<br>],<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><table><thead><tr><th>内容</th><th>值</th><th>说明</th></tr></thead><tbody><tr><td>代码片段名</td><td>“Python-Commom”</td><td>仅仅是一个名字</td></tr><tr><td>“scope”</td><td>“python”</td><td>代码段使用的语言名称列表<br>例如 “python,c”</td></tr><tr><td>“description”</td><td>“Python声明……定，文件信息”</td><td>代码片段的描述，在使用时能够看到它，方便理解代码片段作用</td></tr><tr><td>“prefix”</td><td>[“header”]</td><td>匹配关键词，可以填入多个<br>在你编写代码时填入部分匹配关键词时，会提示出用户代码片段</td></tr><tr><td>“body”</td><td>[“#!/usr/bin/env py……put the import lib”,”$0”,]</td><td>代码片段内容，插入到原本代码中的代码片段<br>以list的形式记录，一个元素为一行内容<br>可以使用一些已经定义好了的变量来填充内容。例如：<br><code>$1</code>代表每一次按<code>Tab</code>后光标跳跃到的位置<br><code>$0</code>表示光标最终位置<br><code>$TM_FILENAME</code>代表当前文件名</td></tr></tbody></table><h2 id="测试使用"><a href="#测试使用" class="headerlink" title="测试使用"></a>测试使用</h2><p><img src="/VSCode-%E7%94%A8%E6%88%B7%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5/use_user_snippets.gif"></p><h1 id="代码片段语法"><a href="#代码片段语法" class="headerlink" title="代码片段语法"></a>代码片段语法</h1><h2 id="制表符-Tabstops"><a href="#制表符-Tabstops" class="headerlink" title="制表符 Tabstops"></a>制表符 Tabstops</h2><p><code>$0</code>, <code>$1</code>, <code>$2</code>……<br>使用制表符能够在代码片段中用<code>Tab</code>键快速移动  </p><p><img src="/VSCode-%E7%94%A8%E6%88%B7%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5/tabstops.gif">  </p><ul><li>在数字大于0时，按照从小到大移动，既 <code>$1</code>-<code>Tab</code>-&gt;<code>$2</code>-<code>Tab</code>-&gt;<code>$3</code></li><li>最终，光标会<code>Tab</code>到<code>$0</code>的位置，既最后的位置  </li><li>如果设置多个一样的制表符（比如在多个位置输入<code>$1</code>）,那么会同时在多个地方输入  </li></ul><h2 id="占位符-Placeholders"><a href="#占位符-Placeholders" class="headerlink" title="占位符 Placeholders"></a>占位符 Placeholders</h2><p><code>$&#123;1:foo&#125;</code>，<code>$&#123;2:what&#125;</code>……<br>存在默认值的制表符。如果你什么都不输入，直接<code>Tab</code>会使用占位符的值设置这个位置<br><img src="/VSCode-%E7%94%A8%E6%88%B7%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5/placeholder.gif">  </p><h2 id="选项-Choice"><a href="#选项-Choice" class="headerlink" title="选项 Choice"></a>选项 Choice</h2><p><code>$&#123;1|one,two,three|&#125;</code>, <code>$&#123;2|op1,op2|&#125;</code>……<br>存在默认值的制表符。你可以选择，设定的值来填入<br><img src="/VSCode-%E7%94%A8%E6%88%B7%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5/choice.gif">  </p><h2 id="变量-Variables"><a href="#变量-Variables" class="headerlink" title="变量 Variables"></a>变量 Variables</h2><h3 id="编辑相关"><a href="#编辑相关" class="headerlink" title="编辑相关"></a>编辑相关</h3><table><thead><tr><th>变量</th><th>信息</th></tr></thead><tbody><tr><td>TM_SELECTED_TEXT</td><td>当前选择的字符（没有则为空）</td></tr><tr><td>TM_CURRENT_LINE</td><td>当前行的内容</td></tr><tr><td>TM_CURRENT_WORD</td><td>当前光标下的单词（没有则为空）</td></tr><tr><td>TM_LINE_INDEX</td><td>从0开始的行序号</td></tr><tr><td>TM_LINE_NUMBER</td><td>从1开始的行号</td></tr><tr><td>TM_FILENAME</td><td>当前文档的文件名</td></tr><tr><td>TM_FILENAME_BASE</td><td>当前文档的文件名，不带扩展名</td></tr><tr><td>TM_DIRECTORY</td><td>当前文档的相对路径</td></tr><tr><td>TM_FILEPATH</td><td>当前文档的绝对路径</td></tr><tr><td>CLIPBOARD</td><td>剪贴板中的内容</td></tr><tr><td>WORKSPACE_NAME</td><td>工作路径名称</td></tr></tbody></table><h3 id="时间相关"><a href="#时间相关" class="headerlink" title="时间相关"></a>时间相关</h3><table><thead><tr><th>变量</th><th>信息</th></tr></thead><tbody><tr><td>CURRENT_YEAR</td><td>当前年份</td></tr><tr><td>CURRENT_YEAR_SHORT</td><td>当前年份（只包含后两位）</td></tr><tr><td>CURRENT_MONTH</td><td>当前月份，用两个数字表示<br>例如：02</td></tr><tr><td>CURRENT_MONTH_NAME</td><td>当前月份的完整英文名<br>例如：July</td></tr><tr><td>CURRENT_MONTH_NAME_SHORT</td><td>当前月份的简写英文名<br>例如：Jul</td></tr><tr><td>CURRENT_DATE</td><td>日期，这个月的第几天</td></tr><tr><td>CURRENT_DAY_NAME</td><td>当前日期星期数完整英文<br>例如：Monday)</td></tr><tr><td>CURRENT_DAY_NAME_SHORT</td><td>当前日期星期数简写英文<br>例如：Mon)</td></tr><tr><td>CURRENT_HOUR</td><td>当前小时数，24小时制</td></tr><tr><td>CURRENT_MINUTE</td><td>当前分钟数</td></tr><tr><td>CURRENT_SECOND</td><td>当前秒数</td></tr><tr><td>CURRENT_SECONDS_UNIX</td><td>时间戳</td></tr></tbody></table><h3 id="变量转换-Variable-transforms"><a href="#变量转换-Variable-transforms" class="headerlink" title="变量转换 Variable transforms"></a>变量转换 Variable transforms</h3><p>在代码片段正式插入到代码之中前，你可以对其中的变量的值，通过正则表达式进行一些替换处理  </p><blockquote><p>案例：去除文件名的扩展名  </p></blockquote><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">$&#123;TM_FILENAME/(.<span class="hljs-symbol">*</span>)\\..+$/$1/&#125;<br>  |<span class="hljs-string">           </span>|<span class="hljs-string">         </span>|<span class="hljs-string">  </span>|<br>  |<span class="hljs-string">           </span>|<span class="hljs-string">         </span>|<span class="hljs-string">  </span>|<span class="hljs-string">-&gt; 替换内容为&quot;&quot;</span><br><span class="hljs-string">  </span>|<span class="hljs-string">           </span>|<span class="hljs-string">         </span>|<br>  |<span class="hljs-string">           </span>|<span class="hljs-string">         </span>|<span class="hljs-string">-&gt; 选择第一个被正则表达式匹配的内容</span><br><span class="hljs-string">  </span>|<span class="hljs-string">           </span>|<span class="hljs-string">            </span><br><span class="hljs-string">  </span>|<span class="hljs-string">           </span>|<span class="hljs-string">-&gt; 正则表达式匹配(.*)</span><br><span class="hljs-string">  </span>|<span class="hljs-string">             </span><br><span class="hljs-string">  </span>|<span class="hljs-string">-&gt; 通过变量得到文件名</span><br></code></pre></td></tr></table></figure><p><span></span></p><blockquote><p>案例：用<code>_</code>取代<code>.</code>  </p></blockquote><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle">$&#123;TM_FILENAME<span class="hljs-regexp">/[\\.]/</span>_/&#125;<br></code></pre></td></tr></table></figure><p><span></span></p><blockquote><p>案例：用<code>_</code>取代<code>.</code>和<code>-</code></p></blockquote><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle">$&#123;TM_FILENAME<span class="hljs-regexp">/[\\.-]/</span>_/g&#125;<br></code></pre></td></tr></table></figure><p><span></span></p><blockquote><p>案例：将文件名改为大写字母  </p></blockquote><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$&#123;</span>TM_FILENAME/(.*)/<span class="hljs-variable">$&#123;</span><span class="hljs-number">1</span><span class="hljs-symbol">:/upcase</span>&#125;/&#125;<br></code></pre></td></tr></table></figure><p><span></span></p><blockquote><p>案例：只保留数字与字母 </p></blockquote><figure class="highlight parser3"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs parser3"><span class="hljs-variable">$&#123;TM_FILENAME</span><span class="xml">/[</span><span class="hljs-keyword">^0-9</span><span class="hljs-keyword">^a-z</span><span class="xml">]//gi&#125;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>VSCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ConfigParser-Python-ini配置文件</title>
    <link href="/post/810bbcb7/"/>
    <url>/post/810bbcb7/</url>
    
    <content type="html"><![CDATA[<h1 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h1><p>这是一个用来管理配置文件的库<br>一般用来管理<code>.ini</code>配置文件（<code>Windows</code>下的配置文件）  </p><blockquote><p>不太推荐用这个东西，问题较多，感觉还不如直接<code>json</code></p></blockquote><h2 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h2><p>官方文档：<a href="https://docs.python.org/3/library/configparser.html">https://docs.python.org/3/library/configparser.html</a>  </p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><code>.ini</code>和<code>.conf</code>配置文件,他们大概长这样：  </p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[db]</span><br><span class="hljs-attr">db_host</span> = <span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span><br><span class="hljs-attr">db_port</span> = <span class="hljs-number">69</span><br><span class="hljs-attr">db_user</span> = root<br><span class="hljs-attr">db_pass</span> = root<br><span class="hljs-attr">host_port</span> = <span class="hljs-number">69</span><br><span class="hljs-attr">is_ok</span> = <span class="hljs-literal">True</span><br> <br><span class="hljs-section">[concurrent]</span><br><span class="hljs-attr">thread</span> = <span class="hljs-number">10</span><br><span class="hljs-attr">processor</span> = <span class="hljs-number">20</span><br></code></pre></td></tr></table></figure><h3 id="Section"><a href="#Section" class="headerlink" title="Section"></a>Section</h3><p>上面的<code>[db]</code>,<code>[concurrent]</code>之类的就是<code>section</code><br>内容一般用<code>[]</code>来包裹，表示一块相对独立的配置块  </p><h3 id="Options"><a href="#Options" class="headerlink" title="Options"></a>Options</h3><p>上面的<code>db_host = 127.0.0.1</code>，<code>db_port = 69</code>之类的就是<code>Options</code><br>这是配置的本体，以<code>Key-Value</code>的形式保存着  </p><h1 id="使用入门"><a href="#使用入门" class="headerlink" title="使用入门"></a>使用入门</h1><p>这个东西的用法很像<code>dict</code><br>如果遇到什么想要进行的<code>dict</code>本身又提供函数的操作，可以试试看能不能用  </p><h2 id="读取"><a href="#读取" class="headerlink" title="读取"></a>读取</h2><h3 id="初始化ConfigParser对象"><a href="#初始化ConfigParser对象" class="headerlink" title="初始化ConfigParser对象"></a>初始化ConfigParser对象</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">&gt;&gt;&gt;<span class="hljs-keyword">import</span> configparser<br>&gt;&gt;&gt;config = configparser.ConfigParser()<br>&gt;&gt;&gt;config.read(<span class="hljs-string">&quot;ini&quot;</span>, encoding=<span class="hljs-string">&quot;utf-8&quot;</span>)<br></code></pre></td></tr></table></figure><h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><h3 id="获取Section节点"><a href="#获取Section节点" class="headerlink" title="获取Section节点"></a>获取Section节点</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">&gt;&gt;&gt;print(config.sections())<br>[<span class="hljs-string">&#x27;db&#x27;</span>, <span class="hljs-string">&#x27;concurrent&#x27;</span>]<br>&gt;&gt;&gt;print(config[<span class="hljs-string">&#x27;db&#x27;</span>])<br>[<span class="hljs-string">&#x27;db&#x27;</span>, <span class="hljs-string">&#x27;concurrent&#x27;</span>]<br></code></pre></td></tr></table></figure><h3 id="从Section中获取Options"><a href="#从Section中获取Options" class="headerlink" title="从Section中获取Options"></a>从Section中获取Options</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">&gt;&gt;&gt;config.options(<span class="hljs-string">&quot;db&quot;</span>)<br>[<span class="hljs-string">&#x27;db_host&#x27;</span>, <span class="hljs-string">&#x27;db_port&#x27;</span>, <span class="hljs-string">&#x27;db_user&#x27;</span>, <span class="hljs-string">&#x27;db_pass&#x27;</span>, <span class="hljs-string">&#x27;host_port&#x27;</span>]<br>&gt;&gt;&gt;<span class="hljs-built_in">list</span>(config[<span class="hljs-string">&#x27;db&#x27;</span>].keys())<br>[<span class="hljs-string">&#x27;db_host&#x27;</span>, <span class="hljs-string">&#x27;db_port&#x27;</span>, <span class="hljs-string">&#x27;db_user&#x27;</span>, <span class="hljs-string">&#x27;db_pass&#x27;</span>, <span class="hljs-string">&#x27;host_port&#x27;</span>]<br></code></pre></td></tr></table></figure><h3 id="获取Option的值"><a href="#获取Option的值" class="headerlink" title="获取Option的值"></a>获取Option的值</h3><h4 id="获取指定Option的值"><a href="#获取指定Option的值" class="headerlink" title="获取指定Option的值"></a>获取指定Option的值</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">&gt;&gt;&gt;r = config.get(<span class="hljs-string">&quot;db&quot;</span>, <span class="hljs-string">&quot;db_host&quot;</span>)<br><span class="hljs-string">&quot;127.0.0.1&quot;</span><br>&gt;&gt;&gt;r0 = config[<span class="hljs-string">&#x27;db&#x27;</span>][<span class="hljs-string">&#x27;db_host&#x27;</span>]<br><span class="hljs-string">&quot;127.0.0.1&quot;</span><br>&gt;&gt;&gt;r1 = config.getint(<span class="hljs-string">&quot;db&quot;</span>, <span class="hljs-string">&quot;db_port&quot;</span>)  <span class="hljs-comment"># 将获取到值转换为int型</span><br><span class="hljs-number">69</span><br>&gt;&gt;&gt;r2 = config.getboolean(<span class="hljs-string">&quot;db&quot;</span>, <span class="hljs-string">&quot;is_ok&quot;</span> )  <span class="hljs-comment"># 将获取到值转换为bool型</span><br><span class="hljs-literal">True</span><br>&gt;&gt;&gt;r3 = config.getfloat(<span class="hljs-string">&quot;db&quot;</span>, <span class="hljs-string">&quot;host_port&quot;</span> ) <span class="hljs-comment">#将获取到值转换为浮点型</span><br><span class="hljs-number">69.0</span><br></code></pre></td></tr></table></figure><h4 id="获取所有Option的值"><a href="#获取所有Option的值" class="headerlink" title="获取所有Option的值"></a>获取所有Option的值</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">&gt;&gt;&gt;config.items(<span class="hljs-string">&quot;db&quot;</span>)<br>[(<span class="hljs-string">&#x27;db_host&#x27;</span>, <span class="hljs-string">&#x27;127.0.0.1&#x27;</span>), (<span class="hljs-string">&#x27;db_port&#x27;</span>, <span class="hljs-string">&#x27;69&#x27;</span>), (<span class="hljs-string">&#x27;db_user&#x27;</span>, <span class="hljs-string">&#x27;root&#x27;</span>), (<span class="hljs-string">&#x27;db_pass&#x27;</span>, <span class="hljs-string">&#x27;root&#x27;</span>), (<span class="hljs-string">&#x27;host_port&#x27;</span>, <span class="hljs-string">&#x27;69&#x27;</span>)]<br>&gt;&gt;&gt;<span class="hljs-built_in">list</span>(config[<span class="hljs-string">&#x27;database-mongo&#x27;</span>].items())<br>[(<span class="hljs-string">&#x27;db_host&#x27;</span>, <span class="hljs-string">&#x27;127.0.0.1&#x27;</span>), (<span class="hljs-string">&#x27;db_port&#x27;</span>, <span class="hljs-string">&#x27;69&#x27;</span>), (<span class="hljs-string">&#x27;db_user&#x27;</span>, <span class="hljs-string">&#x27;root&#x27;</span>), (<span class="hljs-string">&#x27;db_pass&#x27;</span>, <span class="hljs-string">&#x27;root&#x27;</span>), (<span class="hljs-string">&#x27;host_port&#x27;</span>, <span class="hljs-string">&#x27;69&#x27;</span>)]<br></code></pre></td></tr></table></figure><h2 id="检测"><a href="#检测" class="headerlink" title="检测"></a>检测</h2><h3 id="检测是否有Section"><a href="#检测是否有Section" class="headerlink" title="检测是否有Section"></a>检测是否有Section</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">&gt;&gt;&gt;config.has_section(<span class="hljs-string">&quot;db&quot;</span>)  <span class="hljs-comment"># 是否存在该section</span><br><span class="hljs-literal">True</span><br>&gt;&gt;&gt;<span class="hljs-string">&#x27;db&#x27;</span> <span class="hljs-keyword">in</span> config<br><span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><h3 id="检测是否有Option"><a href="#检测是否有Option" class="headerlink" title="检测是否有Option"></a>检测是否有Option</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">&gt;&gt;&gt;config.has_option(<span class="hljs-string">&quot;section&quot;</span>, <span class="hljs-string">&quot;option&quot;</span>)<br><span class="hljs-literal">False</span><br>&gt;&gt;&gt;<span class="hljs-string">&quot;db_host&quot;</span> <span class="hljs-keyword">in</span> config[<span class="hljs-string">&quot;db&quot;</span>]<br><span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><h2 id="修改-创建"><a href="#修改-创建" class="headerlink" title="修改/创建"></a>修改/创建</h2><h3 id="创建Section"><a href="#创建Section" class="headerlink" title="创建Section"></a>创建Section</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">&gt;&gt;&gt;config.add_section(<span class="hljs-string">&quot;new:section&quot;</span>)<br>&gt;&gt;&gt;config[<span class="hljs-string">&#x27;new:section&#x27;</span>] = &#123;&#125;<br><span class="hljs-comment"># 可以顺便赋值option</span><br>&gt;&gt;&gt;config[<span class="hljs-string">&#x27;new:section&#x27;</span>] = &#123;<span class="hljs-string">&#x27;o1&#x27;</span>: <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;o2&#x27;</span>: <span class="hljs-string">&#x27;2&#x27;</span>&#125;<br></code></pre></td></tr></table></figure><h3 id="修改-创建Option"><a href="#修改-创建Option" class="headerlink" title="修改/创建Option"></a>修改/创建Option</h3><p>修改某个<code>option</code>的值，如果不存在该<code>option</code>则会被创建  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># db Section 的 db_port Option 的值为69</span><br>&gt;&gt;&gt;config.<span class="hljs-built_in">set</span>(<span class="hljs-string">&quot;db&quot;</span>, <span class="hljs-string">&quot;db_port&quot;</span>, <span class="hljs-string">&quot;69&quot;</span>)<br>&gt;&gt;&gt;config[<span class="hljs-string">&#x27;db&#x27;</span>][<span class="hljs-string">&quot;db_port&quot;</span>] = <span class="hljs-string">&#x27;69&#x27;</span><br></code></pre></td></tr></table></figure><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><h3 id="删除Section"><a href="#删除Section" class="headerlink" title="删除Section"></a>删除Section</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">&gt;&gt;&gt;config.pop(<span class="hljs-string">&#x27;db&#x27;</span>)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;config[<span class="hljs-string">&#x27;db&#x27;</span>] = &#123;&#125;  <span class="hljs-comment"># 重新创建以供删除</span><br>&gt;&gt;&gt;config.remove_section(<span class="hljs-string">&quot;default&quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="删除Option"><a href="#删除Option" class="headerlink" title="删除Option"></a>删除Option</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">&gt;&gt;&gt;config.pop(<span class="hljs-string">&#x27;db&#x27;</span>)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;config[<span class="hljs-string">&#x27;db&#x27;</span>] = &#123;&#125;  <span class="hljs-comment"># 重新创建以供删除</span><br>&gt;&gt;&gt;config.remove_section(<span class="hljs-string">&quot;default&quot;</span>)<br></code></pre></td></tr></table></figure><h2 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;example.ini&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>    config.write(f)<br></code></pre></td></tr></table></figure><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h2 id="关键词无法使用"><a href="#关键词无法使用" class="headerlink" title="关键词无法使用"></a>关键词无法使用</h2><p>有一些词在文件里是无法使用的，只要一访问带有这个词的Option就会报错<br>比如说 <code>asctime</code><br>解决办法：</p><ol><li>使用<code>RawConfigParser</code>而不是<code>ConfigParser</code>  </li><li>把关键词删除  </li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>ConfigParser</tag>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Webpack-前端</title>
    <link href="/post/80b1cc67/"/>
    <url>/post/80b1cc67/</url>
    
    <content type="html"><![CDATA[<h1 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h1><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>分析项目结构，找到JavaScript模块以及其它的一些浏览器不能直接运行的拓展语言（Scss,TypeScript等），将其打包为合适的格式以供浏览器使用<br><img src="/Webpack-%E5%89%8D%E7%AB%AF/20201028105124538.png">  </p><ul><li>代码转换<br>ES6-&gt;ES5之类  </li><li>文件优化<br>代码压缩，合并文件  </li><li>代码分割<br>公共模块抽离  </li><li>模块合并  </li><li>自动刷新<br>代码变更，更新页面  </li><li>代码校验  </li><li>自动发布  </li></ul><h2 id="学习条件"><a href="#学习条件" class="headerlink" title="学习条件"></a>学习条件</h2><ul><li>Node基础  </li><li>npm使用  </li><li>ES6语法  </li></ul><h1 id="文档-链接"><a href="#文档-链接" class="headerlink" title="文档/链接"></a>文档/链接</h1><p>官网：<a href="https://www.webpackjs.com/">https://www.webpackjs.com/</a><br>文档：<a href="https://www.webpackjs.com/concepts/">https://www.webpackjs.com/concepts/</a>  </p>]]></content>
    
    
    
    <tags>
      
      <tag>Webpack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Django-后端-Python</title>
    <link href="/post/63485ee6/"/>
    <url>/post/63485ee6/</url>
    
    <content type="html"><![CDATA[<h1 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h1><p>一个<code>python</code> <code>web框架</code>，相较于<code>flask</code>而言体量更大更重 </p><h1 id="文档-网站"><a href="#文档-网站" class="headerlink" title="文档/网站"></a>文档/网站</h1><p>官网：<a href="https://www.djangoproject.com/">https://www.djangoproject.com/</a><br>文档：<a href="https://docs.djangoproject.com/zh-hans/3.1/intro/install/">https://docs.djangoproject.com/zh-hans/3.1/intro/install/</a>  </p><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>使用<code>pip</code>进行安装即可  </p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">pip <span class="hljs-keyword">install</span> Django<br></code></pre></td></tr></table></figure><h3 id="验证安装"><a href="#验证安装" class="headerlink" title="验证安装"></a>验证安装</h3><p>对应环境启动后，输出<code>django</code>版本号以测试是否安装成功</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta">&gt;&gt;&gt;</span> <span class="python"><span class="hljs-keyword">import</span> django</span><br><span class="hljs-meta">&gt;&gt;&gt;</span> <span class="python">print(django.get_version())</span><br></code></pre></td></tr></table></figure><h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><h3 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h3><h4 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h4><p>在<code>cmd</code>中<code>cd</code>到一个建立项目的位置<br>使用<code>startproject命令</code>创建项目  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">django-admin startproject 项目名<br></code></pre></td></tr></table></figure><blockquote><p>注意：不要使用python内部字段来命名项目，这会引起冲突  </p></blockquote><p>在运行<code>startproject</code>生成项目后，会生成以下这些文件  </p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs 1c">项目名/  <span class="hljs-meta"># 项目根目录。名字可以随改</span><br>    manage.py  <span class="hljs-meta"># Django项目的命令行工具</span><br>    项目名/  <span class="hljs-meta"># 项目所需python包</span><br>        __init__.py  <span class="hljs-meta"># 包标识</span><br>        settings.py  <span class="hljs-meta"># 项目的配置文件</span><br>        urls.py  <span class="hljs-meta"># 项目的URL声明，就像你网站的“目录”</span><br>        asgi.py <span class="hljs-meta"># 项目的运行在ASGI兼容的Web服务器上的入口</span><br>        wsgi.py  <span class="hljs-meta"># 项目的运行在 WSGI 兼容的Web服务器上的入口</span><br></code></pre></td></tr></table></figure><p>更多细节 - 链接：  </p><ul><li>manage.py - <a href="https://docs.djangoproject.com/zh-hans/3.1/ref/django-admin/">Django项目的命令行工具</a>  </li><li>mysite/settings.py - <a href="https://docs.djangoproject.com/zh-hans/3.1/topics/settings/">Django项目配置</a>  </li><li>mysite/urls.py - <a href="https://docs.djangoproject.com/zh-hans/3.1/topics/http/urls/">URL声明</a>  </li><li>mysite/asgi.py - <a href="https://docs.djangoproject.com/zh-hans/3.1/howto/deployment/asgi/">ASGI-Web服务器入口</a>  </li><li>mysite/wsgi.py - <a href="https://docs.djangoproject.com/zh-hans/3.1/howto/deployment/wsgi/">WSGI-Web服务器入口</a>  </li></ul><h4 id="创建应用"><a href="#创建应用" class="headerlink" title="创建应用"></a>创建应用</h4><p>在<code>Django</code>中，每一个应用都是一个<code>Python</code>包，并且遵循着相同的约定<br><code>Django</code>自带一个工具，可以帮你生成应用的基础目录结构  </p><blockquote><p>项目和应用有什么区别？<br>应用：一个专门做某件事的网络应用程序——比如博客系统，或者公共记录的数据库，或者小型的投票程序<br>项目：则是一个网站使用的配置和应用的集合<br>项目可以包含很多个应用。应用可以被很多个项目使用  </p></blockquote><p>你的应用可以存放在任何<code>Python path</code>中定义的路径<br>可以在<code>manage.py</code>同级目录下创建应用。这样它就可以作为顶级模块导入。也可以在<code>mysite</code>中创建，作为一个子模块  </p><p>创建一个应用（注意路径问题）  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">python manage.py startapp 应用名<br></code></pre></td></tr></table></figure><p>这样以后，会创建一个以应用名命名的文件夹  </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs css">应用名/<br>    __<span class="hljs-selector-tag">init__</span><span class="hljs-selector-class">.py</span><br>    <span class="hljs-selector-tag">admin</span><span class="hljs-selector-class">.py</span><br>    <span class="hljs-selector-tag">apps</span><span class="hljs-selector-class">.py</span><br>    <span class="hljs-selector-tag">migrations</span>/<br>        __<span class="hljs-selector-tag">init__</span><span class="hljs-selector-class">.py</span><br>    <span class="hljs-selector-tag">models</span><span class="hljs-selector-class">.py</span><br>    <span class="hljs-selector-tag">tests</span><span class="hljs-selector-class">.py</span><br>    <span class="hljs-selector-tag">views</span><span class="hljs-selector-class">.py</span><br></code></pre></td></tr></table></figure><p>这个目录包含了这个应用的全部内容  </p><h5 id="添加创建的应用到配置文件中"><a href="#添加创建的应用到配置文件中" class="headerlink" title="添加创建的应用到配置文件中"></a>添加创建的应用到配置文件中</h5><p>然后在<code>项目名/项目名/settings.py</code>中的<code>INSTALLED_APPS</code>中将自己创建的应用添加进去  </p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">INSTALLED_APPS</span> = [<br>    ......<br>    <span class="hljs-string">&#x27;应用名&#x27;</span><br>]<br></code></pre></td></tr></table></figure><p>这样做能更好的利用<code>Django</code>自带的配置，比如说自动加载模板<br>不添加也不会出什么问题  </p><h4 id="编辑视图"><a href="#编辑视图" class="headerlink" title="编辑视图"></a>编辑视图</h4><p>打开<code>polls/views.py</code>，把下面这些<code>Python</code>代码写入：  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.http <span class="hljs-keyword">import</span> HttpResponse<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">index</span>(<span class="hljs-params">request</span>):</span><br>    <span class="hljs-keyword">return</span> HttpResponse(<span class="hljs-string">&quot;Hello, world.&quot;</span>)<br></code></pre></td></tr></table></figure><h4 id="编辑URL映射"><a href="#编辑URL映射" class="headerlink" title="编辑URL映射"></a>编辑URL映射</h4><h5 id="编辑应用URL映射"><a href="#编辑应用URL映射" class="headerlink" title="编辑应用URL映射"></a>编辑应用URL映射</h5><p>将一个URL映射到视图上，才能显示一个视图<br>在 应用的目录（不是项目） 中创建一个<code>urls.py</code>文件，并写入以下代码：  </p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">from</span> django.urls <span class="hljs-keyword">import</span> <span class="hljs-type">path</span><br><span class="hljs-keyword">from</span> . <span class="hljs-keyword">import</span> views<br><br>urlpatterns = [<br>    path(<span class="hljs-string">&#x27;&#x27;</span>, views.<span class="hljs-keyword">index</span>, <span class="hljs-type">name</span>=<span class="hljs-string">&#x27;index&#x27;</span>),<br>]<br></code></pre></td></tr></table></figure><blockquote><p><a href="https://docs.djangoproject.com/zh-hans/3.1/ref/urls/#django.urls.path">path函数</a>具有四个参数，两个必传：<code>route</code> 和 <code>view</code>，两个可选参数：<code>kwargs</code> 和 <code>name</code>    </p><ul><li><p><code>route</code><br><code>route</code>是一个匹配<code>URL</code>的准则（类似正则表达式）<br>当 Django 响应一个请求时，它会从<code>urlpatterns</code>的第一项开始，按顺序依次匹配列表中的项，直到找到匹配的项。</p><blockquote><p>注意：这些准则不会匹配<code>GET</code>和<code>POST</code>参数或域名   </p></blockquote></li><li><p><code>view</code><br>当<code>Django</code>找到了一个匹配的准则，就会调用这个特定的视图函数，并传入一个 <code>HttpRequest</code>对象作为第一个参数，被“捕获”的参数以关键字参数的形式传入  </p></li><li><p><code>kwargs</code><br>任意个关键字参数可以作为一个字典传递给目标视图函数  </p></li><li><p><code>name</code><br>为<code>URL</code>取名能使你在<code>Django</code>的任意地方唯一地引用它，尤其是在模板中<br>这个有用的特性允许你只改一个文件就能全局地修改某个<code>URL</code>模式  </p></li></ul></blockquote><h5 id="编辑项目URL映射"><a href="#编辑项目URL映射" class="headerlink" title="编辑项目URL映射"></a>编辑项目URL映射</h5><p>应用是依托于项目运行的，应用的URL映射关系应与项目URL映射绑定  </p><p>在根<code>URLconf文件</code>中指定我们创建的<code>应用名.urls</code>模块<br>在<code>mysite/urls.py</code>文件的<code>urlpatterns</code>列表里插入一个 <code>include()</code>， 如下：  </p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">from</span> django.contrib <span class="hljs-keyword">import</span> <span class="hljs-keyword">admin</span><br><span class="hljs-keyword">from</span> django.urls <span class="hljs-keyword">import</span> <span class="hljs-keyword">include</span>, <span class="hljs-type">path</span><br><br>urlpatterns = [<br>    path(<span class="hljs-string">&#x27;应用名/&#x27;</span>, <span class="hljs-keyword">include</span>(<span class="hljs-string">&#x27;应用名.urls&#x27;</span>)),<br>    path(<span class="hljs-string">&#x27;admin/&#x27;</span>, <span class="hljs-keyword">admin</span>.site.urls),<br>]<br></code></pre></td></tr></table></figure><p>函数<code>include()</code>允许引用其它<code>URLconfs</code><br>每当<code>Django</code>遇到<code>include()</code>时，它会截断与此项匹配的<code>URL</code>的部分，并将剩余的字符串发送到<code>URLconf</code>以供进一步处理  </p><blockquote><p><code>include()</code>的理念是可以即插即用<br>因为应用有它自己的<code>URLconf( polls/urls.py )</code>，他们能够被放在 “/polls/“ ， “/fun_polls/“ ，”/content/polls/“，或者其他任何路径下，这个应用都能够正常工作  </p></blockquote><h4 id="用于开发的简易服务器"><a href="#用于开发的简易服务器" class="headerlink" title="用于开发的简易服务器"></a>用于开发的简易服务器</h4><p>在<code>cmd</code>中输入命令以使用开发服务器  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">&gt;&gt;&gt;python manager.py runserver<br></code></pre></td></tr></table></figure><p>启动后你会看到一些输出  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql">Watching for file changes <span class="hljs-keyword">with</span> StatReloader<br>Performing <span class="hljs-keyword">system</span> checks...<br><br><span class="hljs-keyword">System</span> <span class="hljs-keyword">check</span> <span class="hljs-keyword">identified</span> <span class="hljs-keyword">no</span> issues (<span class="hljs-number">0</span> silenced).<br><br>You have <span class="hljs-number">18</span> unapplied <span class="hljs-keyword">migration</span>(s). Your <span class="hljs-keyword">project</span> may <span class="hljs-keyword">not</span> <span class="hljs-keyword">work</span> properly <span class="hljs-keyword">until</span> you <span class="hljs-keyword">apply</span> the migrations <span class="hljs-keyword">for</span> app(s): <span class="hljs-keyword">admin</span>, auth, contenttypes, sessions.<br>Run <span class="hljs-string">&#x27;python manage.py migrate&#x27;</span> <span class="hljs-keyword">to</span> <span class="hljs-keyword">apply</span> them.<br>October <span class="hljs-number">26</span>, <span class="hljs-number">2020</span> - <span class="hljs-number">16</span>:<span class="hljs-number">25</span>:<span class="hljs-number">10</span><br>Django <span class="hljs-keyword">version</span> <span class="hljs-number">3.1</span><span class="hljs-number">.2</span>, <span class="hljs-keyword">using</span> <span class="hljs-keyword">settings</span> <span class="hljs-string">&#x27;SXB_BaiduSEO_Web.settings&#x27;</span><br><span class="hljs-keyword">Starting</span> development <span class="hljs-keyword">server</span> <span class="hljs-keyword">at</span> <span class="hljs-keyword">http</span>://<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">8000</span>/<br>Quit the <span class="hljs-keyword">server</span> <span class="hljs-keyword">with</span> CTRL-BREAK.<br></code></pre></td></tr></table></figure><p>这个命令启动的是<code>Django</code>自带的用于开发的简易服务器，一个用纯<code>Python</code>写的轻量级的<code>Web服务器</code><br>这个服务器内置在<code>Django</code>中是为了让你能快速的开发出想要的东西  (不需要进行配置生产级别的服务器（比如 Apache）方面的工作）</p><p><strong>千万不要！！！ 千万不要！！！ 千万不要！！！</strong>将这个服务器用于和生产环境相关的任何地方  </p><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="更多视图"><a href="#更多视图" class="headerlink" title="更多视图"></a>更多视图</h3><p>向<code>应用名/views.py</code> 里添加更多视图  </p><h4 id="带参数视图"><a href="#带参数视图" class="headerlink" title="带参数视图"></a>带参数视图</h4><figure class="highlight python"><figcaption><span>应用名/urls.py</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.urls <span class="hljs-keyword">import</span> path<br><span class="hljs-keyword">from</span> . <span class="hljs-keyword">import</span> views<br><br>urlpatterns = [<br>    ......<br>    <span class="hljs-comment"># 新的url映射，映射到detail中</span><br>    <span class="hljs-comment"># url的一部分作为参数 _id 传入</span><br>    path(<span class="hljs-string">&#x27;&lt;int:_id&gt;/&#x27;</span>, views.detail, name=<span class="hljs-string">&#x27;detail&#x27;</span>),<br>]<br></code></pre></td></tr></table></figure><figure class="highlight python"><figcaption><span>应用名/views.py</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">detail</span>(<span class="hljs-params">request, _id</span>):</span><br>    <span class="hljs-comment"># 获取url作为参数传入的_id</span><br>    <span class="hljs-keyword">return</span> HttpResponse(<span class="hljs-string">&quot;ID=&quot;</span> + _id)<br></code></pre></td></tr></table></figure><h4 id="HTML模板视图"><a href="#HTML模板视图" class="headerlink" title="HTML模板视图"></a>HTML模板视图</h4><ol><li>首先，在应用目录中创建一个模板目录（文件夹）<code>templates</code><br><code>Django</code>将会在这个目录里查找模板文件  </li><li>在刚创建的<code>templates</code>目录里，再创建一个目录<code>polls</code>  </li><li>然后在其中新建一个文件 <code>index.html</code><br>在完成上面的操作以后，你的模板文件的路径应该是 <code>应用名/templates/应用名/index.html</code></li><li>写入<code>index.html</code>的模板代码  <figure class="highlight html"><figcaption><span>应用名/templates/应用名/index.html</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>        &#123;% for question in questions %&#125;<br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>&#123;&#123; question &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>        &#123;% endfor %&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li>视图引用HTML模板  <figure class="highlight python"><figcaption><span>polls/views.py</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.http <span class="hljs-keyword">import</span> HttpResponse<br><span class="hljs-keyword">from</span> django.template <span class="hljs-keyword">import</span> loader<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">questions</span>(<span class="hljs-params">request</span>):</span><br>    questions = [<span class="hljs-string">&#x27;是什么&#x27;</span>,<span class="hljs-string">&#x27;为什么&#x27;</span>, <span class="hljs-string">&#x27;怎么做&#x27;</span>]<br>    template = loader.get_template(<span class="hljs-string">&#x27;BaiduSEO/index.html&#x27;</span>)<br>    context = &#123;<span class="hljs-string">&#x27;questions&#x27;</span>: questions&#125;<br>    <span class="hljs-keyword">return</span> HttpResponse(template.render(context, request))<br></code></pre></td></tr></table></figure></li><li>创建对应url映射  <figure class="highlight python"><figcaption><span>应用名/urls.py</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">urlpatterns = [<br>    ......<br>    path(<span class="hljs-string">&#x27;questions/&#x27;</span>, views.questions, name=<span class="hljs-string">&#x27;questions&#x27;</span>)<br>]<br></code></pre></td></tr></table></figure></li><li>部署、访问、验证效果  </li></ol><blockquote><h5 id="为什么能够找到模板？"><a href="#为什么能够找到模板？" class="headerlink" title="为什么能够找到模板？"></a>为什么能够找到模板？</h5><p>你项目的<a href="https://docs.djangoproject.com/zh-hans/3.1/ref/settings/#std:setting-TEMPLATES"><code>TEMPLATES</code></a> 配置项描述了<code>Django</code>如何载入和渲染模板。<br>默认的设置文件设置了 <code>DjangoTemplates</code> 后端，并将 <a href="https://docs.djangoproject.com/zh-hans/3.1/ref/settings/#std:setting-TEMPLATES-APP_DIRS"><code>APP_DIRS</code></a> 设置成了 <code>True</code>。这一选项将会让 <code>DjangoTemplates</code> 在每个 <a href="https://docs.djangoproject.com/zh-hans/3.1/ref/settings/#std:setting-INSTALLED_APPS"><code>INSTALLED_APPS</code></a> 文件夹中寻找 <code>&quot;templates&quot;</code> 子目录。这就是<code>Django</code>能正确找到应用模板位置的原因。</p></blockquote><p><span></span></p><blockquote><h5 id="模板命名空间"><a href="#模板命名空间" class="headerlink" title="模板命名空间"></a>模板命名空间</h5><p>虽然可以将模板文件直接放在<code>应用名/templates</code>文件夹中（而不是再建立一个<code>应用名</code>子文件夹），但是这样做不太好<br><code>Django</code>会选择第一个匹配的模板文件，如果你有一个模板文件正好和另一个应用中的某个模板文件重名，<code>Django</code>没有办法区分它们<br>为了让<code>Django</code>选择正确的模板，最好的方法就是把他们放入各自的<code>命名空间</code> 中，也就是把这些模板放入一个和 <strong>自身</strong> 应用重名的子文件夹里  </p></blockquote><h3 id="快捷函数render"><a href="#快捷函数render" class="headerlink" title="快捷函数render()"></a>快捷函数render()</h3><p>「载入模板，填充上下文，再返回由它生成的 HttpResponse 对象」是一个非常常用的操作流程<br>于是<code>Django</code>提供了一个快捷函数，来让代码变得更优美  </p><figure class="highlight python"><figcaption><span>应用名/views.py</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.shortcuts <span class="hljs-keyword">import</span> render<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">index</span>(<span class="hljs-params">request</span>):</span><br>    questions = [<span class="hljs-string">&#x27;是什么&#x27;</span>,<span class="hljs-string">&#x27;为什么&#x27;</span>, <span class="hljs-string">&#x27;怎么做&#x27;</span>]<br>    context = &#123;<span class="hljs-string">&#x27;questions&#x27;</span>: questions&#125;<br>    <span class="hljs-keyword">return</span> render(request, <span class="hljs-string">&#x27;应用名/index.html&#x27;</span>, context)<br></code></pre></td></tr></table></figure><p>这样做就不再需要导入<code>loader</code>和<code>HttpResponse</code>  </p><h3 id="抛出404错误"><a href="#抛出404错误" class="headerlink" title="抛出404错误"></a>抛出404错误</h3><p>写一个可能会报错的代码，在抓到异常后返回<code>404</code>  </p><figure class="highlight python"><figcaption><span>应用名/views.py</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.http <span class="hljs-keyword">import</span> Http404<br><span class="hljs-keyword">from</span> django.shortcuts <span class="hljs-keyword">import</span> render<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">detail</span>(<span class="hljs-params">request, question_id</span>):</span><br>    <span class="hljs-keyword">try</span>:<br>    <span class="hljs-comment"># 如果传入的数是0，那么会报错返回`404`  </span><br>        a = <span class="hljs-number">10</span>/question_id<br>    <span class="hljs-keyword">except</span> Exception:<br>        <span class="hljs-keyword">raise</span> Http404(<span class="hljs-string">&quot;Question does not exist&quot;</span>)<br>    <span class="hljs-keyword">return</span> render(request, <span class="hljs-string">&#x27;应用名/id_zero.html&#x27;</span>, &#123;<span class="hljs-string">&#x27;question&#x27;</span>: a&#125;)<br></code></pre></td></tr></table></figure><p>配套的<code>html</code>和<code>url</code>映射写好了以后就能查看情况了  </p><h3 id="去除模板中的硬编码URL"><a href="#去除模板中的硬编码URL" class="headerlink" title="去除模板中的硬编码URL"></a>去除模板中的硬编码URL</h3><figure class="highlight html"><figcaption><span>应用名/template/应用名/free_url.html</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;/polls/&#123;&#123; question.id &#125;&#125;/&quot;</span>&gt;</span>点我<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br></code></pre></td></tr></table></figure><p>硬编码和强耦合的链接，对于一个包含很多应用的项目来说，修改起来是十分困难的。<br>然而，因为你在<code>polls.urls</code>的<code>url()</code>函数中通过<code>name</code>参数为<code>URL</code>定义了名字，你可以使用 <code>&#123;% url %&#125;</code> 标签代替它  </p><figure class="highlight html"><figcaption><span>应用名/template/应用名/free_url.html</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;&#123;% url &#x27;detail&#x27; question.id %&#125;&quot;</span>&gt;</span>&#123;&#123; question.question_text &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这个标签的工作方式是在<code>应用名/urls.py</code>的<code>URL</code>定义中寻具有指定名字的条目 </p><figure class="highlight python"><figcaption><span>应用名/urls.py</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">path(<span class="hljs-string">&#x27;&lt;int:question_id&gt;/&#x27;</span>, views.detail, name=<span class="hljs-string">&#x27;detail&#x27;</span>)<br></code></pre></td></tr></table></figure><p>这个<code>name</code>参数，就是<code>&#123;% url %&#125;</code>用来引用的<code>key</code>，最终得到的值是前面的路由信息</p><p>如果你想改变投票详情视图的<code>URL</code>，比如想改成<code>应用名/specifics/12/</code>，你不用在模板里修改任何东西（包括其它模板），只要在<code>polls/urls.py</code>里稍微修改一下就行  </p><figure class="highlight python"><figcaption><span>应用名/urls.py</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># added the word &#x27;specifics&#x27;</span><br>path(<span class="hljs-string">&#x27;specifics/&lt;int:question_id&gt;/&#x27;</span>, views.detail, name=<span class="hljs-string">&#x27;detail&#x27;</span>),<br></code></pre></td></tr></table></figure><h3 id="URL命名空间"><a href="#URL命名空间" class="headerlink" title="URL命名空间"></a>URL命名空间</h3><p>在一个真实的<code>Django</code>项目中，可能会有五个，十个，二十个，甚至更多应用<br><code>Django</code>如何分辨重名的<code>URL</code>呢？<br>答案是：在根<code>URLconf</code>中添加命名空间。在 <code>应用名/urls.py</code> 文件中稍作修改，加上 <code>app_name</code> 设置命名空间  </p><figure class="highlight python"><figcaption><span>应用名/urls.py</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.urls <span class="hljs-keyword">import</span> path<br><span class="hljs-keyword">from</span> . <span class="hljs-keyword">import</span> views<br><br><br>app_name = <span class="hljs-string">&#x27;well&#x27;</span>  <span class="hljs-comment"># 添加命名空间</span><br>urlpatterns = [<br>    ......<br>]<br></code></pre></td></tr></table></figure><p>在模板需要使用<code>&#123;% url %&#125;</code>时，带上命名空间  </p><figure class="highlight html"><figcaption><span>应用名/template/应用名/free_url.html</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;&#123;% url &#x27;well:detail question.id&#x27;%&#125;&quot;</span>&gt;</span>&#123;&#123; question &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="表单处理"><a href="#表单处理" class="headerlink" title="表单处理"></a>表单处理</h3><p>视图中的<code>request</code>参数（<code>HttpRequest</code>对象）可供使用的内容  </p><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>path</td><td>请求页面的全路径,不包括域名</td></tr><tr><td>method</td><td>请求中使用的HTTP方法的字符串表示。全大写表示。</td></tr><tr><td>GET</td><td>包含所有HTTP GET参数的类字典对象</td></tr><tr><td>POST</td><td>包含所有HTTP POST参数的类字典对象</td></tr><tr><td>REQUEST</td><td>为了方便，该属性是POST和GET属性的集合体<br>有特殊性，先查找POST属性，然后再查找GET属性。<br>强烈建议使用GET and POST,因为这两个属性更加显式化，写出的代码也更易理解。</td></tr><tr><td>COOKIES</td><td>包含所有cookies的标准Python字典对象。Keys和values都是字符串。</td></tr><tr><td>FILES</td><td>包含所有上传文件的类字典对象。<br>FILES中的每个Key都是<code>&lt;input type=&quot;file&quot; name=&quot;&quot; /&gt;</code>标签中name属性的值. <br>FILES中的每个value 同时也是一个标准Python字典对象，包含下面三个Keys:<br>&ensp;&ensp;&ensp;&ensp;filename: 上传文件名,用Python字符串表示<br>&ensp;&ensp;&ensp;&ensp;content-type: 上传文件的Content type<br>&ensp;&ensp;&ensp;&ensp;content: 上传文件的原始内容<br>注意：只有在请求方法是POST，并且请求页面中<code>&lt;form&gt;</code>有<code>enctype=&quot;multipart/form-data&quot;</code>属性时FILES才拥有数据。否则，FILES 是一个空字典。</td></tr><tr><td>META</td><td>包含所有可用HTTP头部信息的字典<br>&ensp;&ensp;&ensp;&ensp;CONTENT_LENGTH<br>&ensp;&ensp;&ensp;&ensp;CONTENT_TYPE<br>&ensp;&ensp;&ensp;&ensp;QUERY_STRING: 未解析的原始查询字符串<br>&ensp;&ensp;&ensp;&ensp;REMOTE_ADDR: 客户端IP地址<br>&ensp;&ensp;&ensp;&ensp;REMOTE_HOST: 客户端主机名<br>&ensp;&ensp;&ensp;&ensp;SERVER_NAME: 服务器主机名<br>&ensp;&ensp;&ensp;&ensp;SERVER_PORT: 服务器端口<br>META 中这些头加上前缀 HTTP_ 为 Key, 冒号(:)后面的为 Value， 例如:<br>&ensp;&ensp;&ensp;&ensp;HTTP_ACCEPT_ENCODING<br>&ensp;&ensp;&ensp;&ensp;HTTP_ACCEPT_LANGUAGE<br>&ensp;&ensp;&ensp;&ensp;HTTP_HOST: 客户发送的HTTP主机头信息<br>&ensp;&ensp;&ensp;&ensp;HTTP_REFERER: referring页<br>&ensp;&ensp;&ensp;&ensp;HTTP_USER_AGENT: 客户端的user-agent字符串<br>&ensp;&ensp;&ensp;&ensp;HTTP_X_BENDER: X-Bender头信息</td></tr><tr><td>session</td><td>唯一可读写的属性，代表当前会话的字典对象。只有激活Django中的session支持时该属性才可用。</td></tr><tr><td>raw_post_data</td><td>原始HTTP POST数据，未解析过。 高级处理时会有用处。</td></tr></tbody></table><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><code>__getitem__(key)</code></td><td>返回GET/POST的键值,先取POST,后取GET。<br>如果键不存在抛出<code>KeyError</code>。<br>这是我们可以使用字典语法访问HttpRequest对象。<br>例如:<code>request[&quot;foo&quot;]</code>等同于先request.POST<code>[&quot;foo&quot;]</code>然后 <code>request.GET[&quot;foo&quot;]</code>的操作。</td></tr><tr><td><code>has_key()</code></td><td>检查<code>request.GET</code>或<code>request.POST</code>中是否包含参数指定的Key。</td></tr><tr><td><code>get_full_path()</code></td><td>返回包含查询字符串的请求路径</td></tr><tr><td><code>is_secure()</code></td><td>如果请求是安全的，返回True，就是说，发出的是HTTPS请求。</td></tr></tbody></table>]]></content>
    
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>Django</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>xpath-Html-XML-数据解析</title>
    <link href="/post/7f566256/"/>
    <url>/post/7f566256/</url>
    
    <content type="html"><![CDATA[<h1 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h1><p><code>XPath</code>是一门在<code>XML</code>档中查找信息的语言<br><code>XPath</code>在<code>XML</code>文档中通过元素和属性进行导航<br>其速度比<code>Beautifulsoup</code>要快，比<code>正则表达式</code>要慢  </p><blockquote><p>正则，永远的神  </p></blockquote><h1 id="词汇描述"><a href="#词汇描述" class="headerlink" title="词汇描述"></a>词汇描述</h1><p>在使用<code>xpath</code>前，先要知道一些<code>DOM</code>描述词汇的意义  </p><blockquote><p>其描述与数据结构中树的描述有很多相似的地方  </p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bookstore</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">book</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">title</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span>Harry Potter<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">author</span>&gt;</span>J K. Rowling<span class="hljs-tag">&lt;/<span class="hljs-name">author</span>&gt;</span> <br>      <span class="hljs-tag">&lt;<span class="hljs-name">year</span>&gt;</span>2005<span class="hljs-tag">&lt;/<span class="hljs-name">year</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">price</span>&gt;</span>29.99<span class="hljs-tag">&lt;/<span class="hljs-name">price</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">book</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bookstore</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li><p>节点 Node<br>从标签开头到标签结束都是节点内容  </p><blockquote><p>比如  </p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">author</span>&gt;</span>J K. Rowling<span class="hljs-tag">&lt;/<span class="hljs-name">author</span>&gt;</span> <br></code></pre></td></tr></table></figure></li><li><p>值 Atomic value</p><blockquote><p>比如  </p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">29.99<br></code></pre></td></tr></table></figure></li><li><p>项 Item<br>值或节点  </p></li><li><p>父级 Parent 与 子级 Children<br>直接父级指上级节点，直接子级指下级节点  </p><blockquote><p>比如：title节点的父级是book节点<br>比如：book节点有子节点title</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">book</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">title</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span>Harry Potter<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>      ......<br><span class="hljs-tag">&lt;/<span class="hljs-name">book</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>比如：book节点有子节点title</p></blockquote></li><li><p>祖先 Ancestor 与 后代 Descendant<br>多级父级关系与多级子级关系  </p><blockquote><p>比如：bookstore有后代节点title节点<br>比如：title有祖先bookstore节点  </p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bookstore</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">book</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Harry Potter<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>      ......<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">book</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bookstore</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>同胞 Sibling<br>拥有相同父节点的节点  </p><blockquote><p>比如：title节点与year节点是同胞</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">book</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Harry Potter<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">year</span>&gt;</span>2005<span class="hljs-tag">&lt;/<span class="hljs-name">year</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">book</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><blockquote><p>然而我还是喜欢叫兄弟节点多一点</p></blockquote></blockquote></li><li><p>属性<br>指节点标签内部声明的内容  </p><blockquote><p>比如：title节点有lang属性，其值为en  </p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">title</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span>Harry Potter<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul><h1 id="轴描述语法"><a href="#轴描述语法" class="headerlink" title="轴描述语法"></a>轴描述语法</h1><p>语法本身是比较的冗长<br>缩写的语法虽然简易，但是无法做到一些比较复杂的事情  </p><table><thead><tr><th>坐标</th><th>名称</th><th>说明</th><th>缩写语法</th></tr></thead><tbody><tr><td>child</td><td>子节点</td><td>比自身节点深度大的一层的节点，且被包含在自身之内</td><td>默认，不需要</td></tr><tr><td>attribute</td><td>属性</td><td></td><td>@</td></tr><tr><td>descendant</td><td>子孙节点</td><td>比自身节点深度大的节点，且被包含在自身之内</td><td>不提供</td></tr><tr><td>descendant-or-self</td><td>自身引用及子孙节点</td><td></td><td>//</td></tr><tr><td>parent</td><td>父节点</td><td>比自身节点深度小一层的节点，且包含自身</td><td>..</td></tr><tr><td>ancestor</td><td>祖先节点</td><td>比自身节点深度小的节点，且包含自身</td><td>不提供</td></tr><tr><td>ancestor-or-self</td><td>自身引用及祖先节点</td><td></td><td>不提供</td></tr><tr><td>following</td><td>下文节点</td><td>按纵轴视图，在此节点后的所有完整节点，即不包含其祖先节点</td><td>不提供</td></tr><tr><td>preceding</td><td>前文节点</td><td>按纵轴视图，在此节点前的所有完整节点，即不包含其子孙节点</td><td>不提供</td></tr><tr><td>following-sibling</td><td>下一个同级节点</td><td></td><td>不提供</td></tr><tr><td>preceding-sibling</td><td>上一个同级节点</td><td></td><td>不提供</td></tr><tr><td>self</td><td>自己</td><td></td><td>.</td></tr><tr><td>namespace</td><td>名称空间</td><td></td><td>不提供</td></tr></tbody></table><blockquote></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bookstore</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">book</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">title</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;eng&quot;</span>&gt;</span>Harry Potter<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">price</span>&gt;</span>29.99<span class="hljs-tag">&lt;/<span class="hljs-name">price</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">book</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">book</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">title</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;eng&quot;</span>&gt;</span>Learning XML<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">price</span>&gt;</span>39.95<span class="hljs-tag">&lt;/<span class="hljs-name">price</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">book</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">book</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">title</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;cn&quot;</span>&gt;</span>Learning XPath<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">price</span>&gt;</span>23.33<span class="hljs-tag">&lt;/<span class="hljs-name">price</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">book</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bookstore</span>&gt;</span><br></code></pre></td></tr></table></figure><p><span></span></p><blockquote><p>案例：原轴描述语法 获取title节点  </p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">/child::bookstore/child::book/child::title<br></code></pre></td></tr></table></figure><blockquote><p>案例：缩写语法 获取title节点  </p></blockquote><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/bookstore/</span>book/title<br></code></pre></td></tr></table></figure><p><span></span></p><blockquote><p>案例：原轴描述语法 获取price节点</p></blockquote><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir">/descendant-<span class="hljs-keyword">or</span>-<span class="hljs-keyword">self</span>::price<br></code></pre></td></tr></table></figure><blockquote><p>案例：缩写语法 获取price节点</p></blockquote><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>price<br></code></pre></td></tr></table></figure><h1 id="节点测试"><a href="#节点测试" class="headerlink" title="节点测试"></a>节点测试</h1><table><thead><tr><th>格式</th><th>信息</th><th>例子</th><th>简写</th></tr></thead><tbody><tr><td>comment()</td><td>寻找XML注释节点</td><td>获取<code>&lt;!-- 注释 --&gt;</code>中的<code>注释</code></td><td></td></tr><tr><td>text()</td><td>寻找某点的文字型别</td><td>获取<code>&lt;k&gt;hello&lt;/k&gt;</code>中的<code>hello</code></td><td></td></tr><tr><td>processing-instruction()</td><td>寻找XML处理指令</td><td><code>&lt;?php echo $a; ?&gt;</code>在这个例子里，将符合processing-instruction(‘php’)会传回值</td><td></td></tr><tr><td>node()</td><td>寻找所有点</td><td><code>//node()[@lang=&quot;cn&quot;]</code>寻找属性<code>lang</code>为<code>cn</code>的节点</td><td><code>*</code></td></tr></tbody></table><h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><table><thead><tr><th>运算符</th><th>描述</th><th>实例</th><th>返回值</th></tr></thead><tbody><tr><td><code>+</code>,<code>-</code>,<code>*</code>,<code>div</code></td><td>加,减,乘,除</td><td><code>6 + 4</code></td><td>返回对应计算结果</td></tr><tr><td><code>=</code>,<code>!=</code></td><td>等于, 不等于</td><td><code>price=9.80</code></td><td>根据比较返回<code>true</code>或<code>false</code></td></tr><tr><td><code>&lt;</code>,<code>&gt;</code>,<code>&lt;=</code>,<code>&gt;=</code></td><td>小于，大于，小于等于，大于等于</td><td><code>price&lt;=9.80</code></td><td>根据比较结果返回<code>true</code>或<code>false</code></td></tr><tr><td>or</td><td>或</td><td><code>price=9.80 or price=9.70</code></td><td>如果 price 是 9.80，则返回 true，否则返回 false</td></tr><tr><td>and</td><td>与</td><td><code>price&gt;9.00 and price&lt;9.90</code></td><td>如果 price 是 9.80，则返回 true，否则返回 false</td></tr><tr><td>mod</td><td>计算除法的余数</td><td><code>5 mod 2</code></td><td>1</td></tr></tbody></table><h1 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h1><h2 id="类型转换函数"><a href="#类型转换函数" class="headerlink" title="类型转换函数"></a>类型转换函数</h2><p>string()，number()，boolean()  </p><h2 id="文字运算函数"><a href="#文字运算函数" class="headerlink" title="文字运算函数"></a>文字运算函数</h2><p>concat(), substring(), contains(), substring-before(), substring-after(), translate(), normalize-space(), string-length()  </p><h2 id="数学运算函数"><a href="#数学运算函数" class="headerlink" title="数学运算函数"></a>数学运算函数</h2><p>sum(), round(), floor(), ceiling()  </p><h2 id="节点属性取得函数"><a href="#节点属性取得函数" class="headerlink" title="节点属性取得函数"></a>节点属性取得函数</h2><p>name(), local-name(), namespace-uri()  </p><h2 id="处理上下文数据取得函数"><a href="#处理上下文数据取得函数" class="headerlink" title="处理上下文数据取得函数"></a>处理上下文数据取得函数</h2><p>position(), last()  </p><h2 id="类型转换函数-1"><a href="#类型转换函数-1" class="headerlink" title="类型转换函数"></a>类型转换函数</h2><p>string(), number(), boolean()  </p><h1 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h1><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bookstore</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">book</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">title</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;eng&quot;</span>&gt;</span>Harry Potter<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">price</span>&gt;</span>29.99<span class="hljs-tag">&lt;/<span class="hljs-name">price</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">book</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">book</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">title</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;eng&quot;</span>&gt;</span>Learning XML<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">price</span>&gt;</span>39.95<span class="hljs-tag">&lt;/<span class="hljs-name">price</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">book</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">book</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">title</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;cn&quot;</span>&gt;</span>Learning XPath<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">price</span>&gt;</span>23.33<span class="hljs-tag">&lt;/<span class="hljs-name">price</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">book</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">ticket</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">spend</span>&gt;</span>10<span class="hljs-tag">&lt;/<span class="hljs-name">spend</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">ticket</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bookstore</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>案例：后两本书总价  </p></blockquote><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">sum(<span class="hljs-regexp">/bookstore/</span>book[position()&gt;<span class="hljs-number">1</span>]<span class="hljs-regexp">/price/</span>text())<br></code></pre></td></tr></table></figure><p><span></span></p><blockquote><p>案例：英文书总价  </p></blockquote><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">sum(<span class="hljs-regexp">//</span>title[@lang=<span class="hljs-string">&quot;eng&quot;</span>]<span class="hljs-regexp">/../</span>price/text())<br></code></pre></td></tr></table></figure><p><span></span></p><blockquote><p>案例：学习书籍的总价  </p></blockquote><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">sum(<span class="hljs-regexp">//</span>title[contains(text(), <span class="hljs-string">&quot;Learn&quot;</span>)]<span class="hljs-regexp">/../</span>price/text())<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>xpath</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python-tqdm-进度条</title>
    <link href="/post/3162fa98/"/>
    <url>/post/3162fa98/</url>
    
    <content type="html"><![CDATA[<h1 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h1><p><code>python</code>可以使用的一个进度条<br>github/文档：<a href="https://github.com/tqdm/tqdm">https://github.com/tqdm/tqdm</a>  </p><h1 id="基础使用"><a href="#基础使用" class="headerlink" title="基础使用"></a>基础使用</h1><h2 id="tqdm-tqdm"><a href="#tqdm-tqdm" class="headerlink" title="tqdm.tqdm"></a>tqdm.tqdm</h2><p>使用之前先将<code>tqdm</code>导入进来  </p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">from</span> tqdm <span class="hljs-keyword">import</span> tqdm<br></code></pre></td></tr></table></figure><h3 id="基于可迭代对象使用"><a href="#基于可迭代对象使用" class="headerlink" title="基于可迭代对象使用"></a>基于可迭代对象使用</h3><blockquote><p>案例 1  </p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> tqdm(<span class="hljs-built_in">range</span>(<span class="hljs-number">10000</span>)):<br>    ...<br></code></pre></td></tr></table></figure><blockquote><p>显示结果</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">76%</span><span class="bash">|████████████████████████        | 7568/10000 [00:33&lt;00:10, 229.00it/s]</span><br></code></pre></td></tr></table></figure><br>>案例 2  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> tqdm <span class="hljs-keyword">import</span> tqdm<br><span class="hljs-keyword">from</span> time <span class="hljs-keyword">import</span> sleep<br><br>text = <span class="hljs-string">&quot;&quot;</span><br><span class="hljs-keyword">for</span> char <span class="hljs-keyword">in</span> tqdm([<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-string">&quot;d&quot;</span>]):<br>    sleep(<span class="hljs-number">0.25</span>)<br>    text = text + char<br></code></pre></td></tr></table></figure>`tqdm.tqdm()`会接收一个可迭代的对象，通过`len()`计算它的长度来实现进度条的效果  只要满足这两个条件，就能塞东西进去显示进度条  <h3 id="基于数值使用"><a href="#基于数值使用" class="headerlink" title="基于数值使用"></a>基于数值使用</h3><p>并非所有对象都可以进行迭代<br>在遇到不能迭代的内容时，可以使用预先设置数值来进行进度条的计算  </p><blockquote><p>案例 1</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">pbar = tqdm(total=<span class="hljs-number">100</span>)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):<br>    sleep(<span class="hljs-number">0.1</span>)<br>    pbar.update(<span class="hljs-number">10</span>)<br>pbar.close()<br></code></pre></td></tr></table></figure><blockquote><p>案例 2</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">with</span> tqdm(total=<span class="hljs-number">100</span>) <span class="hljs-keyword">as</span> pbar:<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):<br>        sleep(<span class="hljs-number">0.1</span>)<br>        pbar.update(<span class="hljs-number">10</span>)<br></code></pre></td></tr></table></figure><h1 id="tqdm详细"><a href="#tqdm详细" class="headerlink" title="tqdm详细"></a>tqdm详细</h1><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs routeros">class tqdm():<br>  <span class="hljs-string">&quot;&quot;</span><span class="hljs-string">&quot;</span><br><span class="hljs-string">  装饰一个可迭代的对象，返回一个迭代器。迭代器返回的对象与原本一致，但是会更新进度条信息  </span><br><span class="hljs-string">  &quot;</span><span class="hljs-string">&quot;&quot;</span><br><br>  def __init__(self, <span class="hljs-attribute">iterable</span>=None, <span class="hljs-attribute">desc</span>=None, <span class="hljs-attribute">total</span>=None, <span class="hljs-attribute">leave</span>=<span class="hljs-literal">True</span>,<br>               <span class="hljs-attribute">file</span>=None, <span class="hljs-attribute">ncols</span>=None, <span class="hljs-attribute">mininterval</span>=0.1,<br>               <span class="hljs-attribute">maxinterval</span>=10.0, <span class="hljs-attribute">miniters</span>=None, <span class="hljs-attribute">ascii</span>=None, <span class="hljs-attribute">disable</span>=<span class="hljs-literal">False</span>,<br>               <span class="hljs-attribute">unit</span>=<span class="hljs-string">&#x27;it&#x27;</span>, <span class="hljs-attribute">unit_scale</span>=<span class="hljs-literal">False</span>, <span class="hljs-attribute">dynamic_ncols</span>=<span class="hljs-literal">False</span>,<br>               <span class="hljs-attribute">smoothing</span>=0.3, <span class="hljs-attribute">bar_format</span>=None, <span class="hljs-attribute">initial</span>=0, <span class="hljs-attribute">position</span>=None,<br>               <span class="hljs-attribute">postfix</span>=None, <span class="hljs-attribute">unit_divisor</span>=1000):<br></code></pre></td></tr></table></figure><table><thead><tr><th>参数名</th><th>值类型</th><th>参数类型</th><th>描述</th></tr></thead><tbody><tr><td>iterable</td><td>iterable</td><td>可选</td><td>一个被装饰的可迭代对象</td></tr><tr><td>desc</td><td>str</td><td>可选</td><td>进度条前缀描述</td></tr><tr><td>total</td><td>int / float</td><td>可选</td><td>预期的迭代次数。<br>如未指定，则使用len(iterable)获取</td></tr><tr><td>leave</td><td>bool</td><td>可选</td><td>默认为True<br>是否不在迭代迭代结束后将进度条消除掉</td></tr><tr><td>file</td><td><code>io.TextIOWrapper</code>/<code>io.StringIO</code></td><td>可选</td><td>指定输出流，使用<code>file.write(str)</code>和<code>file.flush()</code>实现</td></tr><tr><td>ncols</td><td>int</td><td>可选</td><td>进度条宽度</td></tr><tr><td>mininterval</td><td>float</td><td>可选</td><td>进度条最小进度更新时间间隔，默认值：0.1秒</td></tr><tr><td>maxinterval</td><td>float</td><td>可选</td><td>进度条最大进度更新时间间隔，默认10秒</td></tr><tr><td>miniters</td><td>int / float</td><td>可选</td><td>最小进度显示更新值</td></tr><tr><td>ascii</td><td>bool / str</td><td>可选</td><td>如果未指定或为<code>False</code>，则会用<code>unicode</code>平滑块符号 填充仪表</td></tr><tr><td>disable</td><td>bool</td><td>可选</td><td>是否禁用</td></tr><tr><td>unit</td><td>str</td><td>可选</td><td>进度条单位</td></tr><tr><td>unit_scale</td><td>bool / int / float</td><td>可选</td><td>如果为1或True，则迭代次数将自动减少/缩放。比如<code>bit</code>转<code>kb</code>。默认值：False</td></tr><tr><td>dynamic_ncols</td><td>bool</td><td>可选</td><td>进度条长度动态适应窗口大小。默认值：False</td></tr><tr><td>smoothing</td><td>float</td><td>可选</td><td>速度估计的平滑因子<br>范围从0（平均速度）到1（当前/瞬时速度）。默认值：0.3</td></tr><tr><td>bar_format</td><td>str</td><td>可选</td><td>进度条显示形式，由于是不断刷新的，会影响机器性能<br>默认值：’{l_bar} {bar} {r_bar}’</td></tr><tr><td>initial</td><td>int / float</td><td>可选</td><td>进度条初始值</td></tr><tr><td>position</td><td>int</td><td>可选</td><td>指定进度条显示偏移量（从0开始）。如果未指定，则为自动设置。<br>在你想要显示多个进度条的时候，它会帮到你的</td></tr><tr><td>postfix</td><td>dict / <code>*</code></td><td>可选</td><td>指定显示在进度条末尾的其他统计信息</td></tr><tr><td>unit_divisor</td><td>float</td><td>可选</td><td></td></tr><tr><td>write_bytes</td><td>bool</td><td>可选</td><td></td></tr><tr><td>lock_args</td><td>tuple</td><td>可选</td><td></td></tr><tr><td>nrows</td><td>int</td><td>可选</td><td>如果指定，则在此边界之外隐藏嵌套的条。 如果未指定，请尝试使用环境高度。</td></tr><tr><td>colour</td><td>str</td><td>可选项</td><td>进度条颜色</td></tr></tbody></table>]]></content>
    
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>tqdm</tag>
      
      <tag>进度条</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux-進程查看</title>
    <link href="/post/b5bd8d04/"/>
    <url>/post/b5bd8d04/</url>
    
    <content type="html"><![CDATA[<h1 id="ps-命令"><a href="#ps-命令" class="headerlink" title="ps 命令"></a>ps 命令</h1><p>ps(process status) 命令是 Linux 下最常用的进程查看工具，使用该命令可以确定哪些进程正在运行和运行的状态、</p><p>进程是否结束、进程有没有僵尸、哪些进程占用了过多的资源等等  </p><blockquote><p>注意：ps 命令工具显示的是进程的瞬间状态，并不是动态连续显示，如果想对进程状态进行实时监控应该用 top 命令  </p></blockquote><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p>不添加任何參數时，只显示当前用户会话中打开的进程  </p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ps<br></code></pre></td></tr></table></figure><p><img src="/Linux-%E9%80%B2%E7%A8%8B%E6%9F%A5%E7%9C%8B/20201011050930863.png">  </p></blockquote><ul><li>PID：表示该进程的唯一 ID 号  </li><li>TTY 或 TT：启动进程的终端名。表示该进程在哪个终端上运行  </li><li>TIME：该进程使用 CPU 的累计时间  </li><li>CMD：该进程所运行的命令  </li></ul><h2 id="e显示全部进程的信息"><a href="#e显示全部进程的信息" class="headerlink" title="e显示全部进程的信息"></a><code>e</code>显示全部进程的信息</h2><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ps e<br></code></pre></td></tr></table></figure><p><img src="/Linux-%E9%80%B2%E7%A8%8B%E6%9F%A5%E7%9C%8B/20201011081257947.png"></p></blockquote><p>结果和上面的类似，但是显示的进程会多一些  </p><ul><li>COMMAND：执行原因（命令）  </li><li>STAT：表示进程的当前状态  <ul><li>R：running，运行或可运行状态（在运行队列中）。正在运行或准备运行的进程。</li><li>S：interruptable sleeping，可中断睡眠（等待事件完成）。正在睡眠的进程。</li><li>D：uninterruptable sleeping，不可中断的睡眠进程（通常为IO）。</li><li>T：stopped，停止或被追踪的进程。由作业控制信号停止。</li><li>Z：zombie，失败终止的（“僵死”）进程。</li><li>s：session leader，会话层状态。代表的父进程</li><li>N：低优先级进程</li><li>&lt;：高优先级进程</li><li>+：前台进程。在前台进程组中</li><li>l：多线程进程。</li></ul></li></ul><h2 id="f显示完整信息"><a href="#f显示完整信息" class="headerlink" title="f显示完整信息"></a><code>f</code>显示完整信息</h2><blockquote><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">ps f</span><br></code></pre></td></tr></table></figure><p><img src="/Linux-%E9%80%B2%E7%A8%8B%E6%9F%A5%E7%9C%8B/20201011081444591.png"></p></blockquote><p>除了基本命令本身就有的信息项以外，还会显示更多的信息  </p><ul><li>UID：启动该进程的用户的 ID 号  </li><li>PPID：代表该进程的父进程的 ID 号  </li><li>C：进程的 CPU 处理器利用率  </li><li>STIME/START：表示进程的启动时间  </li></ul><h2 id="a显示当前终端所有进程信息"><a href="#a显示当前终端所有进程信息" class="headerlink" title="a显示当前终端所有进程信息"></a><code>a</code>显示当前终端所有进程信息</h2><p>显示当前终端下的所有进程信息，包含其他用户的进程信息  </p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ps a<br></code></pre></td></tr></table></figure><p><img src="/Linux-%E9%80%B2%E7%A8%8B%E6%9F%A5%E7%9C%8B/20201011083539734.png">  </p></blockquote><h2 id="x显示当前用户在所有终端下的进程信息"><a href="#x显示当前用户在所有终端下的进程信息" class="headerlink" title="x显示当前用户在所有终端下的进程信息"></a><code>x</code>显示当前用户在所有终端下的进程信息</h2><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ps x<br></code></pre></td></tr></table></figure><p><img src="/Linux-%E9%80%B2%E7%A8%8B%E6%9F%A5%E7%9C%8B/20201011084553974.png">  </p></blockquote><h2 id="u以面向用户的格式显示当前终端下的所有信息"><a href="#u以面向用户的格式显示当前终端下的所有信息" class="headerlink" title="u以面向用户的格式显示当前终端下的所有信息"></a><code>u</code>以面向用户的格式显示当前终端下的所有信息</h2><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ps u<br></code></pre></td></tr></table></figure><p><img src="/Linux-%E9%80%B2%E7%A8%8B%E6%9F%A5%E7%9C%8B/20201011084827077.png">  </p></blockquote><ul><li>USER：启动该进程的用户帐号名称  </li><li>%CPU：表示进程的 CPU 占用率  </li><li>%MEM：表示进程的内存占用率  </li><li>VSZ：表示进程虚拟内存的大小，以 KB 为单位  </li></ul><h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><ul><li><code>ps -ef</code><br>查看所有进程  </li><li><code>ps aux</code><br>以面向用户的格式显示当前终端下的所有信息  </li></ul><h1 id="更多操作"><a href="#更多操作" class="headerlink" title="更多操作"></a>更多操作</h1><h2 id="sort排序"><a href="#sort排序" class="headerlink" title="--sort排序"></a><code>--sort</code>排序</h2><p>对指定的项目输入即可得到根据项目排序后得到的结果  </p><blockquote><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dos">ps <span class="hljs-built_in">aux</span> --<span class="hljs-built_in">sort</span>=%mem<br></code></pre></td></tr></table></figure><p><img src="/Linux-%E9%80%B2%E7%A8%8B%E6%9F%A5%E7%9C%8B/20201011090057738.png">  </p></blockquote><h2 id="grep过滤"><a href="#grep过滤" class="headerlink" title="grep过滤"></a><code>grep</code>过滤</h2><p>过滤调不符合条件的内容，只显示指定的内容  </p><blockquote><p>只显示SSH的进程  </p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">ps</span> -ef |<span class="hljs-keyword">grep</span> sshd<br></code></pre></td></tr></table></figure><p><img src="/Linux-%E9%80%B2%E7%A8%8B%E6%9F%A5%E7%9C%8B/20201011090803012.png">  </p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python-logging-日志</title>
    <link href="/post/6c246ae5/"/>
    <url>/post/6c246ae5/</url>
    
    <content type="html"><![CDATA[<h1 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h1><p>日志是跟踪软件运行时所发生的事件的一种方法<br>软件开发者在代码中调用日志函数，表明发生了特定的事件  </p><p><code>logging</code>可以很好的代替<code>print</code>功能，并且更加方便管理  </p><h1 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h1><p><code>logging</code>是<code>python</code>自带的日志模块，一般不需要额外安装<br>需要使用日志前<code>import</code>即可  </p><blockquote><p>案例：Hello World</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> logging<br>logging.info(<span class="hljs-string">&#x27;Hello World&#x27;</span>)<br></code></pre></td></tr></table></figure><blockquote><p>这是一个简单的<code>logging</code>使用的例子<br>这里用<code>logging</code>记录了<code>Hello World</code>这个信息  </p></blockquote><p>如果没有特别设置，这个信息默认会输出到控制台上。并且附带一些诸如时间之类的额外的信息  </p><h2 id="日志等级"><a href="#日志等级" class="headerlink" title="日志等级"></a>日志等级</h2><p><code>logging</code>的日志有六个等级  </p><table><thead><tr><th>等级</th><th>NOTSET</th><th>DEBUG</th><th>INFO</th><th>WARNING(默认)</th><th>ERROR</th><th>CRITICAL</th></tr></thead><tbody><tr><td>数值</td><td>0</td><td>10</td><td>20</td><td>30</td><td>40</td><td>50</td></tr><tr><td>信息</td><td>提示</td><td>调试信息<br>只在调试问题时使用</td><td>信息<br>事情按预期工作</td><td>警告<br>没有预料到的事件提示</td><td>错误<br>软件不能执行一些功能</td><td>严重错误<br>软件已不能继续运行</td></tr></tbody></table><p>你可以在代码需要的位置记录不同等级的日志  </p><blockquote><p>案例：记录不同级别的日志  </p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> logging<br>logging.debug(<span class="hljs-string">&#x27;debug 信息&#x27;</span>)<br>logging.info(<span class="hljs-string">&#x27;info 信息&#x27;</span>)<br>logging.warning(<span class="hljs-string">&#x27;warning 信息&#x27;</span>)<br>logging.error(<span class="hljs-string">&#x27;error 信息&#x27;</span>)<br>logging.critical(<span class="hljs-string">&#x27;critial 信息&#x27;</span>)<br></code></pre></td></tr></table></figure><p>可以在使用前,用<code>logging.basicConfig</code>规定日志的输出等级(上面说过的等级都有)<br>低于规定等级的日志，在程序运行过程中不会记录  </p><blockquote><p>案例：指定输出日志等级  </p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> logging<br>logging.basicConfig(level=logging.INFO)<br>logging.debug(<span class="hljs-string">&#x27;debug 信息&#x27;</span>)<br>logging.error(<span class="hljs-string">&#x27;error 信息&#x27;</span>)<br></code></pre></td></tr></table></figure><h2 id="文件日志"><a href="#文件日志" class="headerlink" title="文件日志"></a>文件日志</h2><p>可以在使用前,用<code>logging.basicConfig</code>规定日志的输出文件与输出方式  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">logging.basicConfig(<br>    filename=<span class="hljs-string">&#x27;new.log&#x27;</span>,  <span class="hljs-comment"># 日志文件文件路径</span><br>    filemode=<span class="hljs-string">&#x27;a&#x27;</span>  <span class="hljs-comment"># 记录模式，可填入&#x27;a&#x27;或&#x27;w&#x27;,与`open`函数的对应参数效果一致</span><br>)<br></code></pre></td></tr></table></figure><ul><li>filename<br>日志文件文件路径  </li><li>filemode<br>记录模式，可填入’a’或’w’,与<code>open</code>函数的对应参数效果一致  (即’w’为覆盖，’a’为增量)</li></ul><h2 id="日志格式"><a href="#日志格式" class="headerlink" title="日志格式"></a>日志格式</h2><p>日志中的信息除了基本写在程序中的信息以外，还包括了一些附属的信息（时间，级别，模块名……）<br>设置日志记录的格式结构，可以让记录更加精简或更加详细  </p><p>可以在使用前,用<code>logging.basicConfig</code>规定日志格式  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">logging.basicConfig(<br>    <span class="hljs-built_in">format</span>=<span class="hljs-string">&#x27;%(asctime)s - %(pathname)s[line:%(lineno)d] - %(levelname)s: %(message)s&#x27;</span><br>)<br></code></pre></td></tr></table></figure><h3 id="格式参数参考"><a href="#格式参数参考" class="headerlink" title="格式参数参考"></a>格式参数参考</h3><table><thead><tr><th>日志内容</th><th>信息</th></tr></thead><tbody><tr><td>%(name)s</td><td>Logger的名字</td></tr><tr><td>%(levelno)s</td><td>数字形式的日志级别</td></tr><tr><td>%(levelname)s</td><td>文本形式的日志级别</td></tr><tr><td>%(pathname)s</td><td>调用日志输出函数的模块的完整路径名，可能没有</td></tr><tr><td>%(filename)s</td><td>调用日志输出函数的模块的文件名</td></tr><tr><td>%(module)s</td><td>调用日志输出函数的模块名</td></tr><tr><td>%(funcName)s</td><td>调用日志输出函数的函数名</td></tr><tr><td>%(lineno)d</td><td>调用日志输出函数的语句所在的代码行</td></tr><tr><td>%(created)f</td><td>当前时间，用UNIX标准的表示时间的浮 点数表示</td></tr><tr><td>%(relativeCreated)d</td><td>输出日志信息时的，自Logger创建以 来的毫秒数</td></tr><tr><td>%(asctime)s</td><td>字符串形式的当前时间。默认格式：”%Y-%m-%d %H:%M:%S”<br>效果：“2003-07-08 16:49:45,896”。逗号后面的是毫秒</td></tr><tr><td>%(thread)d</td><td>线程ID。可能没有</td></tr><tr><td>%(threadName)s</td><td>线程名。可能没有</td></tr><tr><td>%(process)d</td><td>进程ID。可能没有</td></tr><tr><td>%(message)s</td><td>用户输出的消息</td></tr></tbody></table>]]></content>
    
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>logging</tag>
      
      <tag>日志</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Scrapy-基础-url拼接</title>
    <link href="/post/296cbee9/"/>
    <url>/post/296cbee9/</url>
    
    <content type="html"><![CDATA[<h1 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h1><p>爬虫过程中，url拼接的问题几乎是100%会碰到的<br>你当然可以使用字符串并接的方式删删拼拼达到目的，但那样做显得很麻瓜。而且，由于<code>&lt;a&gt;</code>的<code>@href</code>和<code>&lt;img&gt;</code>的<code>@src</code>呈现出来的内容的不同，可能每一个url都要区别对待<br>实际上，倒是有一些函数能帮忙做这些事情  </p><h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><h2 id="基本字符串拼接"><a href="#基本字符串拼接" class="headerlink" title="基本字符串拼接"></a>基本字符串拼接</h2><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">url</span> = <span class="hljs-string">&#x27;https://www.a.com&#x27;</span> + <span class="hljs-string">&#x27;/index.html&#x27;</span><br><span class="hljs-attr">url</span> = <span class="hljs-string">&#x27;https://www.a.com/index.html&#x27;</span>[:<span class="hljs-number">11</span>] + <span class="hljs-string">&#x27;/1_1.html&#x27;</span><br></code></pre></td></tr></table></figure><p>最多最多就是把<code>host</code>拿来用一下减轻一些观感上的压力，但实际上就是很麻烦  </p><h2 id="response-joinurl"><a href="#response-joinurl" class="headerlink" title="response.joinurl"></a>response.joinurl</h2><p><code>scrapy</code>的解析函数参数<code>response</code>的函数<code>joinurl</code>能够很轻松的处理<code>url</code>拼接问题  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">a_href = <span class="hljs-string">&#x27;/a/1.html&#x27;</span><br>url = response.urljoin(a_href)<br></code></pre></td></tr></table></figure><h2 id="response-follow"><a href="#response-follow" class="headerlink" title="response.follow"></a>response.follow</h2><p>此函数用于直接对新的<code>url</code>发起请求，它会计算新的<code>url</code>来访问  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">a_href = <span class="hljs-string">&#x27;/a/1.html&#x27;</span><br><span class="hljs-keyword">yield</span> response.follow(a_href, callback=self.parse)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Scrapy</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python-单例模式</title>
    <link href="/post/c7d0c491/"/>
    <url>/post/c7d0c491/</url>
    
    <content type="html"><![CDATA[<h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><p>单例模式（Singleton Pattern）是一种常用的软件设计模式，该模式的主要目的是确保某一个类只有一个实例存在<br>当你希望在整个系统中，某个类只能出现一个实例时，单例对象就能派上用场  </p><blockquote><p>在那些需要“创建连接”的内容中使用能节约很多资源  </p></blockquote><h1 id="Python实现方式"><a href="#Python实现方式" class="headerlink" title="Python实现方式"></a>Python实现方式</h1><h2 id="模块方式"><a href="#模块方式" class="headerlink" title="模块方式"></a>模块方式</h2><p>其实，<code>Python</code> 的模块就是天然的单例模式<br>因为模块在第一次导入时，会生成<code>.pyc</code>文件，当第二次导入时，就会直接加载<code>.pyc</code>文件，而不会再次执行模块代码<br>因此，只需把相关的函数和数据定义在一个模块中，就可以获得一个单例对象了  </p><blockquote><p>例：</p></blockquote><figure class="highlight python"><figcaption><span>single.py</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">pass</span><br>single = Singleton()<br></code></pre></td></tr></table></figure><blockquote><p>直接在其他文件中导入此文件中的对象<code>single</code>，这个对象即是单例模式的对象  </p></blockquote><figure class="highlight python"><figcaption><span>a.py</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> demo.my_singleton <span class="hljs-keyword">import</span> single<br> <br>single.foo()<br></code></pre></td></tr></table></figure><h2 id="装饰器方式"><a href="#装饰器方式" class="headerlink" title="装饰器方式"></a>装饰器方式</h2><h3 id="函数装饰器"><a href="#函数装饰器" class="headerlink" title="函数装饰器"></a>函数装饰器</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">singleton</span>(<span class="hljs-params">cls</span>):</span><br>    _instance = &#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">inner</span>():</span><br>        <span class="hljs-keyword">if</span> cls <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> _instance:<br>            _instance[cls] = cls()<br>        <span class="hljs-keyword">return</span> _instance[cls]<br>    <span class="hljs-keyword">return</span> inner<br>    <br><span class="hljs-meta">@singleton</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cls</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">pass</span><br><br>cls1, cls2 = Cls(), Cls()<br>print(<span class="hljs-built_in">id</span>(cls1) == <span class="hljs-built_in">id</span>(cls2))<br></code></pre></td></tr></table></figure><blockquote><ul><li>id函数可以查看对象在内存中的位置  </li><li>使用这个方式创建对象时，会访问singleton函数<br>实际上，由于装饰器的应用，<code>Cls</code>返回的结果也变成了函数  </li></ul></blockquote><p>函数会查看想要创建实例的类是否在字典中已经有记录，要是有记录就直接返回记录中的对象  </p><h3 id="类装饰器"><a href="#类装饰器" class="headerlink" title="类装饰器"></a>类装饰器</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    _INSTANCE = &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, cls</span>):</span><br>        self.cls = cls   <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__call__</span>(<span class="hljs-params">self, *args, **kwargs</span>):</span><br>        instance = self._INSTANCE.get(self.cls, <span class="hljs-literal">None</span>)<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> instance:<br>            instance = self.cls(*args, **kwargs)<br>            self._INSTANCE[self.cls] = instance<br>        <span class="hljs-keyword">return</span> instance  <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__getattr__</span>(<span class="hljs-params">self, key</span>):</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">getattr</span>(self.cls, key, <span class="hljs-literal">None</span>)<br><span class="hljs-meta">@Singleton</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">my_cls</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-keyword">pass</span><br><br>cls1, cls2 = Cls2(), Cls2()<br>print(<span class="hljs-built_in">id</span>(cls1) == <span class="hljs-built_in">id</span>(cls2))<br></code></pre></td></tr></table></figure><p>虽然和函数装饰器看上去并不一样，但实际上原理是一样的  </p><h2 id="类方式"><a href="#类方式" class="headerlink" title="类方式"></a>类方式</h2><h3 id="使用属性（不要在多线程环境使用）"><a href="#使用属性（不要在多线程环境使用）" class="headerlink" title="使用属性（不要在多线程环境使用）"></a>使用属性（不要在多线程环境使用）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    __instance = <span class="hljs-literal">None</span><br> <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, x</span>):</span><br>        self.x = x<br>        print(x)<br>        time.sleep(<span class="hljs-number">1</span>)  <span class="hljs-comment"># 加入干扰元素，造成多线程出现问题</span><br> <br><span class="hljs-meta">    @classmethod</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">my_singleton</span>(<span class="hljs-params">cls, *args, **kwargs</span>):</span><br>        <span class="hljs-keyword">with</span> cls.__instance_lock:  <span class="hljs-comment"># 加锁</span><br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> cls.__instance:<br>                cls.__instance = cls(*args, **kwargs)<br>        <span class="hljs-keyword">return</span> cls.__instance<br></code></pre></td></tr></table></figure><p>这种方式如果不加锁，在多线程环境使用的时候会出现失效的情况  </p><blockquote><p>过程很容易想象，假设现在有A，B两个线程  </p></blockquote><ol><li>A <code>if not cls.__instance:</code>判断为真  </li><li>B <code>if not cls.__instance:</code>判断为真  </li><li>B <code>cls.__instance = cls(*args, **kwargs)</code>初始化了一遍实例  </li><li>A <code>cls.__instance = cls(*args, **kwargs)</code>初始化了两遍实例  </li></ol><p>这种方式仅在单线程情况下推荐使用<br>多线程模式中不推荐使用，加锁会明显的降低性能  </p><h3 id="使用-new"><a href="#使用-new" class="headerlink" title="使用__new__"></a>使用<code>__new__</code></h3><p>当我们实例化一个对象时，是先执行了类的<code>__new__</code>方法实例化对象；然后再执行类的<code>__init__</code>方法，对这个对象进行初始化  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> threading<br> <br> <br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    _instance_lock = threading.Lock()<br> <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, x</span>):</span><br>        self.x = x<br>        <span class="hljs-keyword">import</span> time<br>        time.sleep(<span class="hljs-number">1</span>)  <span class="hljs-comment"># 加入干扰元素，造成多线程出现问题</span><br> <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__new__</span>(<span class="hljs-params">cls, *args, **kwargs</span>):</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">hasattr</span>(cls, <span class="hljs-string">&#x27;_instance&#x27;</span>):<br>            <span class="hljs-keyword">with</span> cls._instance_lock:  <span class="hljs-comment"># 加锁</span><br>                cls._instance = <span class="hljs-built_in">super</span>(Singleton, cls).__new__(cls)<br>        <span class="hljs-keyword">return</span> cls._instance<br></code></pre></td></tr></table></figure><h3 id="元类方式"><a href="#元类方式" class="headerlink" title="元类方式"></a>元类方式</h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">class</span> <span class="hljs-constructor">Singleton(<span class="hljs-params">type</span>)</span>:<br>    def <span class="hljs-constructor">__init__(<span class="hljs-params">cls</span>, <span class="hljs-params">name</span>, <span class="hljs-params">bases</span>, <span class="hljs-params">dic</span>)</span>:<br>        super(Singleton, cls).<span class="hljs-constructor">__init__(<span class="hljs-params">name</span>, <span class="hljs-params">bases</span>, <span class="hljs-params">dic</span>)</span><br>        cls._instance = None<br>    def <span class="hljs-constructor">__call__(<span class="hljs-params">cls</span>, <span class="hljs-operator">*</span><span class="hljs-params">args</span>, <span class="hljs-operator">**</span><span class="hljs-params">kwargs</span>)</span>:<br>        <span class="hljs-keyword">if</span> cls._instance is None:<br>            cls._instance = super(Singleton, cls).<span class="hljs-constructor">__call__(<span class="hljs-operator">*</span><span class="hljs-params">args</span>, <span class="hljs-operator">**</span><span class="hljs-params">kwargs</span>)</span><br>            # cls._instance = cls(*args, **kwargs)  # Error! Lead <span class="hljs-keyword">to</span> call this <span class="hljs-keyword">function</span> recursively<br>        return cls._instance<br> <br><span class="hljs-keyword">class</span> my<span class="hljs-constructor">_cls(<span class="hljs-params">object</span>)</span>:<br>    __metaclass__ = Singleton<br></code></pre></td></tr></table></figure><p>这个例子中我们使用元类<code>Singleton</code>替代默认使用<code>type</code>方式创建类<code>my_cls</code><br>可以将类<code>my_cls</code>看做是元类<code>Singleton</code>的一个对象，当我们使用<code>my_cls(...)</code>的方式创建类<code>my_cls</code>的对象时，实际上是在调用元类<code>Singleton</code>的对象<code>my_cls</code>  </p><p>对象可以以函数的方式被调用，那么要求类中定义<code>__call__</code>函数。不过此处被调用的是类，因此我们在元类中定义函数<code>__call__</code>来控制类<code>my_cls</code>对象创建的唯一性  </p><p>这种方式的弊端之一就是类唯一的对象被存放在类的一个静态数据成员中，外部可以通过<code>class_name._instance</code>的方式修改甚至删除这个实例(该例中<code>my_cls._instance = None</code>完全合法)  </p>]]></content>
    
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>设计模式</tag>
      
      <tag>单例模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git-.gitignore-忽略指定文件的版本控制</title>
    <link href="/post/f44b67ee/"/>
    <url>/post/f44b67ee/</url>
    
    <content type="html"><![CDATA[<h1 id="gitignore文件"><a href="#gitignore文件" class="headerlink" title=".gitignore文件"></a>.gitignore文件</h1><p>并不是所有的文件都需要版本控制，程序运行产生的编译的中间文件，日志文件，等等都是不需要版本控制的  </p><p>编写在git的目录创建一个<code>.ignore</code>文件，编写指定的忽略规则就能让git忽略指定的文件或者文件夹，让管理更方便  </p><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><ol><li><p>创建.gitignore文件<br>如果此文件是在项目<code>push</code>之后创建，那么需要进行一些操作才能让这个文件正常工作  </p><blockquote><p>注意！！！<br>在代码提交以后再进行此操作，要不然会丢失进度<br><span></span></p></blockquote> <figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">git rm -r --cached .<br>git <span class="hljs-keyword">add</span><span class="bash"> .</span><br></code></pre></td></tr></table></figure><p> stackoverflow：<a href="https://stackoverflow.com/questions/1139762/ignore-files-that-have-already-been-committed-to-a-git-repository">如何在push后创建.gitignore并使它生效</a></p></li><li><p>编写忽略规则  </p></li></ol><table><thead><tr><th>规则案例</th><th>说明</th></tr></thead><tbody><tr><td><code>.a</code></td><td>忽略所有 <code>.a</code> 结尾的文件</td></tr><tr><td><code>/TODO</code></td><td>仅仅忽略项目根目录下的 <code>TODO</code> 文件</td></tr><tr><td><code>build/</code></td><td>忽略 <code>build/</code> 目录下的所有文件</td></tr><tr><td><code>doc/\*.txt</code></td><td>忽略 <code>doc</code>文件夹下的<code>txt</code>文件</td></tr><tr><td><code>*.class</code></td><td>忽略所有后缀为<code>.class</code>的文件</td></tr><tr><td><code>**/__pycache__</code></td><td>忽略所有<code>__pycache__</code>子文件夹</td></tr></tbody></table><blockquote><p>案例：我的VScode python项目的.ignore案例  </p><p>~~~<br>.vscode/<br>models/<strong>pycache</strong><br>old/~~~<br>忽略了根目录下的.vscode配置文件夹<br>忽略了models/__pycache__文件夹<br>忽略了根目录下的old文件夹</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Javascript-Hook-脚本</title>
    <link href="/post/a88eb1a7/"/>
    <url>/post/a88eb1a7/</url>
    
    <content type="html"><![CDATA[<h1 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h1><p>自行编写或者收集到的<code>Hook</code>脚本代码  </p><h1 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h1><h2 id="webpack-hook-半自动扣"><a href="#webpack-hook-半自动扣" class="headerlink" title="webpack hook 半自动扣"></a>webpack hook 半自动扣</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 在加载器后面下断点  执行下面代码</span><br><span class="hljs-comment">// 这里的f 替换成需要导出的函数名</span><br><span class="hljs-built_in">window</span>.zhiyuan = f;<br><span class="hljs-built_in">window</span>.wbpk_ = <span class="hljs-string">&quot;&quot;</span>;<br><span class="hljs-built_in">window</span>.isz = <span class="hljs-literal">false</span>;<br>f = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">r</span>)</span>&#123;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">window</span>.isz)<br>&#123;<br>                <span class="hljs-comment">// e[r]里的e 是加载器里的call那里</span><br><span class="hljs-built_in">window</span>.wbpk_ = <span class="hljs-built_in">window</span>.wbpk_ + r.toString()+<span class="hljs-string">&quot;:&quot;</span>+(e[r]+<span class="hljs-string">&quot;&quot;</span>)+ <span class="hljs-string">&quot;,&quot;</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">window</span>.zhiyuan(r);<br>&#125;<br></code></pre></td></tr></table></figure><p>在你要的方法加载前下断点 执行<code>window.isz=true</code><br>在你要的方法运行后代码处下断点  执行<code>window.wbpk_</code> 拿到所有代码  注意后面有个逗号</p><h2 id="请求hook"><a href="#请求hook" class="headerlink" title="请求hook"></a>请求hook</h2><p>当请求的url里包含<code>MmEwMD</code>时，则插入断点  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> code = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br><span class="hljs-keyword">var</span> open = <span class="hljs-built_in">window</span>.XMLHttpRequest.prototype.open;<br><span class="hljs-built_in">window</span>.XMLHttpRequest.prototype.open = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">method, url, <span class="hljs-keyword">async</span></span>)</span>&#123;<br>    <span class="hljs-keyword">if</span> (url.indexOf(<span class="hljs-string">&quot;MmEwMD&quot;</span>)&gt;-<span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-keyword">debugger</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> open.apply(<span class="hljs-built_in">this</span>, <span class="hljs-built_in">arguments</span>);<br>&#125;;<br>&#125;<br><span class="hljs-keyword">var</span> script = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;script&#x27;</span>);<br>script.textContent = <span class="hljs-string">&#x27;(&#x27;</span> + code + <span class="hljs-string">&#x27;)()&#x27;</span>;<br>(<span class="hljs-built_in">document</span>.head||<span class="hljs-built_in">document</span>.documentElement).appendChild(script);<br>script.parentNode.removeChild(script);<br></code></pre></td></tr></table></figure><h2 id="docuemnt-getElementById-以及value属性的hook"><a href="#docuemnt-getElementById-以及value属性的hook" class="headerlink" title="docuemnt.getElementById 以及value属性的hook"></a>docuemnt.getElementById 以及value属性的hook</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// docuemnt.getElementById 以及value属性的hook,可以参考完成innerHTML的hook</span><br><span class="hljs-built_in">document</span>.getElementById = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">id</span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> value = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;#&#x27;</span> + id).value;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;DOM操作 id: &#x27;</span>, id)<br>    <span class="hljs-keyword">try</span> &#123;<br><br>        <span class="hljs-built_in">Object</span>.defineProperty(<span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;#&#x27;</span>+ id), <span class="hljs-string">&#x27;value&#x27;</span>, &#123;<br>            get: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>                <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;getting -&#x27;</span>, id, <span class="hljs-string">&#x27;value -&#x27;</span>, value);<br>                <span class="hljs-keyword">return</span> value;<br>            &#125;,<br>            set: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">val</span>) </span>&#123;<br>                <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;setting -&#x27;</span>, id, <span class="hljs-string">&#x27;value -&#x27;</span>, val)<br>                value = val;<br>            &#125;<br>        &#125;)<br>    &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;---------华丽的分割线--------&#x27;</span>)<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;#&#x27;</span> + id);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="过debugger"><a href="#过debugger" class="headerlink" title="过debugger"></a>过debugger</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Closure</span>(<span class="hljs-params">injectFunction</span>) </span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>                <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">arguments</span>.length)<br>                    <span class="hljs-keyword">return</span> injectFunction.apply(<span class="hljs-built_in">this</span>, <span class="hljs-built_in">arguments</span>)<br>                    <span class="hljs-built_in">arguments</span>[<span class="hljs-built_in">arguments</span>.length - <span class="hljs-number">1</span>] = <span class="hljs-built_in">arguments</span>[<span class="hljs-built_in">arguments</span>.length - <span class="hljs-number">1</span>].replace(<span class="hljs-regexp">/debugger/g</span>, <span class="hljs-string">&quot;&quot;</span>);<br>                <span class="hljs-keyword">return</span> injectFunction.apply(<span class="hljs-built_in">this</span>, <span class="hljs-built_in">arguments</span>)<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">var</span> oldFunctionConstructor = <span class="hljs-built_in">window</span>.Function.prototype.constructor;<br>        <span class="hljs-built_in">window</span>.Function.prototype.constructor = Closure(oldFunctionConstructor)<br>            <span class="hljs-comment">//fix native function</span><br>            <span class="hljs-built_in">window</span>.Function.prototype.constructor.toString = oldFunctionConstructor.toString.bind(oldFunctionConstructor);<br><br>        <span class="hljs-keyword">var</span> oldFunction = <span class="hljs-built_in">Function</span>;<br>        <span class="hljs-built_in">window</span>.Function = Closure(oldFunction)<br>            <span class="hljs-comment">//fix native function</span><br>            <span class="hljs-built_in">window</span>.Function.toString = oldFunction.toString.bind(oldFunction);<br><br>        <span class="hljs-keyword">var</span> oldEval = <span class="hljs-built_in">eval</span>;<br>        <span class="hljs-built_in">window</span>.eval = Closure(oldEval)<br>            <span class="hljs-comment">//fix native function</span><br>            <span class="hljs-built_in">window</span>.eval.toString = oldEval.toString.bind(oldEval);<br><br>        <span class="hljs-comment">// hook GeneratorFunction</span><br>        <span class="hljs-keyword">var</span> oldGeneratorFunctionConstructor = <span class="hljs-built_in">Object</span>.getPrototypeOf(<span class="hljs-function"><span class="hljs-keyword">function</span>  * (<span class="hljs-params"></span>) </span>&#123;&#125;).constructor<br>            <span class="hljs-keyword">var</span> newGeneratorFunctionConstructor = Closure(oldGeneratorFunctionConstructor)<br>            newGeneratorFunctionConstructor.toString = oldGeneratorFunctionConstructor.toString.bind(oldGeneratorFunctionConstructor);<br>        <span class="hljs-built_in">Object</span>.defineProperty(oldGeneratorFunctionConstructor.prototype, <span class="hljs-string">&quot;constructor&quot;</span>, &#123;<br>            value: newGeneratorFunctionConstructor,<br>            writable: <span class="hljs-literal">false</span>,<br>            configurable: <span class="hljs-literal">true</span><br>        &#125;)<br><br>        <span class="hljs-comment">// hook Async Function</span><br>        <span class="hljs-keyword">var</span> oldAsyncFunctionConstructor = <span class="hljs-built_in">Object</span>.getPrototypeOf(<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;&#125;).constructor<br>            <span class="hljs-keyword">var</span> newAsyncFunctionConstructor = Closure(oldAsyncFunctionConstructor)<br>            newAsyncFunctionConstructor.toString = oldAsyncFunctionConstructor.toString.bind(oldAsyncFunctionConstructor);<br>        <span class="hljs-built_in">Object</span>.defineProperty(oldAsyncFunctionConstructor.prototype, <span class="hljs-string">&quot;constructor&quot;</span>, &#123;<br>            value: newAsyncFunctionConstructor,<br>            writable: <span class="hljs-literal">false</span>,<br>            configurable: <span class="hljs-literal">true</span><br>        &#125;)<br><br>        <span class="hljs-comment">// hook dom</span><br>        <span class="hljs-keyword">var</span> oldSetAttribute = <span class="hljs-built_in">window</span>.Element.prototype.setAttribute;<br>        <span class="hljs-built_in">window</span>.Element.prototype.setAttribute = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name, value</span>) </span>&#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> value == <span class="hljs-string">&quot;string&quot;</span>)<br>                value = value.replace(<span class="hljs-regexp">/debugger/g</span>, <span class="hljs-string">&quot;&quot;</span>)<br>                    <span class="hljs-comment">// 向上调用</span><br>                    oldSetAttribute.call(<span class="hljs-built_in">this</span>, name, value)<br>        &#125;;<br>        <span class="hljs-keyword">var</span> oldContentWindow = <span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor(HTMLIFrameElement.prototype, <span class="hljs-string">&quot;contentWindow&quot;</span>).get<br>            <span class="hljs-built_in">Object</span>.defineProperty(<span class="hljs-built_in">window</span>.HTMLIFrameElement.prototype, <span class="hljs-string">&quot;contentWindow&quot;</span>, &#123;<br>            <span class="hljs-function"><span class="hljs-title">get</span>(<span class="hljs-params"></span>)</span> &#123;<br>                <span class="hljs-keyword">var</span> newV = oldContentWindow.call(<span class="hljs-built_in">this</span>)<br>                    <span class="hljs-keyword">if</span> (!newV.inject) &#123;<br>                        newV.inject = <span class="hljs-literal">true</span>;<br>                        core.call(newV, globalConfig, newV);<br>                    &#125;<br>                    <span class="hljs-keyword">return</span> newV<br>            &#125;<br>        &#125;)<br></code></pre></td></tr></table></figure><h2 id="过debugger—1-constructor构造器构造出来的"><a href="#过debugger—1-constructor构造器构造出来的" class="headerlink" title="过debugger—1   constructor构造器构造出来的"></a>过debugger—1   constructor构造器构造出来的</h2><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs delphi"><span class="hljs-keyword">var</span> _constructor = <span class="hljs-function"><span class="hljs-keyword">constructor</span>;</span><br><span class="hljs-keyword">Function</span>.prototype.<span class="hljs-keyword">constructor</span> = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(s)</span> <span class="hljs-comment">&#123;</span></span><br><span class="hljs-function"><span class="hljs-comment">                if (s == &quot;debugger&quot;)&#123;</span></span><br><span class="hljs-function"><span class="hljs-comment">                    console.log(s);</span></span><br><span class="hljs-function"><span class="hljs-comment">                    return null;</span></span><br><span class="hljs-function"><span class="hljs-comment">                &#125;</span></span><br><span class="hljs-function">                <span class="hljs-title">return</span> _<span class="hljs-title">constructor</span><span class="hljs-params">(s)</span>;</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="过debugger—2-eval的"><a href="#过debugger—2-eval的" class="headerlink" title="过debugger—2  eval的"></a>过debugger—2  eval的</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript">(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123; <br><span class="hljs-meta">    &#x27;use strict&#x27;</span>;<br>    <span class="hljs-keyword">var</span> eval_ = <span class="hljs-built_in">window</span>.eval;<br>    <span class="hljs-built_in">window</span>.eval = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">x</span>)</span>&#123;<br>    eval_(x.replace(<span class="hljs-string">&quot;debugger;&quot;</span>,<span class="hljs-string">&quot;  ; &quot;</span>));<br>    &#125;;<br>    <span class="hljs-built_in">window</span>.eval.toString = eval_.toString;<br>&#125;)();<br></code></pre></td></tr></table></figure><h1 id="json-hook"><a href="#json-hook" class="headerlink" title="json hook"></a>json hook</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> my_stringify = <span class="hljs-built_in">JSON</span>.stringify;<br><span class="hljs-built_in">JSON</span>.stringify = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">params</span>) </span>&#123;<br>    <span class="hljs-comment">//这里可以添加其他逻辑比如 debugger</span><br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;json_stringify params:&quot;</span>,params);<br>    <span class="hljs-keyword">return</span> my_stringify(params);<br>&#125;;<br><br><span class="hljs-keyword">var</span> my_parse = <span class="hljs-built_in">JSON</span>.parse;<br><span class="hljs-built_in">JSON</span>.parse = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">params</span>) </span>&#123;<br>    <span class="hljs-comment">//这里可以添加其他逻辑比如 debugger</span><br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;json_parse params:&quot;</span>,params);<br>    <span class="hljs-keyword">return</span> my_parse(params);<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="对象属性hook-属性自定义"><a href="#对象属性hook-属性自定义" class="headerlink" title="对象属性hook 属性自定义"></a>对象属性hook 属性自定义</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript">(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-comment">// 严格模式，检查所有错误</span><br><span class="hljs-meta">    &#x27;use strict&#x27;</span><br>    <span class="hljs-comment">// document 为要hook的对象 ,属性是cookie</span><br>    <span class="hljs-built_in">Object</span>.defineProperty(<span class="hljs-built_in">document</span>,<span class="hljs-string">&#x27;cookie&#x27;</span>,&#123;<br>        <span class="hljs-comment">// hook set方法也就是赋值的方法，get就是获取的方法</span><br>        set: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">val</span>)</span>&#123;<br>            <span class="hljs-comment">// 这样就可以快速给下面这个代码行下断点，从而快速定位设置cookie的代码</span><br>            <span class="hljs-keyword">debugger</span>;  <span class="hljs-comment">// 在此处自动断下</span><br>            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Hook捕获到set-cookie -&gt;&#x27;</span>,val);<br>            <span class="hljs-keyword">return</span> val;<br>        &#125;<br>    &#125;)<br>&#125;)();<br></code></pre></td></tr></table></figure><h1 id="cookies"><a href="#cookies" class="headerlink" title="cookies"></a>cookies</h1><h2 id="1"><a href="#1" class="headerlink" title="1"></a>1</h2><p>（不是万能的 有些时候hook不到 自己插入debugger）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> cookie_cache = <span class="hljs-built_in">document</span>.cookie;<br><br><span class="hljs-built_in">Object</span>.defineProperty(<span class="hljs-built_in">document</span>, <span class="hljs-string">&#x27;cookie&#x27;</span>, &#123;<br>    get: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Getting cookie&#x27;</span>);<br>        <span class="hljs-keyword">return</span> cookie_cache;<br>    &#125;,<br>    set: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">val</span>) </span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Seting cookie&quot;</span>,val);<br>        <span class="hljs-keyword">var</span> cookie = val.split(<span class="hljs-string">&quot;;&quot;</span>)[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">var</span> ncookie = cookie.split(<span class="hljs-string">&quot;=&quot;</span>);<br>        <span class="hljs-keyword">var</span> flag = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">var</span> cache = cookie_cache.split(<span class="hljs-string">&quot;; &quot;</span>);<br>        cache = cache.map(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a</span>)</span>&#123;<br>            <span class="hljs-keyword">if</span> (a.split(<span class="hljs-string">&quot;=&quot;</span>)[<span class="hljs-number">0</span>] === ncookie[<span class="hljs-number">0</span>])&#123;<br>                flag = <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">return</span> cookie;<br>            &#125;<br>            <span class="hljs-keyword">return</span> a;<br>        &#125;)<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><h2 id="cookies-2"><a href="#cookies-2" class="headerlink" title="cookies - 2"></a>cookies - 2</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> code = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-keyword">var</span> org = <span class="hljs-built_in">document</span>.cookie.__lookupSetter__(<span class="hljs-string">&#x27;cookie&#x27;</span>);<br>    <span class="hljs-built_in">document</span>.__defineSetter__(<span class="hljs-string">&quot;cookie&quot;</span>,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">cookie</span>)</span>&#123;<br>        <span class="hljs-keyword">if</span>(cookie.indexOf(<span class="hljs-string">&#x27;TSdc75a61a&#x27;</span>)&gt;-<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">debugger</span>;<br>        &#125;<br>        org = cookie;<br>    &#125;);<br>    <span class="hljs-built_in">document</span>.__defineGetter__(<span class="hljs-string">&quot;cookie&quot;</span>,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<span class="hljs-keyword">return</span> org;&#125;);<br>&#125;<br><span class="hljs-keyword">var</span> script = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;script&#x27;</span>);<br>script.textContent = <span class="hljs-string">&#x27;(&#x27;</span> + code + <span class="hljs-string">&#x27;)()&#x27;</span>;<br>(<span class="hljs-built_in">document</span>.head||<span class="hljs-built_in">document</span>.documentElement).appendChild(script);<br>script.parentNode.removeChild(script);<br><br><span class="hljs-comment">// 当cookie中匹配到了 TSdc75a61a， 则插入断点。</span><br></code></pre></td></tr></table></figure><h1 id="window-attr"><a href="#window-attr" class="headerlink" title="window attr"></a>window attr</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 定义hook属性</span><br><span class="hljs-keyword">var</span> window_flag_1 = <span class="hljs-string">&quot;_t&quot;</span>;<br><span class="hljs-keyword">var</span> window_flag_2 = <span class="hljs-string">&quot;ccc&quot;</span>;<br><br><span class="hljs-keyword">var</span> key_value_map = &#123;&#125;;<br><span class="hljs-keyword">var</span> window_value = <span class="hljs-built_in">window</span>[window_flag_1];<br><br><span class="hljs-comment">// hook</span><br><span class="hljs-built_in">Object</span>.defineProperty(<span class="hljs-built_in">window</span>, window_flag_1, &#123;<br>    get: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Getting&quot;</span>,<span class="hljs-built_in">window</span>,window_flag_1,<span class="hljs-string">&quot;=&quot;</span>,window_value);<br>        <span class="hljs-comment">//debugger</span><br>        <span class="hljs-keyword">return</span> window_value<br>    &#125;,<br>    set: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">val</span>) </span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Setting&quot;</span>,<span class="hljs-built_in">window</span>, window_flag_1, <span class="hljs-string">&quot;=&quot;</span>,val);<br>        <span class="hljs-comment">//debugger</span><br>        window_value = val;<br>        key_value_map[<span class="hljs-built_in">window</span>[window_flag_1]] = window_flag_1;<br>        set_obj_attr(<span class="hljs-built_in">window</span>[window_flag_1],window_flag_2);<br>    &#125;,<br><br>&#125;);<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">set_obj_attr</span>(<span class="hljs-params">obj,attr</span>)</span>&#123;<br>    <span class="hljs-keyword">var</span> obj_attr_value = obj[attr];<br>    <span class="hljs-built_in">Object</span>.defineProperty(obj,attr, &#123;<br>        get: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Getting&quot;</span>, key_value_map[obj],attr, <span class="hljs-string">&quot;=&quot;</span>, obj_attr_value);<br>            <span class="hljs-comment">//debugger</span><br>            <span class="hljs-keyword">return</span> obj_attr_value;<br>        &#125;,<br>        set: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">val</span>)</span>&#123;<br>            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Setting&quot;</span>, key_value_map[obj], attr, <span class="hljs-string">&quot;=&quot;</span>, val);<br>            <span class="hljs-comment">//debugger</span><br>            obj_attr_value = val;<br>        &#125;,<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="eval-Function"><a href="#eval-Function" class="headerlink" title="eval/Function"></a>eval/Function</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">window</span>.__cr_eval = <span class="hljs-built_in">window</span>.eval;<br><span class="hljs-keyword">var</span> myeval = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">src</span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(src);<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;========= eval end ===========&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">window</span>.__cr_eval;<br>&#125;<br><br><span class="hljs-keyword">var</span> _myeval = myeval.bind(<span class="hljs-literal">null</span>);<br>_myeval.toString = <span class="hljs-built_in">window</span>.__cr_eval.toString;<br><span class="hljs-built_in">Object</span>.defineProperty(<span class="hljs-built_in">window</span>, <span class="hljs-string">&#x27;eval&#x27;</span>,&#123;<span class="hljs-attr">value</span>: _myeval&#125;);<br><br><span class="hljs-built_in">window</span>._cr_fun = <span class="hljs-built_in">window</span>.Function<br><span class="hljs-keyword">var</span> myfun = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-keyword">var</span> args = <span class="hljs-built_in">Array</span>.prototype.slice.call(<span class="hljs-built_in">arguments</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>).join(<span class="hljs-string">&quot;,&quot;</span>), src = <span class="hljs-built_in">arguments</span>[<span class="hljs-built_in">arguments</span>.lenght -<span class="hljs-number">1</span>];<br>    <span class="hljs-built_in">console</span>.log(src);<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;======== Function end =============&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">window</span>._cr_fun.apply(<span class="hljs-built_in">this</span>, <span class="hljs-built_in">arguments</span>)<br>&#125;<br><br>myfun.toString = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">window</span>._cr_fun + <span class="hljs-string">&quot;&quot;</span>&#125; <span class="hljs-comment">//小花招，这里防止代码里检测原生函数</span><br><span class="hljs-built_in">Object</span>.defineProperty(<span class="hljs-built_in">window</span>, <span class="hljs-string">&quot;Function&quot;</span>,&#123;<span class="hljs-attr">value</span>: myfun&#125;)<br></code></pre></td></tr></table></figure><h1 id="websocket-hook"><a href="#websocket-hook" class="headerlink" title="websocket hook"></a>websocket hook</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 1、webcoket 一般都是json数据格式传输，那么发生之前需要JSON.stringify  </span><br><span class="hljs-keyword">var</span> my_stringify = <span class="hljs-built_in">JSON</span>.stringify;<br><span class="hljs-built_in">JSON</span>.stringify = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">params</span>) </span>&#123;<br>    <span class="hljs-comment">//这里可以添加其他逻辑比如 debugger</span><br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;json_stringify params:&quot;</span>,params);<br>    <span class="hljs-keyword">return</span> my_stringify(params);<br>&#125;;<br><br><span class="hljs-keyword">var</span> my_parse = <span class="hljs-built_in">JSON</span>.parse;<br><span class="hljs-built_in">JSON</span>.parse = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">params</span>) </span>&#123;<br>    <span class="hljs-comment">//这里可以添加其他逻辑比如 debugger</span><br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;json_parse params:&quot;</span>,params);<br>    <span class="hljs-keyword">return</span> my_parse(params);<br>&#125;;<br><br><span class="hljs-comment">// 2  webScoket 绑定在windows对象，上，根据浏览器的不同，websokcet名字可能不一样 </span><br><span class="hljs-comment">//chrome window.WebSocket  firfox window.MozWebSocket;</span><br><span class="hljs-built_in">window</span>._WebSocket = <span class="hljs-built_in">window</span>.WebSocket;<br><br><span class="hljs-comment">// hook send</span><br><span class="hljs-built_in">window</span>._WebSocket.prototype.send = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.info(<span class="hljs-string">&quot;Hook WebSocket&quot;</span>, data);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.send(data)<br>&#125;<br><br><span class="hljs-built_in">Object</span>.defineProperty(<span class="hljs-built_in">window</span>, <span class="hljs-string">&quot;WebSocket&quot;</span>,&#123;<span class="hljs-attr">value</span>: WebSocket&#125;)<br></code></pre></td></tr></table></figure><h1 id="hook-正则"><a href="#hook-正则" class="headerlink" title="hook 正则"></a>hook 正则</h1><h2 id="1-1"><a href="#1-1" class="headerlink" title="1"></a>1</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript">(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> _RegExp = <span class="hljs-built_in">RegExp</span>;<br>    <span class="hljs-built_in">RegExp</span> = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">pattern, modifiers</span>) </span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Some codes are setting regexp&quot;</span>);<br>        <span class="hljs-keyword">debugger</span>;<br>        <span class="hljs-keyword">if</span> (modifiers) &#123;<br>            <span class="hljs-keyword">return</span> _RegExp(pattern, modifiers);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> _RegExp(pattern);<br>        &#125;<br>    &#125;;<br>    <span class="hljs-built_in">RegExp</span>.toString = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;function setInterval() &#123; [native code] &#125;&quot;</span><br>    &#125;;<br>&#125;)();<br></code></pre></td></tr></table></figure><h2 id="hook-正则-2-加在sojson头部过字符串格式化检测"><a href="#hook-正则-2-加在sojson头部过字符串格式化检测" class="headerlink" title="hook 正则 2 加在sojson头部过字符串格式化检测"></a>hook 正则 2 加在sojson头部过字符串格式化检测</h2><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs perl">(function () &#123;<br>            var _RegExp = RegExp;<br>            RegExp = function (pattern, modifiers) &#123;<br>                <span class="hljs-keyword">if</span> (pattern == decodeURIComponent(<span class="hljs-string">&quot;%5Cw%2B%20*%5C(%5C)%20*%7B%5Cw%2B%20*%5B&#x27;%7C%22%5D.%2B%5B&#x27;%7C%22%5D%3B%3F%20*%7D&quot;</span>) || pattern == decodeURIComponent(<span class="hljs-string">&quot;function%20*%5C(%20*%5C)&quot;</span>)<br>                     || pattern == decodeURIComponent(<span class="hljs-string">&quot;%5C%2B%5C%2B%20*(%3F%3A_0x(%3F%3A%5Ba-f0-9%5D)%7B4%2C6%7D%7C(%3F%3A%5Cb%7C%5Cd)%5Ba-z0-9%5D%7B1%2C4%7D(%3F%3A%5Cb%7C%5Cd))&quot;</span>) || pattern == decodeURIComponent(<span class="hljs-string">&quot;(%5C%5C%5Bx%7Cu%5D(%5Cw)%7B2%2C4%7D)%2B&quot;</span>)) &#123;<br>                    pattern = <span class="hljs-string">&#x27;.*?&#x27;</span>;<br>                    console.log(<span class="hljs-string">&quot;发现sojson检测特征，已帮您处理。&quot;</span>)<br>                &#125;<br>                <span class="hljs-keyword">if</span> (modifiers) &#123;<br>                    console.log(<span class="hljs-string">&quot;疑似最后一个检测...已帮您处理。&quot;</span>)<br>                    console.log(<span class="hljs-string">&quot;已通过全部检测，请手动处理debugger后尽情调试吧！&quot;</span>)<br>                    <span class="hljs-keyword">return</span> _RegExp(pattern, modifiers);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">return</span> _RegExp(pattern);<br>                &#125;<br>            &#125;;<br>            RegExp.toString = function () &#123;<br>                <span class="hljs-keyword">return</span> _RegExp.toString();<br>            &#125;;<br>        &#125;)();<br></code></pre></td></tr></table></figure><h1 id="hook-canvas-定位图片生成的地方"><a href="#hook-canvas-定位图片生成的地方" class="headerlink" title="hook canvas (定位图片生成的地方)"></a>hook canvas (定位图片生成的地方)</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript">(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br><span class="hljs-meta">    &#x27;use strict&#x27;</span>;<br>    <span class="hljs-keyword">let</span> create_element = <span class="hljs-built_in">document</span>.createElement.bind(doument);<br><br>    <span class="hljs-built_in">document</span>.createElement = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">_element</span>) </span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;create_element:&quot;</span>,_element);<br>        <span class="hljs-keyword">if</span> (_element === <span class="hljs-string">&quot;canvas&quot;</span>) &#123;<br>            <span class="hljs-keyword">debugger</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> create_element(_element);<br>    &#125;<br>&#125;)();<br></code></pre></td></tr></table></figure><h1 id="setInterval-定时器"><a href="#setInterval-定时器" class="headerlink" title="setInterval 定时器"></a>setInterval 定时器</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript">(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>            setInterval_ = <span class="hljs-built_in">setInterval</span>;<br>            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;原函数已被重命名为setInterval_&quot;</span>)<br>            <span class="hljs-built_in">setInterval</span> = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;&#125;;<br>            <span class="hljs-built_in">setInterval</span>.toString = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>                <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;有函数正在检测setInterval是否被hook&quot;</span>);<br>                <span class="hljs-keyword">return</span> setInterval_.toString();<br>            &#125;;<br>        &#125;)();<br></code></pre></td></tr></table></figure><h1 id="console-log-检测例子-（不让你输出调试）"><a href="#console-log-检测例子-（不让你输出调试）" class="headerlink" title="console.log 检测例子 （不让你输出调试）"></a>console.log 检测例子 （不让你输出调试）</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> oldConsole = [<span class="hljs-string">&quot;debug&quot;</span>, <span class="hljs-string">&quot;error&quot;</span>, <span class="hljs-string">&quot;info&quot;</span>, <span class="hljs-string">&quot;log&quot;</span>, <span class="hljs-string">&quot;warn&quot;</span>, <span class="hljs-string">&quot;dir&quot;</span>, <span class="hljs-string">&quot;dirxml&quot;</span>, <span class="hljs-string">&quot;table&quot;</span>, <span class="hljs-string">&quot;trace&quot;</span>, <span class="hljs-string">&quot;group&quot;</span>, <span class="hljs-string">&quot;groupCollapsed&quot;</span>, <span class="hljs-string">&quot;groupEnd&quot;</span>, <span class="hljs-string">&quot;clear&quot;</span>, <span class="hljs-string">&quot;count&quot;</span>, <span class="hljs-string">&quot;countReset&quot;</span>, <span class="hljs-string">&quot;assert&quot;</span>, <span class="hljs-string">&quot;profile&quot;</span>, <span class="hljs-string">&quot;profileEnd&quot;</span>, <span class="hljs-string">&quot;time&quot;</span>, <span class="hljs-string">&quot;timeLog&quot;</span>, <span class="hljs-string">&quot;timeEnd&quot;</span>, <span class="hljs-string">&quot;timeStamp&quot;</span>, <span class="hljs-string">&quot;context&quot;</span>, <span class="hljs-string">&quot;memory&quot;</span>].map(<span class="hljs-function"><span class="hljs-params">key</span> =&gt;</span> &#123;<br>            <span class="hljs-keyword">var</span> old = <span class="hljs-built_in">console</span>[key];<br>            <span class="hljs-built_in">console</span>[key] = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;&#125;;<br>            <span class="hljs-built_in">console</span>[key].toString = old.toString.bind(old)<br>                <span class="hljs-keyword">return</span> old;<br>        &#125;)<br></code></pre></td></tr></table></figure><h1 id="检测函数是否被hook例子"><a href="#检测函数是否被hook例子" class="headerlink" title="检测函数是否被hook例子"></a>检测函数是否被hook例子</h1><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-keyword">if</span> (<span class="hljs-built_in">window</span>.<span class="hljs-built_in">eval</span> == <span class="hljs-string">&#x27;native code&#x27;</span>)&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;发现eval函数被hook了 开始死循环&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>javascript</tag>
      
      <tag>Hook</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux-Shell-后台运行脚本</title>
    <link href="/post/141cf4a2/"/>
    <url>/post/141cf4a2/</url>
    
    <content type="html"><![CDATA[<h1 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h1><p>前台运行脚本会占住你的控制台，控制台关闭以后，脚本也会跟着停下。后台运行会让你感到舒服/干净  </p><blockquote><p>虽然存在忘了脚本在运行和分不清是什么脚本的可能性  </p></blockquote><h1 id="amp-后台运行脚本"><a href="#amp-后台运行脚本" class="headerlink" title="&amp;后台运行脚本"></a><code>&amp;</code>后台运行脚本</h1><p>直接在运行的脚本后家<code>&amp;</code>即可实现  </p><blockquote><p>例：后台运行<code>test.sh</code>脚本  </p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">. test.sh &amp;<br></code></pre></td></tr></table></figure><p>虽然这样已经是后台运行了，但这样做会有一个问题<br>关闭终端连接后，脚本会停止运行  </p><h1 id="nohup不挂断的运行"><a href="#nohup不挂断的运行" class="headerlink" title="nohup不挂断的运行"></a><code>nohup</code>不挂断的运行</h1><blockquote><p>nohup 是 no hang up 的缩写，就是不挂断的意思  </p></blockquote><p>不挂断的运行，指用nohup运行命令可以使命令永久的执行下去。命令可以在你退出帐户/关闭终端之后继续运行相应的进程<br>断开SSH连接/关闭终端 都不会影响他的运行  </p><blockquote><p>例：后台不挂断运行<code>test.sh</code>脚本  </p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">. test.sh &amp;<br></code></pre></td></tr></table></figure><p>注意：用这个命令运行的脚本的所有输出都被重定向到一个名为nohup.out的文件中  </p>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Shell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>服务器部署-SSH</title>
    <link href="/post/5ca1c756/"/>
    <url>/post/5ca1c756/</url>
    
    <content type="html"><![CDATA[<h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><ul><li>Centos7.2 腾讯云服务器  </li></ul><h1 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h1><p><code>SSH</code>全称是<code>Secure Shell</code>，<code>SSH</code>协议是基于应用层的协议，为远程登录会话和其他网络服务提供安全性的协议。</p><blockquote><p><code>SSH</code>使用最多的是远程登录和传输文件，实现此功能的传统协议都不安全（<code>ftp</code>，<code>telnet</code>等），因为它们使用明文传输数据。而SSH在传输过程中的数据是加密的，安全性更高。</p></blockquote><h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p>SSH协议传输是基于(非对称加密方法的)[<a href="https://zh.wikipedia.org/zh-cn/%E5%85%AC%E5%BC%80%E5%AF%86%E9%92%A5%E5%8A%A0%E5%AF%86]">https://zh.wikipedia.org/zh-cn/%E5%85%AC%E5%BC%80%E5%AF%86%E9%92%A5%E5%8A%A0%E5%AF%86]</a>  </p><h3 id="文件路径"><a href="#文件路径" class="headerlink" title="文件路径"></a>文件路径</h3><ul><li><p>服务端<br>若远程服务器是新系统，会在<code>/etc/ssh</code>目录下生成一个名为<code>ssh_host_ecdsa_key.pub</code>的公钥，同时生成一个名为<code>ssh_host_ecdsa_key</code>的私钥，这一对就是远程服务器的公钥与私钥<br>之后每次启动sshd服务的时候，系统会自动在此路径下查找公钥  </p></li><li><p>客户端<br>客户端将服务器传来的公钥记录在<code>~/.ssh/known_hosts</code>中，若是已经记录有该服务器公钥，则比对是否一致，一致后就计算客户端自己的公私钥。发送自己的公钥给服务器  </p></li></ul><h3 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h3><p>实际上这个过程比上面描述的要复杂很多<br>比如说<code>DH秘钥交换的密钥交换算法</code>就是一种多种加密算法混合的算法    </p><h2 id="认证方式"><a href="#认证方式" class="headerlink" title="认证方式"></a>认证方式</h2><h2 id="密码"><a href="#密码" class="headerlink" title="密码"></a>密码</h2><ul><li>连接服务器的各类型密码不应低于8位（建议20位）  </li><li>密码字符涵盖类型越多越好。数字、英文大写、小写、特殊字符  </li></ul><p>如果没有什么特殊需求，建议使用密钥  </p><h2 id="密钥"><a href="#密钥" class="headerlink" title="密钥"></a>密钥</h2><p>作为密码的更好的替代品存在的东西存在<br>载体是一个文件，认证以后就不用频繁的输入密码了  </p><h1 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h1><h2 id="SSH配置文件修改"><a href="#SSH配置文件修改" class="headerlink" title="SSH配置文件修改"></a>SSH配置文件修改</h2><p>由于很多操作其实都是编辑<code>SSH</code>的配置文件，这里先给出打开方式  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vi /etc/ssh/sshd_config<br></code></pre></td></tr></table></figure><p>在进行完修改以后，重新启动SSH服务以应用设置  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">service sshd restart<br></code></pre></td></tr></table></figure><h2 id="SSH禁止使用root用户直接登录"><a href="#SSH禁止使用root用户直接登录" class="headerlink" title="SSH禁止使用root用户直接登录"></a>SSH禁止使用root用户直接登录</h2><p>想要获取root权限？先用普通用户登录再切换用户  </p><blockquote><p>注意，要是没有其它用户又禁用了root用户就会很麻烦  </p></blockquote><ol><li><p>打开SSH配置文件</p></li><li><p>找到对应项并设置为no</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">PermitRootLogin no<br></code></pre></td></tr></table></figure><h2 id="修改SSH端口"><a href="#修改SSH端口" class="headerlink" title="修改SSH端口"></a>修改SSH端口</h2><p>如果<code>SSH端口</code>不是22，那就不能直接暴力破解了，需要扫描很多的端口才能发现真的<code>SSH端口</code>，浪费黑客的时间  </p><blockquote><p>注意防火墙的问题，连不上就麻烦了  </p></blockquote></li><li><p>打开SSH配置文件  </p></li><li><p>找到 #Port 22<br>这东西本身就被注释了，找到这个东西只是为了将一类设置写一起  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#Port 22</span><br>Port 51369 <span class="hljs-comment"># 设置自定义的端口51369</span><br></code></pre></td></tr></table></figure><h2 id="创建SSH密钥来登录"><a href="#创建SSH密钥来登录" class="headerlink" title="创建SSH密钥来登录"></a>创建SSH密钥来登录</h2><p>虽然理论中说了要双方公钥交换，但实际上只要有一对连接上了，另一个会被自动创建<br>因此有两种方式来创建密钥  </p></li></ol><ul><li>客户端创建密钥，将公钥给服务器  </li><li>服务器创建密钥，将私钥给客户端，自己将公钥注册下来  </li></ul><p>以下方式为第二种  </p><ol><li>SSH设置允许密钥登录  <ol><li>打开SSH配置文件  </li><li>编辑配置  <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">RSAAuthentication</span> <span class="hljs-literal">yes</span><br><span class="hljs-string">PubkeyAuthentication</span> <span class="hljs-literal">yes</span><br></code></pre></td></tr></table></figure></li></ol></li><li>切换到希望创建密钥的用户，创建密钥对  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh-keygen<br></code></pre></td></tr></table></figure> 过程中会需要你输入一些东西，要是不知道是什么，可以直接回车不管   <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">Enter file <span class="hljs-keyword">in</span> which to save the key (<span class="hljs-regexp">/home/</span>用户名<span class="hljs-regexp">/.ssh/i</span>d_rsa):  <span class="hljs-comment"># 设置密钥文件保存路径</span><br>Enter passphrase (empty <span class="hljs-keyword">for</span> no passphrase):  <span class="hljs-comment"># 设置密钥锁码</span><br>Enter same passphrase again:  <span class="hljs-comment"># 密钥锁码确认</span><br></code></pre></td></tr></table></figure> 最后会有一些提示  <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment"># 你的私钥保存在这里</span><br>Your identification has been saved <span class="hljs-keyword">in</span> <span class="hljs-regexp">/home/m</span>anager<span class="hljs-regexp">/.ssh/i</span>d_rsa.<br><span class="hljs-comment"># 你的公钥保存在这里</span><br>Your public key has been saved <span class="hljs-keyword">in</span> <span class="hljs-regexp">/home/m</span>anager<span class="hljs-regexp">/.ssh/i</span>d_rsa.pub.<br></code></pre></td></tr></table></figure></li><li>服务器公钥注册  <ol><li>来到.ssh目录 <figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-keyword">cd</span> ~<br><span class="hljs-keyword">cd</span> <span class="hljs-string">.ssh</span><br></code></pre></td></tr></table></figure></li><li>注册公钥  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">cat</span> <span class="hljs-selector-tag">id_rsa</span><span class="hljs-selector-class">.pub</span> &gt;&gt; <span class="hljs-selector-tag">authorized_keys</span><br></code></pre></td></tr></table></figure><blockquote><p>有些时候会遇到权限的问题，把权限设置得高一些就可以解决  </p></blockquote><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">chmod</span> <span class="hljs-number">600</span> authorized_keys<br></code></pre></td></tr></table></figure></li></ol></li><li>重启SSH以应用设置  <figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">service sshd restart</span><br></code></pre></td></tr></table></figure></li><li>客户端获取密钥私钥文件<br>使用<a href="/post/8649b4ed/" title="scp命令">scp命令</a>即可，这里是从服务器把私钥下载下来，放到E盘  <figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir">scp root<span class="hljs-variable">@192</span>.<span class="hljs-number">168.1</span>.<span class="hljs-number">2</span><span class="hljs-symbol">:/home/manager/</span>.ssh/id_rsa <span class="hljs-symbol">E:</span>/ <br></code></pre></td></tr></table></figure></li><li>客户端使用私钥<br>这里以<code>putty</code>为例  <ol><li>将密钥转为<code>putty</code>能使用的类型的密钥文件<br><img src="/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2-SSH/convert_key.gif">  </li><li>在登录时应用密钥<br><img src="/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2-SSH/use_key.gif">  </li></ol></li></ol><h2 id="禁用密码登录"><a href="#禁用密码登录" class="headerlink" title="禁用密码登录"></a>禁用密码登录</h2><ol><li>打开SSH配置文件  </li><li>修改配置  <figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">PasswordAuthentication</span> <span class="hljs-literal">no</span><br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>服务器</tag>
      
      <tag>SSH</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo-abbrlink</title>
    <link href="/post/Infinity/"/>
    <url>/post/Infinity/</url>
    
    <content type="html"><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p><code>Hexo</code>文章链接默认的生成规则是：:year/:month/:day/:title。即按照年、月、日、标题来生成<br>如果文章标题是中文的话，URL链接是也会是中文，但链接不能是中文原文，需要转译，于是就变成了非常非常长的一串<br>如果你需要弄博客内跳转的话，文件名一改，url会跟着改，想要正确跳转又要手动跟着改，非常麻烦  </p><h1 id="Hexo-abbrlink"><a href="#Hexo-abbrlink" class="headerlink" title="Hexo-abbrlink"></a>Hexo-abbrlink</h1><p>为了应对url又长又臭，文件更改又会更改的问题，有人作出了插件让文章生成唯一不变的url的插件<code>Hexo-abbrlink</code><br>Github: <a href="https://github.com/Rozbo/hexo-abbrlink">https://github.com/Rozbo/hexo-abbrlink</a></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>博客目录下npm安装，如果提示缺少前置，那就把前置装上就行    </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">npm <span class="hljs-keyword">install</span> hexo-abbrlink <span class="hljs-comment">--save</span><br></code></pre></td></tr></table></figure><h2 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h2><p>打开博客目录的配置文件<code>_config.yml</code>，修改<code>permalink</code>设置(只能在原本的位置进行更改)  </p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">permalink: posts<span class="hljs-regexp">/:abbrlink/</span><br></code></pre></td></tr></table></figure><p><code>:abbrlink</code>是生成的文章标识<br>你可以像我一样完全只用这个生成后不会变的id来构建路由，也可以根据自己的需要设置路由  </p><blockquote><p>最後的那個<code>/</code>不要刪除<br>web server发送错误的MIME类型，浏览器接收到非HTML的MIME，会默认进行下载</p></blockquote><p>然后在文件最后，添加生成<code>abbrlink</code>的配置  </p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">abbrlink:</span><br>    <span class="hljs-meta"># 算法： crc16(default) and crc32</span><br><span class="hljs-symbol">    alg:</span> crc32<br>    <span class="hljs-meta"># 进制： dec(default) and hex</span><br><span class="hljs-symbol">    rep:</span> hex<br></code></pre></td></tr></table></figure><p>在清理，生成文件后，文章会被添加<code>abbrlink</code>字段作为唯一标识<br><img src="/Hexo-abbrlink/20200927090958942.png"><br>发布后，此字段就会作为<code>url</code>的一部分，使得每一个文章的<code>url</code>不重复的同时很美观  </p>]]></content>
    
    
    
    <tags>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>硬件-固态硬盘</title>
    <link href="/post/b35a5996/"/>
    <url>/post/b35a5996/</url>
    
    <content type="html"><![CDATA[<h1 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h1><p>固态硬盘（SSD）主要包括主控芯片、闪存颗粒和缓存单元三大组件  </p><p>预算&gt;主控&gt;颗粒&gt;无缓存&gt;容量  </p><h2 id="主控"><a href="#主控" class="headerlink" title="主控"></a>主控</h2><p>一款主控芯片的好坏直接决定了固态硬盘的实际体验和使用寿命<br>主要分为两种：原厂和主控厂商  </p><h3 id="主控的工作"><a href="#主控的工作" class="headerlink" title="主控的工作"></a>主控的工作</h3><ul><li><p>同时连接多个闪存单元<br>这意味着能获得更高的吞吐量  </p></li><li><p>损耗均衡<br>平均分配，延长寿命<br><code>SSD</code>闪存单元写入次数有限，如果<code>SSD</code>只往同一个闪存单元理读写东西，那么这个闪存单元很快就会因为写入次数过多而报废<br>主控将东西平均分配到各个闪存单元，通过平均写次数来延长硬盘寿命  </p></li><li><p>GC 垃圾回收<br>把现存数据重新转移到其他闪存位置，并且把一些无用的数据彻底删除的过程<br>可以将块中的没用的数据打上“过期”的标签，在转移数据到其它块的时候，只转移那些没有被打标签的内容。这样能避免无意义写入，延长硬盘寿命    </p><blockquote><p>写入放大<br>当写入新数据时，如果SSD控制器找不到可以写入的page时，会执行GC过程，然后GC机制会将一些block中的有效数据合并写入其他的block中，然后将这些block的无效数据擦出，再将新数据写入到这些block中，而在整个过程中除了要写入用户的数据之外，实际上SSD还写入了一些其他block合并过来的数据，所以这就叫写入放大</p></blockquote></li><li><p>Trim<br>减少写入负担<br>当<code>Windows</code>识别到<code>SSD</code>并确认<code>SSD</code>支持<code>Trim</code>后，在删除数据时，会不向硬盘通知删除指令，只使用<code>Volume Bitmap</code>来记住这里的数据已经删除。<br><code>Volume Bitmap</code>只是一个磁盘快照，其建立速度比直接读写硬盘去标记删除区域要快得多。这一步就已经省下一大笔时间了。<br>写入数据的时候，可以直接根据<code>Volume Bitmap</code>的情况，向快照中已删除的区块写入新的数据，而不用花时间去擦除原本的数据。</p></li><li><p>控温、SMART健康度报告、坏块管理、纠错、断电保护等等  </p></li></ul><h3 id="主控的好坏"><a href="#主控的好坏" class="headerlink" title="主控的好坏"></a>主控的好坏</h3><p>各个主控厂商对主控的设计保密很厉害，实际上你很难评价主控的好坏<br>也许只有等你用久了才感受得到  </p><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><blockquote><p>缓存的标准作用<br>适配速度不同的设备。将经常使用的内容保存在其中，高速设备需要直接从缓存里拿，不必访问低速设备，进而节约在低速设备运行时间  </p></blockquote><h3 id="独立缓存"><a href="#独立缓存" class="headerlink" title="独立缓存"></a>独立缓存</h3><p>对于SSD来说，独立缓存并不是很重要。<br>SSD的反应速度很快，只有0.2毫秒，不比缓存慢。带缓存性能提升也不大，只有在小文件的读写速度上稍有优势。<br>寿命方面来说，SSD并不是看有没有缓存，而是看NAND FLASH的写入次数。打个比方说，带缓存的用10年，不带缓存的用9年10个月这种感觉，影响也很小。<br>主控不同的话，也是SSD是否带缓存的一个因素，有些主控不需要缓存，有的则需要。比如镁光M4的Marvell主控就必须要有缓存的支持才可以工作。<br>所以很多SSD都没有缓存  </p><h2 id="PCIe-与-SATA"><a href="#PCIe-与-SATA" class="headerlink" title="PCIe 与 SATA"></a>PCIe 与 SATA</h2><h3 id="SATA（串行ATA）"><a href="#SATA（串行ATA）" class="headerlink" title="SATA（串行ATA）"></a>SATA（串行ATA）</h3><p>是SSD使用的一种连接接口，用于与系统进行数据通信。它创建于2003年，这意味着它有很多时间将自己巩固为当今最广泛使用的连接类型之一  </p><h3 id="PCIe"><a href="#PCIe" class="headerlink" title="PCIe"></a>PCIe</h3><p>PCIe（Peripheral Component Interconnect Express）<br>可以视为与主板更直接的数据连接。它通常用于显卡等设备，这些设备也需要极快的数据连接  </p><h3 id="SATA-PCIe-对比"><a href="#SATA-PCIe-对比" class="headerlink" title="SATA PCIe 对比"></a>SATA PCIe 对比</h3><p>||理论通道带宽|理论传输速度|<br>|–|–|–|–|<br>|SATA 3.0|6 Gb/s|750 MB/s|<br>|PCIe 3.0|8 Gb/s/通道|985 MB/s/通道||</p><p>PCIe设备可支持1x，4x，8x或16x通道，因此潜在的传输速度可到15.76 GB/s  </p><h2 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h2><p>可以用常用的性能测试比如<code>fio</code>、<code>IOMeter</code>等工具评估一下，并且需要测试一下SSD使用率达到80%以上时SSD的性能<br>有些SSD针对常用的测试工具<code>fio</code>做了优化，所以使用<code>fio</code>是测试不出真实性能，必须上<code>IOMeter</code>  </p><h2 id="寿命"><a href="#寿命" class="headerlink" title="寿命"></a>寿命</h2><p>简易计算公式<br><img src="/%E7%A1%AC%E4%BB%B6-%E5%9B%BA%E6%80%81%E7%A1%AC%E7%9B%98/20200926011715037.png"></p><p>固态硬盘的寿命，是由闪存类型和写入量决定的。</p><ol><li>一般的MLC固态硬盘，最广泛了，与入量是3000次P/E，也就是累计写满3000次。假设一只128G的固态硬盘，每天平均写入40G（一般的家庭用户不可能做到），那也能使用20年以上。</li><li>TLC的寿命，是MLC的一半或三分之一。也就是上述寿命缩短三倍。</li><li>SLC的寿命，是10000次p/e，是MLC的三倍以上。</li></ol><hr><p>参考：</p><ul><li><a href="https://zhidao.baidu.com/question/524007630.html">对于SSD来说缓存很重要吗？为什么许多SSD都没有缓存？</a>  </li><li><a href="youtube.com/watch?v=qUZtXUP78sw">SSD Controllers as Fast As Possible</a>  </li><li><a href="https://blog.csdn.net/scaleqiao/article/details/50511279">SSD的工作原理、GC和TRIM、写入放大以及性能评测</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>硬件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>服务器部署-CentOS-Windows-文件传输</title>
    <link href="/post/8649b4ed/"/>
    <url>/post/8649b4ed/</url>
    
    <content type="html"><![CDATA[<h1 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h1><p>上传文件总是逃不过的<br>借助第三方平台速度太慢，只能自己寻找协议/工具/代码来实现  </p><h1 id="Window端操作"><a href="#Window端操作" class="headerlink" title="Window端操作"></a>Window端操作</h1><h2 id="SCP命令"><a href="#SCP命令" class="headerlink" title="SCP命令"></a>SCP命令</h2><p><code>scp</code>是<code>secure copy</code>的简写，用于在Linux下进行远程拷贝文件的命令<br><code>scp</code>传输是加密的，速度相对于不加密的传输来说要慢（废话）<br><code>scp</code>还非常不占资源，不会提高多少系统负荷  </p><blockquote><p>在占资源这一点上，<code>rsync</code>就远远不及它了。虽然 <code>rsync</code>比<code>scp</code>会快一点，但当小文件众多的情况下，<code>rsync</code>会导致硬盘<code>I/O</code>非常高，而<code>scp</code>基本不影响系统正常使用。</p></blockquote><p><code>scp</code>是<code>linux</code>系统下基于<code>ssh</code>登陆进行安全的远程文件拷贝命令<br><code>linux</code>的<code>scp</code>命令可以在<code>linux</code>服务器之间复制文件和目录  </p><blockquote><p>注意，在cmd中要使用绝对路径  </p></blockquote><h2 id="SCP上传"><a href="#SCP上传" class="headerlink" title="SCP上传"></a>SCP上传</h2><p>将本地的文件/文件夹上传到目标服务器路径  </p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs inform7">scp <span class="hljs-comment">[本地文件路径（含文件名）]</span> <span class="hljs-comment">[SSH用户名]</span>@<span class="hljs-comment">[服务器IP]</span>:<span class="hljs-comment">[服务器上文件路径（不含文件名）]</span><br></code></pre></td></tr></table></figure><blockquote><p>案例：<code>a.txt</code>通过<code>root</code>用户的<code>SSH</code>传输到<code>/home/root</code>文件夹中  </p></blockquote><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir">scp a.txt root<span class="hljs-variable">@192</span>.<span class="hljs-number">168.1</span>.<span class="hljs-number">2</span><span class="hljs-symbol">:/home/root</span><br></code></pre></td></tr></table></figure><blockquote><p>在输入以后，会提示你输入root用户的SSH密码。输入正确以后就开始传输  </p></blockquote><h2 id="SCP下载"><a href="#SCP下载" class="headerlink" title="SCP下载"></a>SCP下载</h2><p>将目标服务器文件/文件夹下载到本地  </p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs inform7">scp <span class="hljs-comment">[SSH用户名]</span>@<span class="hljs-comment">[服务器IP]</span>:<span class="hljs-comment">[服务器上文件路径（含文件名）]</span> <span class="hljs-comment">[本地文件路径（不含文件名）]</span><br></code></pre></td></tr></table></figure><blockquote><p>案例：通过<code>SSH</code>的 <code>root</code>用户 从服务器<code>/home/root/a.txt</code>下载<code>a.txt</code>到/Documents/下  </p></blockquote><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir">scp root<span class="hljs-variable">@192</span>.<span class="hljs-number">168.1</span>.<span class="hljs-number">2</span><span class="hljs-symbol">:/home/root/a</span>.txt /Documents/ <br></code></pre></td></tr></table></figure><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><h3 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h3><p><code>SSH</code>默认22端口。如果不是22，就需要你填入一个参数<code>-P</code>  </p><blockquote><p>案例：<code>a.txt</code>通过 11024端口 的<code>SSH</code>的 manager用户 传输到<code>/home/manager</code>文件夹中  </p></blockquote><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir">scp -P <span class="hljs-number">11024</span> a.txt manager<span class="hljs-variable">@192</span>.<span class="hljs-number">168.1</span>.<span class="hljs-number">2</span><span class="hljs-symbol">:/home/manager</span><br></code></pre></td></tr></table></figure><h3 id="文件夹传输"><a href="#文件夹传输" class="headerlink" title="文件夹传输"></a>文件夹传输</h3><p>如果想要以文件夹为单位传输的话，加个<code>-r</code>参数。路径都改为文件夹路径即可  </p><blockquote><p>案例：将本地的<code>Documents</code>文件夹通过<code>root</code>用户<code>SSH</code>上传到<code>/home/root/folder</code> 下  </p></blockquote><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir">scp -r /Documents  root<span class="hljs-variable">@192</span>.<span class="hljs-number">168.1</span>.<span class="hljs-number">2</span><span class="hljs-symbol">:/home/root/folder</span>  <br></code></pre></td></tr></table></figure><h3 id="其它参数"><a href="#其它参数" class="headerlink" title="其它参数"></a>其它参数</h3><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>-1</td><td>强制scp命令使用协议ssh1</td></tr><tr><td>-2</td><td>强制scp命令使用协议ssh2</td></tr><tr><td>-4</td><td>强制scp命令只使用IPv4寻址</td></tr><tr><td>-6</td><td>强制scp命令只使用IPv6寻址</td></tr><tr><td>-B</td><td>使用批处理模式（传输过程中不询问传输口令或短语）</td></tr><tr><td>-C</td><td>允许压缩。（将-C标志传递给ssh，从而打开压缩功能）</td></tr><tr><td>-p</td><td>保留原文件的修改时间，访问时间和访问权限。</td></tr><tr><td>-q</td><td>不显示传输进度条。</td></tr><tr><td>-r</td><td>递归复制整个目录。</td></tr><tr><td>-v</td><td>详细方式显示输出。scp和ssh(1)会显示出整个过程的调试信息。这些信息用于调试连接，验证和配置问题。</td></tr><tr><td>-c</td><td>cipher 以cipher将数据传输进行加密，这个选项将直接传递给ssh。</td></tr><tr><td>-F</td><td>ssh_config 指定一个替代的ssh配置文件，此参数直接传递给ssh。</td></tr><tr><td>-i</td><td>identity_file 从指定文件中读取传输时使用的密钥文件，此参数直接传递给ssh。</td></tr><tr><td>-l</td><td>limit 限定用户所能使用的带宽，以Kbit/s为单位。</td></tr><tr><td>-o</td><td>ssh_option 如果习惯于使用ssh_config(5)中的参数传递方式，</td></tr><tr><td>-P</td><td>port 注意是大写的P, port是指定数据传输用到的端口号</td></tr><tr><td>-S</td><td>program 指定加密传输时所使用的程序。此程序必须能够理解ssh(1)的选项。</td></tr></tbody></table>]]></content>
    
    
    
    <tags>
      
      <tag>CentOS</tag>
      
      <tag>Windows</tag>
      
      <tag>服务器部署</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Blender-使用记录</title>
    <link href="/post/5e31e418/"/>
    <url>/post/5e31e418/</url>
    
    <content type="html"><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>官网下载：<a href="https://www.blender.org/download/">https://www.blender.org/download/</a><br>清华源下载：<a href="https://mirror.tuna.tsinghua.edu.cn/blender/blender-release/">https://mirror.tuna.tsinghua.edu.cn/blender/blender-release/</a></p><h1 id="个人设置"><a href="#个人设置" class="headerlink" title="个人设置"></a>个人设置</h1><h2 id="模拟maya视图操作"><a href="#模拟maya视图操作" class="headerlink" title="模拟maya视图操作"></a>模拟maya视图操作</h2><p>键位-3D视图<br>旋转视图 Alt+鼠标左键<br>平移视图 Alt+鼠标中间</p><h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><p>Add Curve:Extra Objects<br>Add Mesh:Extra Objects<br>Object:Bool Tool<br>Node:Node Wrangler<br>Mesh:Edit Mesh Tools<br>Interface:Modifier Tools<br>Interface:Copy Attributes Menu</p><h1 id="建模方法"><a href="#建模方法" class="headerlink" title="建模方法"></a>建模方法</h1><p>此处抽象的介绍一些建模方法大致效果，具体某个功能会有更多的可选细节  </p><h2 id="挤出"><a href="#挤出" class="headerlink" title="挤出"></a>挤出</h2><p><img src="/Blender-%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/jichu.gif">  </p><h2 id="环切"><a href="#环切" class="headerlink" title="环切"></a>环切</h2><p><img src="/Blender-%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/huanqie.gif">  </p><h2 id="倒角"><a href="#倒角" class="headerlink" title="倒角"></a>倒角</h2><p><img src="/Blender-%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/daojiao.gif">  </p><h2 id="内插面"><a href="#内插面" class="headerlink" title="内插面"></a>内插面</h2><p><img src="/Blender-%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/neichamian.gif">  </p><h2 id="切刀"><a href="#切刀" class="headerlink" title="切刀"></a>切刀</h2><p><img src="/Blender-%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/qiedao.gif">  </p><h2 id="切分"><a href="#切分" class="headerlink" title="切分"></a>切分</h2><p><img src="/Blender-%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/qiefen.gif">  </p><h2 id="旋绕"><a href="#旋绕" class="headerlink" title="旋绕"></a>旋绕</h2><p><img src="/Blender-%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/xuanrao.gif">  </p><h2 id="旋绕复制"><a href="#旋绕复制" class="headerlink" title="旋绕复制"></a>旋绕复制</h2><p><img src="/Blender-%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/xuanraofuzhi.gif">  </p><h2 id="光滑"><a href="#光滑" class="headerlink" title="光滑"></a>光滑</h2><p><img src="/Blender-%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/guanghua.gif">  </p><h2 id="随机"><a href="#随机" class="headerlink" title="随机"></a>随机</h2><p><img src="/Blender-%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/suiji.gif">  </p><h2 id="滑动边线"><a href="#滑动边线" class="headerlink" title="滑动边线"></a>滑动边线</h2><p><img src="/Blender-%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/huadongbianxian.gif">  </p><h2 id="法线缩放"><a href="#法线缩放" class="headerlink" title="法线缩放"></a>法线缩放</h2><p><img src="/Blender-%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/faxiangsuofang.gif">  </p><h2 id="推拉"><a href="#推拉" class="headerlink" title="推拉"></a>推拉</h2><p><img src="/Blender-%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/tuila.gif">  </p><h2 id="切变"><a href="#切变" class="headerlink" title="切变"></a>切变</h2><p><img src="/Blender-%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/qiebian.gif">  </p><h2 id="球型化"><a href="#球型化" class="headerlink" title="球型化"></a>球型化</h2><p><img src="/Blender-%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/qiouxinghua.gif">  </p><h2 id="断离区域"><a href="#断离区域" class="headerlink" title="断离区域"></a>断离区域</h2><p><img src="/Blender-%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/duanli.gif">   </p><h2 id="断离边线"><a href="#断离边线" class="headerlink" title="断离边线"></a>断离边线</h2><p><img src="/Blender-%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/duanli2.gif">   </p><h2 id="融并"><a href="#融并" class="headerlink" title="融并"></a>融并</h2><p><img src="/Blender-%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/rongbing.gif">   </p><h2 id="桥接循环边"><a href="#桥接循环边" class="headerlink" title="桥接循环边"></a>桥接循环边</h2><p><img src="/Blender-%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/qiaojiexunhuanbian.gif"><br><img src="/Blender-%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/qiaojiexunhuanbian2.gif">   </p><h2 id="实体化-solidify-Faces"><a href="#实体化-solidify-Faces" class="headerlink" title="实体化 solidify Faces"></a>实体化 solidify Faces</h2><p><img src="/Blender-%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/shitihua.gif">   </p><h2 id="线框"><a href="#线框" class="headerlink" title="线框"></a>线框</h2><p><img src="/Blender-%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/xiankuang.gif">   </p><h2 id="填充"><a href="#填充" class="headerlink" title="填充"></a>填充</h2><p><img src="/Blender-%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/tianchong.gif">   </p><h2 id="面三角化"><a href="#面三角化" class="headerlink" title="面三角化"></a>面三角化</h2><p><img src="/Blender-%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/sanjiaohua.gif">   </p><h2 id="三角面-gt-四边面"><a href="#三角面-gt-四边面" class="headerlink" title="三角面-&gt;四边面"></a>三角面-&gt;四边面</h2><p><img src="/Blender-%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/sanjiao_sibian.gif">   </p><h2 id="交集（切割）"><a href="#交集（切割）" class="headerlink" title="交集（切割）"></a>交集（切割）</h2><p><img src="/Blender-%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/jiaojiqiege.gif">   </p><h2 id="交集（布尔）"><a href="#交集（布尔）" class="headerlink" title="交集（布尔）"></a>交集（布尔）</h2><p><img src="/Blender-%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/jiaoji_bool.gif">   </p>]]></content>
    
    
    
    <tags>
      
      <tag>Blender</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Pymongo-Python-MongoDB</title>
    <link href="/post/940c0ef1/"/>
    <url>/post/940c0ef1/</url>
    
    <content type="html"><![CDATA[<h1 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h1><p>PyMongo是MongoDB数据库的python模块  </p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">pip <span class="hljs-keyword">install</span> pymongo<br></code></pre></td></tr></table></figure><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="创建连接"><a href="#创建连接" class="headerlink" title="创建连接"></a>创建连接</h2><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">from</span> pymongo import MongoClient<br><span class="hljs-keyword">client</span> = MongoClient(<span class="hljs-string">&quot;mongodb://mongodb0.example.net:27019&quot;</span>)<br></code></pre></td></tr></table></figure><blockquote><p>MongoClient(‘mongodb://用户名:用户密码@服务IP:服务端口/‘)</p></blockquote><h2 id="访问数据库-Database"><a href="#访问数据库-Database" class="headerlink" title="访问数据库 Database"></a>访问数据库 Database</h2><p>你可以使用属性访问的方式，赋值一个数据库（例如名字为primer）给本地变量db</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">db</span> = client.primer<br></code></pre></td></tr></table></figure><p>你也可以使用字典形式访问一个数据库</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">db</span> = client[<span class="hljs-string">&#x27;primer&#x27;</span>]<br></code></pre></td></tr></table></figure><blockquote><p>如果数据库不存在，那么会自动创建  </p></blockquote><h2 id="访问集合-Collection"><a href="#访问集合-Collection" class="headerlink" title="访问集合 Collection"></a>访问集合 Collection</h2><p>访问方式与访问database类似  </p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">coll</span> = db.dataset<br><span class="hljs-attr">coll</span> = db[<span class="hljs-string">&#x27;dataset&#x27;</span>]<br></code></pre></td></tr></table></figure><h2 id="访问文档-Document"><a href="#访问文档-Document" class="headerlink" title="访问文档 Document"></a>访问文档 Document</h2><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><blockquote><p>如果你所插入的集合在<code>MongoDB</code>中不存在，<code>MongoDB</code>将为你自动创建一个集合  </p></blockquote><h3 id="insert-one"><a href="#insert-one" class="headerlink" title="insert_one()"></a>insert_one()</h3><p>插入一条数据  </p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs makefile">con = MyMongo.get_mongo_connect()<br>mydb = con[<span class="hljs-string">&quot;temp&quot;</span>]<br>mycol = mydb[<span class="hljs-string">&quot;cx_sxb_school&quot;</span>]<br>mydict = &#123; <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;EvilRecluse&quot;</span>, <span class="hljs-string">&quot;url&quot;</span>: <span class="hljs-string">&quot;https://evilrecluse.top/&quot;</span> &#125;<br>x = mycol.insert_one(mydict) <br>print(result.inserted_id)<br></code></pre></td></tr></table></figure><p>操作会返回了一个<code>InsertOneResult</code>对象，它包括了<code>insert_id</code>属性表示被插入的文档的<code>_id</code>  </p><blockquote><p>如果你传递给<code>insert_one()</code>方法的参数不包含<code>_id</code>字段，<code>MongoClient</code>将自动添加这个字段并且生成一个<code>ObjectId</code>设置为这个字段的值。</p></blockquote><h3 id="insert-many"><a href="#insert-many" class="headerlink" title="insert_many()"></a>insert_many()</h3><p>插入多条数据  </p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs makefile">myclient = pymongo.MongoClient(<span class="hljs-string">&quot;mongodb://localhost:27017/&quot;</span>)<br>mydb = myclient[<span class="hljs-string">&quot;runoobdb&quot;</span>][<span class="hljs-string">&quot;sites&quot;</span>]<br>mylist = [<br>  &#123; <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;知乎&quot;</span>, <span class="hljs-string">&quot;url&quot;</span>: <span class="hljs-string">&quot;https://www.zhihu.com&quot;</span> &#125;,<br>  &#123; <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;Github&quot;</span>, <span class="hljs-string">&quot;url&quot;</span>: <span class="hljs-string">&quot;https://www.github.com&quot;</span> &#125;<br>]<br> <br>x = mycol.insert_many(mylist)<br>print(x.inserted_ids)<br></code></pre></td></tr></table></figure><h1 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h1><ul><li><p>find_one()<br>查询得到一个结果，通常用于看看搜索结果的样式  </p><blockquote><p>似乎并不能传进去什么参数，似乎就真的只能用来看看样式  </p></blockquote></li><li><p>find()<br>查询可以返回在集合中的所有数据或者只返回符合筛选条件<br>方法返回一个查询结果的游标，这是一个产生文档的迭代对象<br>如果不传入任何参数，则返回所有结果(如果数量庞大，当心内存炸裂)    </p><blockquote><p>查询type为1的记录，只返回它们的name</p>  <figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">_col_spider.<span class="hljs-builtin-name">find</span>(&#123;<span class="hljs-string">&#x27;type&#x27;</span>: 1&#125;, &#123;<span class="hljs-string">&#x27;_id&#x27;</span>: 0, <span class="hljs-string">&#x27;name&#x27;</span>:1&#125;)<br></code></pre></td></tr></table></figure><ul><li>参数1 dict<br>筛选条件，指定列名与指定s值，这里是指定 type为1  </li><li>参数2 dict<br>返回内容项，指定返回什么数据，值为1则返回，值为0则不返回<br>如果你只指定了0，那么剩余的都会被指定为1，反之亦然  </li></ul></blockquote><p>  需要注意的是，如果你不指定不返回’_id’，那么会默认返回这个项<br>  你可以使用比较运算符之类的操作，具体见<a href="/post/8ead567e/" title="比较逻辑">比较逻辑</a>  </p></li></ul><h3 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h3><h4 id="根据-id查询"><a href="#根据-id查询" class="headerlink" title="根据_id查询"></a>根据_id查询</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> bson.objectid <span class="hljs-keyword">import</span> ObjectId<br><br>articles.find_one(&#123;‘_id’:ObjectId(‘50f0d76347f4ec148890ef1e’)&#125;)<br></code></pre></td></tr></table></figure><h4 id="结果排序"><a href="#结果排序" class="headerlink" title="结果排序"></a>结果排序</h4><ul><li><p>sort() </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">database</span><span class="hljs-selector-class">.collect</span><span class="hljs-selector-class">.find</span>()<span class="hljs-selector-class">.sort</span>(<span class="hljs-selector-tag">key</span>, <span class="hljs-selector-tag">ind</span>)<br></code></pre></td></tr></table></figure><ul><li>key<br>用来排序的键  </li><li>ind<br>排序顺序，可以填入1或-1</li></ul><p>可以填入多个参照  </p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">database</span>.collect.find().sort([(key<span class="hljs-number">1</span>, ind<span class="hljs-number">1</span>), (key<span class="hljs-number">2</span>, ind<span class="hljs-number">2</span>)])<br></code></pre></td></tr></table></figure><h4 id="比较查询"><a href="#比较查询" class="headerlink" title="比较查询"></a>比较查询</h4></li></ul><table><thead><tr><th>&lt;</th><th>&lt;=</th><th>&gt;</th><th>&gt;=</th><th>!=</th></tr></thead><tbody><tr><td>$lt</td><td>$lte</td><td>$gt</td><td>$gte</td><td>$ne</td></tr></tbody></table><blockquote><p>如果你希望应对数据库中不存在的null，你可以在python中填入None来与之对应<br>案例：字段非空查询</p></blockquote><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">col.<span class="hljs-builtin-name">find</span>(&#123;<span class="hljs-string">&quot;字段名&quot;</span>:&#123;<span class="hljs-string">&quot;<span class="hljs-variable">$ne</span>&quot;</span>:None&#125;&#125;,&#123;&#125;)<br></code></pre></td></tr></table></figure><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><p>将某个数据记录的某系字段进行更改  </p><ul><li>update_one()<br>修改匹配的第一条记录<br>第一个参数为查询的条件，第二个参数为要修改的字段    <blockquote><p>案例：将name为DIO的记录的power项改为stander  </p></blockquote><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ada">mycol.update_one(<br>    &#123; <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;DIO&quot;</span> &#125;, &#123; <span class="hljs-string">&quot;$set&quot;</span>: &#123;<span class="hljs-symbol">&#x27;power</span><span class="hljs-string">&quot;:&quot;</span>stander<span class="hljs-string">&quot; &#125; &#125;)</span><br></code></pre></td></tr></table></figure></li><li>update_many()<br>修改匹配的所有记录<br>参数与<code>update_one</code>是一样的  <blockquote><p>案例：修改所有name是JO开头的power项值为1000000  </p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">mycol.update_many(&#123;<span class="hljs-string">&quot;name&quot;</span>: &#123; <span class="hljs-string">&quot;<span class="hljs-variable">$regex</span>&quot;</span>: <span class="hljs-string">&quot;^JO&quot;</span> &#125; &#125;, &#123; <span class="hljs-string">&quot;<span class="hljs-variable">$set</span>&quot;</span>: &#123; <span class="hljs-string">&quot;power&quot;</span>: <span class="hljs-string">&quot;1000000&quot;</span> &#125; &#125;)<br></code></pre></td></tr></table></figure><h2 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h2>将旧的文档丢弃，传入一个新的文档替代原本的文档  </li><li>update()<br>替代文档对应原来的文档可以有不同的字段<br>替代文档可以忽略_id字段因为它是不变的。(如果你硬是要填入那它必须和原文档的值相同)  <blockquote></blockquote><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs applescript"><span class="hljs-literal">result</span> = db.restaurants.replace_one(<br>    &#123;<span class="hljs-string">&quot;_id&quot;</span>: <span class="hljs-string">&quot;5f60b67d7c68de24d1745024&quot;</span>&#125;,<br>    &#123;<br>        <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;DIO&quot;</span>,<br>        <span class="hljs-string">&quot;power&quot;</span>: <span class="hljs-string">&quot;The World&quot;</span><br>    &#125;<br>)<br></code></pre></td></tr></table></figure></li></ul><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><h3 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h3><ul><li>delete_one()<br>删除第一个匹配的项  <blockquote><p>案例：删除找寻出来第一个name为Jax的记录  </p></blockquote><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">mycol.delete<span class="hljs-constructor">_one(&#123; <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;Jax&quot;</span> &#125;)</span><br></code></pre></td></tr></table></figure></li><li>delete_many()<br>删除多个文档<br>如果不传入参数，则删除集合中的所有文档  <blockquote><p>案例：删除所有name以F开头的记录  </p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">mycol.delete_many(&#123; <span class="hljs-string">&quot;name&quot;</span>: &#123;<span class="hljs-string">&quot;<span class="hljs-variable">$regex</span>&quot;</span>: <span class="hljs-string">&quot;^F&quot;</span>&#125; &#125;)<br></code></pre></td></tr></table></figure><h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3></li><li>drop()<br>删除一个集合  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">mycol</span><span class="hljs-selector-class">.drop</span>()<br></code></pre></td></tr></table></figure><h2 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h2></li><li>aggregate  <blockquote><p>案例：<br>使用$group操作符去利用一个指定的键进行分组。在$group操作中，指定需要分组的字段为_id。$group通过字段路径访问字段，该字段需要有一个美元符号$作为前缀。$group操作可以使用累加器对本次分组进行计算。下面的例子将使用borough字段对restaurants集合进行操作，并且使用$sum累加器进行文档的统计计算。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">cursor = db.restaurants.aggregate(<br>    [<br>        &#123;<span class="hljs-string">&quot;<span class="hljs-variable">$group</span>&quot;</span>: &#123;<span class="hljs-string">&quot;_id&quot;</span>: <span class="hljs-string">&quot;<span class="hljs-variable">$borough</span>&quot;</span>, <span class="hljs-string">&quot;count&quot;</span>: &#123;<span class="hljs-string">&quot;<span class="hljs-variable">$sum</span>&quot;</span>: 1&#125;&#125;&#125;<br>    ]<br>)<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>MongoDB</tag>
      
      <tag>Pymongo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Scrapy-基础-Shell</title>
    <link href="/post/f1278502/"/>
    <url>/post/f1278502/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><code>Scrapy``shell</code> 是一个快速debug交互<code>shell</code>，一般被用于做数据抽取代码的测试工作，它得到的结果会和你在Python中跑出来的一样  </p><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="命令行启动"><a href="#命令行启动" class="headerlink" title="命令行启动"></a>命令行启动</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">scrapy shell <span class="hljs-string">&quot;url&quot;</span><br></code></pre></td></tr></table></figure><p>这是最基本的启动方式  </p><blockquote><p>注意:双引号不要去除，也不要用单引号来替代</p></blockquote><p>你也以用<code>shell</code>来加载本地文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">scrapy shell /path/file.html<br></code></pre></td></tr></table></figure><blockquote><ul><li>如果使用相对路径，使用./或../开头  </li><li><code>scrapy shell index.html</code>并不会工作<blockquote><p><code>scrapy shell index.html</code>并不会工作原因<br>这并不是一个bug，<code>shell</code>会将<code>index.html</code>当成一个域名来处理，将它丢给DNS来解析，结果自然是没有正确的解析的  </p></blockquote></li></ul></blockquote><p>你也可以设置请求头来访问  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">scrapy shell -s USER_AGENT=<span class="hljs-string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:61.0) Gecko/20100101 Firefox/61.0&quot;</span> <span class="hljs-string">&quot;https://www.jianshu.com/recommendations/users?page=1&quot;</span><br></code></pre></td></tr></table></figure><h2 id="代码启动"><a href="#代码启动" class="headerlink" title="代码启动"></a>代码启动</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">inspect_response(response, self)<br></code></pre></td></tr></table></figure><p><code>response</code>参数是<code>parse</code>方法中的参数，<code>self</code>是<code>Spider</code>类的参数<br>在适当的地方启用shell能达到很好的目的（比如说使用<code>catch.....except</code>捕获错误以后，看看为什么解析错误报错之类）  </p><h1 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h1><h2 id="捷径"><a href="#捷径" class="headerlink" title="捷径"></a>捷径</h2><p><img src="/Scrapy-%E5%9F%BA%E7%A1%80-Shell/20200916075633932.png"><br>在你打开<code>shell</code>之后，会显示一些捷径提示，你可以在<code>shell</code>中使用这些捷径来快速做事  </p><h2 id="可用的Scrapy对象"><a href="#可用的Scrapy对象" class="headerlink" title="可用的Scrapy对象"></a>可用的Scrapy对象</h2><p>Shell中有一些自动创建的对象  </p><ul><li><p><code>crawler</code> - 当前<code>crawler</code>对象  </p></li><li><p><code>spider</code> - 当前url的spider对象  </p></li><li><p><code>request</code> - 最后请求的页面对象的<code>Request</code>对象. 你可以使用<code>replace()</code>来更改这个对象.你也可以用<code>fetch</code>捷径来接收一个新的<code>request</code></p></li><li><p><code>response</code> - 装则响应的<code>Response</code>对象  </p></li><li><p><code>settings</code> - Scrapy设置</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Scrapy</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MongoDB</title>
    <link href="/post/8ead567e/"/>
    <url>/post/8ead567e/</url>
    
    <content type="html"><![CDATA[<h1 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h1><p><code>MongoDB</code> 是一个由<code>C++</code>编的 写基于分布式文件存储的数据库。旨在为 WEB 应用提供可扩展的高性能数据存储解决方案<br><code>MongoDB</code> 是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的  </p><h2 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h2><p><code>MongoDB</code> 将数据存储为一个文档，数据结构由键值对组成<br><code>MongoDB</code> 文档类似于 <code>JSON</code> 对象。字段值可以包含其他文档，数组及文档数组  </p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul><li><code>MongoDB</code> 是一个面向文档存储的数据库，操作起来比较简单和容易  </li><li>MongoDB记录中设置任何属性的索引来实现更快的排序  </li><li>可以通过本地或者网络创建数据镜像，这使得MongoDB有更强的扩展性  </li><li>如果负载的增加 ，它可以分布在计算机网络中的其他节点上这就是所谓的分片  </li><li>Mongo支持丰富的查询表达式。查询指令使用JSON形式的标记，可轻易查询文档中内嵌的对象及数组  </li><li>使用update()命令可以实现替换完成的文档（数据）或者一些指定的数据字段  </li><li>Map和Reduce。Map函数调用emit(key,value)遍历集合中所有的记录，将key与value传给Reduce函数进行处理  </li><li>Map函数和Reduce函数是使用Javascript编写的，并可以通过db.runCommand或mapreduce命令来执行MapReduce操作  </li><li>GridFS是MongoDB中的一个内置功能，可以用于存放大量小文件  </li><li>MongoDB允许在服务端执行脚本，可以用Javascript编写某个函数，直接在服务端执行，也可以把函数的定义存储在服务端，下次直接调用  </li></ul><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p>官网：<a href="https://www.mongodb.com/">https://www.mongodb.com/</a>  </p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h2 id="Docker安装"><a href="#Docker安装" class="headerlink" title="Docker安装"></a>Docker安装</h2><ol><li><p>拉取镜像  </p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">docker pull mongo</span><br></code></pre></td></tr></table></figure><p> 如果想要安装非最新版，可以查询<a href="https://hub.docker.com/_/mongo?tab=tags&page=1">Docker镜像信息</a>信息<br>或者使用<code>docker search mongo</code>来查看可用版本    </p><blockquote><p>在拉取完毕后，可以使用<code>docker images</code>来查看镜像信息</p></blockquote></li><li><p>运行容器  </p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> run -itd --name mongo -p <span class="hljs-number">27018</span>:<span class="hljs-number">27017</span> mongo --auth<br></code></pre></td></tr></table></figure><ul><li>-p 27018:27017<br>映射容器服务的<code>27017</code>端口到宿主机的<code>27018</code>端口。外部可以直接通过<code>ip:27018</code> 访问到<code>mongo</code>的服务</li><li>–auth<br>需要密码才能访问容器服务  </li><li>-itd<br>实际上是<code>-i</code> <code>-t</code> <code>-d</code>的简写  <ul><li><code>-i</code> 以交互模式运行容器，通常与 <code>-t</code> 同时使用  </li><li><code>-t</code>    为容器重新分配一个伪输入终端，通常与 <code>-i</code> 同时使用  </li><li><code>-d</code>    后台运行容器，并返回容器ID  </li></ul></li></ul></li></ol><blockquote><p>可以通过<code>docker ps</code>命令查看容器的运行信息</p></blockquote><ol><li>容器命令行进行交互  <figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sqf">docker <span class="hljs-built_in">exec</span> -it mongo mongo <span class="hljs-built_in">admin</span><br></code></pre></td></tr></table></figure>创建一个超级账户<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">db</span><span class="hljs-selector-class">.createUser</span>(&#123; <span class="hljs-attribute">user</span>:<span class="hljs-string">&#x27;用户名&#x27;</span>,<span class="hljs-attribute">pwd</span>:<span class="hljs-string">&#x27;密码&#x27;</span>,<span class="hljs-attribute">roles</span>:[ &#123; <span class="hljs-attribute">role</span>:<span class="hljs-string">&#x27;root&#x27;</span>, <span class="hljs-attribute">db</span>: <span class="hljs-string">&#x27;admin&#x27;</span>&#125;]&#125;);<br></code></pre></td></tr></table></figure>在创建完用户以后尝试使用新用户进行连接<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">db</span><span class="hljs-selector-class">.auth</span>(<span class="hljs-string">&#x27;用户名&#x27;</span>, <span class="hljs-string">&#x27;密码&#x27;</span>)<br></code></pre></td></tr></table></figure>如果正确可行的话，会返回1，这也意味着账户切换成功  </li></ol><h1 id="MongoDB名词概念"><a href="#MongoDB名词概念" class="headerlink" title="MongoDB名词概念"></a>MongoDB名词概念</h1><table><thead><tr><th>SQL术语/概念</th><th>MongoDB术语/概念</th></tr></thead><tbody><tr><td>database 数据库</td><td>database 数据库</td></tr><tr><td>table     数据库表</td><td>collection 集合</td></tr><tr><td>row     数据记录行</td><td>document 文档</td></tr><tr><td>column     数据字段</td><td>field    域</td></tr><tr><td>index   索引</td><td>index 索引</td></tr><tr><td>table joins表连接</td><td>不支持</td></tr><tr><td>primary key 主键</td><td>primary key     MongoDB自动将_id字段设置为主键</td></tr></tbody></table><p><img src="/MongoDB/20200911074758467.png">  </p><h1 id="数据库-database"><a href="#数据库-database" class="headerlink" title="数据库 database"></a>数据库 database</h1><p>一个<code>mongodb</code>中可以建立多个数据库<br><code>MongoDB</code>的默认数据库为”db”，该数据库存储在data目录中<br><code>MongoDB</code>的单个实例可以容纳多个独立的数据库，每一个都有自己的集合和权限，不同的数据库也放置在不同的文件中  </p><blockquote><p>数据库名为utf-8字符串,符合以下标准：</p></blockquote><ul><li>非空  </li><li>不含（空格)、.、$、/、\和\0 (空字符)  </li><li>字母全部小写  </li><li>小于64字节  </li></ul><h2 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h2><table><thead><tr><th>命令</th><th>信息</th></tr></thead><tbody><tr><td><code>show dbs</code></td><td>查询所有含有文档的数据库信息</td></tr><tr><td><code>db</code></td><td>显示当前数据库信息</td></tr><tr><td><code>use 数据库名</code></td><td>连接到指定数据库</br>如果数据库不存在则创建数据库</td></tr><tr><td><code>db.dropDatabase()</code></td><td>删除当前数据库</td></tr></tbody></table><h2 id="保留的数据库"><a href="#保留的数据库" class="headerlink" title="保留的数据库"></a>保留的数据库</h2><p>有一些数据库名是保留的，可以直接访问这些有特殊作用的数据库。</p><table><thead><tr><th>保留数据库名</th><th>信息</th></tr></thead><tbody><tr><td>admin</td><td>从权限的角度来看，这是”root”数据库。要是将一个用户添加到这个数据库，这个用户自动继承所有数据库的权限。一些特定的服务器端命令也只能从这个数据库运行，比如列出所有的数据库或者关闭服务器</td></tr><tr><td>local</td><td>这个数据永远不会被复制，可以用来存储限于本地单台服务器的任意集合</td></tr><tr><td>config</td><td>当Mongo用于分片设置时，config数据库在内部使用，用于保存分片的相关信息</td></tr></tbody></table><h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><h2 id="常用操作-1"><a href="#常用操作-1" class="headerlink" title="常用操作"></a>常用操作</h2><h3 id="创建集合"><a href="#创建集合" class="headerlink" title="创建集合"></a>创建集合</h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">db.create<span class="hljs-constructor">Collection(<span class="hljs-params">name</span>, <span class="hljs-params">options</span>)</span><br></code></pre></td></tr></table></figure><ul><li><p>name：集合名</p></li><li><p>option：可选参数</p><ul><li><p>capped（bool)<br> 如果为 true，则创建固定集合。为 true 时，必须指定 size 参数  </p><blockquote><p>固定集合是指有着固定大小的集合，当达到最大值时，它会自动覆盖最早的文档  </p></blockquote></li><li><p>size (int)<br> 为固定集合指定一个最大值，即字节数<br> 如果 capped 为 true，也需要指定该字段  </p></li><li><p>max (int)<br> 指定固定集合中包含文档的最大数量  </p></li></ul></li></ul><h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-keyword">use</span> <span class="hljs-keyword">test</span><br>&gt;&gt;&gt;switched to <span class="hljs-keyword">db</span> <span class="hljs-keyword">test</span><br><span class="hljs-keyword">db</span>.createCollection(<span class="hljs-string">&quot;runoob&quot;</span>)<br>&gt;&gt;&gt;&#123; <span class="hljs-string">&quot;ok&quot;</span> : 1 &#125;<br></code></pre></td></tr></table></figure><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">db.create<span class="hljs-constructor">Collection(<span class="hljs-string">&quot;mycol&quot;</span>, &#123; <span class="hljs-params">capped</span> : <span class="hljs-params">true</span>, <span class="hljs-params">autoIndexId</span> : <span class="hljs-params">true</span>, <span class="hljs-params">size</span> : 6142800, <span class="hljs-params">max</span> : 10000 &#125; )</span><br></code></pre></td></tr></table></figure><h3 id="查看集合"><a href="#查看集合" class="headerlink" title="查看集合"></a>查看集合</h3><p>命令有两个，随便一个都可以  </p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">show</span> collections<br><span class="hljs-keyword">show</span> <span class="hljs-keyword">tables</span><br></code></pre></td></tr></table></figure><h3 id="删除集合"><a href="#删除集合" class="headerlink" title="删除集合"></a>删除集合</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">db</span><span class="hljs-selector-class">.collection</span><span class="hljs-selector-class">.drop</span>()<br></code></pre></td></tr></table></figure><h4 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell">use mydb<br><span class="hljs-meta">&gt;</span><span class="bash">&gt;&gt;switched to db mydb</span><br><br>show collections<br><span class="hljs-meta">&gt;</span><span class="bash">&gt;&gt;mycol</span><br><span class="hljs-meta">&gt;</span><span class="bash">&gt;&gt;mycol2</span><br><span class="hljs-meta">&gt;</span><span class="bash">&gt;&gt;system.indexes</span><br><span class="hljs-meta">&gt;</span><span class="bash">&gt;&gt;runoob</span><br><br>show collections<br><span class="hljs-meta">&gt;</span><span class="bash">&gt;&gt;mycol</span><br><span class="hljs-meta">&gt;</span><span class="bash">&gt;&gt;system.indexes</span><br><span class="hljs-meta">&gt;</span><span class="bash">&gt;&gt;runoob</span><br></code></pre></td></tr></table></figure><h1 id="文档-Document"><a href="#文档-Document" class="headerlink" title="文档 Document"></a>文档 Document</h1><p>文档的数据结构和 JSON 基本一样<br>所有存储在集合中的数据都是 BSON 格式<br>BSON 是一种类似 JSON 的二进制形式的存储格式，是 Binary JSON 的简称  </p><ul><li>文档不需要设置相同的字段，相同的字段不需要相同的数据类型   </li><li>文档中的键/值对是有序的    </li><li>文档中的值不仅可以是在双引号里面的字符串，还可以是其他几种数据类型（甚至可以是整个嵌入的文档)  </li><li>区分类型和大小写  </li><li>文档不能有重复的键  </li><li>文档的键是字符串。除了少数例外情况，键可以使用任意UTF-8字符  </li></ul><blockquote><p>文档键命名规范：</p></blockquote><ul><li>键不能含有\0 (空字符)。这个字符用来表示键的结尾  </li><li>.和$有特别的意义，只有在特定环境下才能使用  </li><li>以下划线”_”开头的键是保留的(不是严格要求的)  </li></ul><h2 id="常用操作-2"><a href="#常用操作-2" class="headerlink" title="常用操作"></a>常用操作</h2><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><ul><li><p>db.collection.insertOne<br>如果主键存在则更新数据，如果不存在就插入数据  </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">db</span><span class="hljs-selector-class">.collection</span><span class="hljs-selector-class">.insertOne</span>(<br>   &lt;<span class="hljs-selector-tag">document</span>&gt;,<br>   &#123;<br>      <span class="hljs-attribute">writeConcern</span>: &lt;document&gt;<br>   &#125;<br>)<br></code></pre></td></tr></table></figure><ul><li><p>document：要写入的文档  </p></li><li><p>writeConcern：写入策略，默认为 1，即要求确认写操作，0 是不要求  </p></li><li><p>ordered：指定是否按顺序写入，默认 true，按顺序写入  </p><blockquote><p>案例  </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">db</span><span class="hljs-selector-class">.products</span><span class="hljs-selector-class">.insertOne</span>( &#123; <span class="hljs-attribute">item</span>: <span class="hljs-string">&quot;card&quot;</span>, qty: <span class="hljs-number">15</span> &#125; );<br></code></pre></td></tr></table></figure></blockquote></li></ul></li><li><p>db.collection.insertMany<br>向集合插入一个多个文档</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">db</span><span class="hljs-selector-class">.collection</span><span class="hljs-selector-class">.insertMany</span>(<br>   <span class="hljs-selector-attr">[ &lt;document 1&gt; , &lt;document 2&gt;, ... ]</span>,<br>   &#123;<br>      <span class="hljs-attribute">writeConcern</span>: &lt;document&gt;,<br>      ordered: &lt;boolean&gt;<br>   &#125;<br>)<br></code></pre></td></tr></table></figure><p>  参数与<code>db.collection.insertOne</code>一致  </p><blockquote><p>案例  往 products集合 插入一些数据  </p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">db</span><span class="hljs-selector-class">.products</span><span class="hljs-selector-class">.insertMany</span>( [<br>  &#123; <span class="hljs-attribute">item</span>: <span class="hljs-string">&quot;card&quot;</span>, <span class="hljs-attribute">qty</span>: <span class="hljs-number">15</span> &#125;,<br>  &#123; <span class="hljs-attribute">item</span>: <span class="hljs-string">&quot;envelope&quot;</span>, <span class="hljs-attribute">qty</span>: <span class="hljs-number">20</span> &#125;,<br>  &#123; <span class="hljs-attribute">item</span>: <span class="hljs-string">&quot;stamps&quot;</span> , <span class="hljs-attribute">qty</span>: <span class="hljs-number">30</span> &#125;<br>   ] );<br>&#125;<br></code></pre></td></tr></table></figure></blockquote></li><li><p>insert()<br>若插入的数据主键已经存在，则会抛<code>org.springframework.dao.DuplicateKeyException</code> 异常，提示主键重复，不保存当前数据  </p><blockquote><p>案例：向 runoob 数据库 的 col 集合中插入数据  </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">db</span><span class="hljs-selector-class">.col</span><span class="hljs-selector-class">.insert</span>(&#123;<span class="hljs-attribute">title</span>: <span class="hljs-string">&#x27;MongoDB 教程&#x27;</span>, <br>   description: <span class="hljs-string">&#x27;MongoDB 是一个 Nosql 数据库&#x27;</span>,<br>   by: <span class="hljs-string">&#x27;菜鸟教程&#x27;</span>,<br>   url: <span class="hljs-string">&#x27;http://www.runoob.com&#x27;</span>,<br>   tags: [<span class="hljs-string">&#x27;mongodb&#x27;</span>, <span class="hljs-string">&#x27;database&#x27;</span>, <span class="hljs-string">&#x27;NoSQL&#x27;</span>],<br>   likes: <span class="hljs-number">100</span><br>&#125;)<br></code></pre></td></tr></table></figure></blockquote></li></ul><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><ul><li><p><a href="https://docs.mongodb.com/manual/reference/method/db.collection.deleteOne/">db.collection.deleteOne</a><br>删除集合中的一个文档    </p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs dts">db.collection.deleteOne(<br>   <span class="hljs-params">&lt;filter&gt;</span>,<br>   &#123;<br><span class="hljs-symbol">      writeConcern:</span> <span class="hljs-params">&lt;document&gt;</span>,<br><span class="hljs-symbol">      collation:</span> <span class="hljs-params">&lt;document&gt;</span>,<br><span class="hljs-symbol">      hint:</span> <span class="hljs-params">&lt;document|string&gt;</span>    <span class="hljs-comment">// Available starting in MongoDB 4.4</span><br>   &#125;<br>)<br></code></pre></td></tr></table></figure><ul><li>filter<br>指定删除条件,如果设置为{}则删除第一个文档  </li><li>writeConcern<br>可选参数，写入关注，其值为一个文档  </li><li>collation<br>可选参数，指定用于操作的集合  </li><li>hint<br>可选参数，指定用于支持查询谓词的索引的文档或字符串  </li></ul><blockquote><p>假设现在有一个order集合，集合中有这么个文档  </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs css">&#123;<br>   <span class="hljs-attribute">_id</span>: <span class="hljs-built_in">ObjectId</span>(<span class="hljs-string">&quot;563237a41a4d68582c2509da&quot;</span>),<br>   stock: <span class="hljs-string">&quot;Brent Crude Futures&quot;</span>,<br>   qty: <span class="hljs-number">250</span>,<br>   type: <span class="hljs-string">&quot;buy-limit&quot;</span>,<br>   limit: <span class="hljs-number">48.90</span>,<br>   creationts: <span class="hljs-built_in">ISODate</span>(<span class="hljs-string">&quot;2015-11-01T12:30:15Z&quot;</span>),<br>   expiryts: <span class="hljs-built_in">ISODate</span>(<span class="hljs-string">&quot;2015-11-01T12:35:15Z&quot;</span>),<br>   client: <span class="hljs-string">&quot;Crude Traders Inc.&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>案例： 根据删除<code>_id</code>为<code>233</code>的文档  </p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">db.orders.deleteOne( &#123; <span class="hljs-string">&quot;_id&quot;</span> : <span class="hljs-type">ObjectId</span>(<span class="hljs-string">&quot;233&quot;</span>) &#125; );<br></code></pre></td></tr></table></figure></blockquote></li><li><p>db.collection.deleteMany<br>删除集合中所有符合<code>filter</code>的文档<br><a href="https://docs.mongodb.com/manual/reference/method/db.collection.deleteMany/">文档地址</a>  </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">db</span><span class="hljs-selector-class">.collection</span><span class="hljs-selector-class">.deleteMany</span>(<br>   &lt;<span class="hljs-selector-tag">filter</span>&gt;,<br>   &#123;<br>      <span class="hljs-attribute">writeConcern</span>: &lt;document&gt;,<br>      collation: &lt;document&gt;<br>   &#125;<br>)<br></code></pre></td></tr></table></figure><p>  参数同<code>db.collection.deleteOne</code>  </p><blockquote><p>案例<br>假设现在有一个order集合，集合中有这么个文档  </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs css">&#123;<br>  <span class="hljs-attribute">_id</span>: <span class="hljs-built_in">ObjectId</span>(<span class="hljs-string">&quot;563237a41a4d68582c2509da&quot;</span>),<br>  stock: <span class="hljs-string">&quot;Brent Crude Futures&quot;</span>,<br>  client: <span class="hljs-string">&quot;Crude Traders Inc.&quot;</span><br>&#125;<br>&#123;<br>  <span class="hljs-attribute">_id</span>: <span class="hljs-built_in">ObjectId</span>(<span class="hljs-string">&quot;123437a41a423423444509da&quot;</span>),<br>  stock: <span class="hljs-string">&quot;Brent Crude Futures&quot;</span>,<br>  client: <span class="hljs-string">&quot;Crude Traders Inc.&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>案例： 根据删除<code>client</code>为<code>Crude Traders Inc.</code>的文档  </p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">db.<span class="hljs-keyword">orders.deleteMany( </span>&#123; <span class="hljs-string">&quot;client&quot;</span> : <span class="hljs-string">&quot;Crude Traders Inc.&quot;</span> &#125; );<br></code></pre></td></tr></table></figure></blockquote><h3 id="更改"><a href="#更改" class="headerlink" title="更改"></a>更改</h3></li><li><p>db.collection.update<br>更新已存在的文档<br><a href="https://docs.mongodb.com/master/reference/command/update/">文档地址</a>  </p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs dts">db.collection.update(<br>   <span class="hljs-params">&lt;query&gt;</span>,<br>   <span class="hljs-params">&lt;update&gt;</span>,<br>   &#123;<br><span class="hljs-symbol">     upsert:</span> <span class="hljs-params">&lt;boolean&gt;</span>,<br><span class="hljs-symbol">     multi:</span> <span class="hljs-params">&lt;boolean&gt;</span>,<br><span class="hljs-symbol">     writeConcern:</span> <span class="hljs-params">&lt;document&gt;</span><br>   &#125;<br>)<br></code></pre></td></tr></table></figure><ul><li>query : update的查询条件，类似sql update查询内where后面的  </li><li>update : update的对象和一些更新的操作符（如$,$inc…）等，也可以理解为sql update查询内set后面的  </li><li>upsert : 可选，这个参数的意思是，如果不存在update的记录，是否插入objNew,true为插入，默认是false，不插入  </li><li>multi : 可选，mongodb 默认是false,只更新找到的第一条记录，如果这个参数为true,就把按条件查出来多条记录全部更新  </li><li>writeConcern :可选，抛出异常的级别  </li></ul><blockquote><p>假设现在有一个order集合，集合中有这么个文档  </p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>    <span class="hljs-attr">&quot;_id&quot;</span> : ObjectId(<span class="hljs-string">&quot;1&quot;</span>),<br>    <span class="hljs-attr">&quot;title&quot;</span> : <span class="hljs-string">&quot;MongoDB&quot;</span>,<br>    <span class="hljs-attr">&quot;description&quot;</span> : <span class="hljs-string">&quot;MongoDB 是一个 Nosql 数据库&quot;</span>,<br>&#125;<br></code></pre></td></tr></table></figure><p>案例：更改<code>title</code>为<code>mysql</code></p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vim">db.<span class="hljs-keyword">col</span>.<span class="hljs-keyword">update</span>(&#123;<span class="hljs-string">&#x27;title&#x27;</span>:<span class="hljs-string">&#x27;MongoDB&#x27;</span>&#125;,&#123;$<span class="hljs-keyword">se</span><span class="hljs-variable">t:</span>&#123;<span class="hljs-string">&#x27;title&#x27;</span>:<span class="hljs-string">&#x27;mysql&#x27;</span>&#125;&#125;)~~~<br>&gt;需要注意的是，这语句只会修改第一个发现的文档，如果想要修改多个，需要<br></code></pre></td></tr></table></figure><pre><code>  db.col.update(&#123;&#39;title&#39;:&#39;MongoDB&#39;&#125;,&#123;$set:&#123;&#39;title&#39;:&#39;mysqls&#39;&#125;&#125;,&#123;multi:true&#125;)  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">    <br>* <span class="hljs-selector-tag">db</span><span class="hljs-selector-class">.collection</span><span class="hljs-selector-class">.save</span>  <br>通过传入的文档来替换已有文档，主键存在就更新，不存在就插入  <br></code></pre></td></tr></table></figure></code></pre><p>db.collection.save(<br> <document>,<br> {<br>   writeConcern: <document><br> }<br>)</p></blockquote><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">  *</span> document : 文档数据  <br><span class="hljs-bullet">  *</span> writeConcern :可选，抛出异常的级别  <br><br>&gt;实际上就是用一个新的文档来覆盖旧的,关键是要让<span class="hljs-emphasis">_id主键一致    </span><br></code></pre></td></tr></table></figure><p>  db.col.save({</p><pre><code>  &quot;_id&quot; : ObjectId(&quot;1&quot;),  &quot;title&quot; : &quot;MongoDB&quot;,</code></pre><p>  })</p>  <figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs clean"><br>### 查询  <br>* find  <br></code></pre></td></tr></table></figure><p>db.collection.find(query, projection)</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">  *</span> query ：可选，使用查询操作符指定查询条件  <br><span class="hljs-bullet">  *</span> projection ：可选，使用投影操作符指定返回的键。查询时返回文档中所有键值， 只需省略该参数即可（默认省略）  <br><br>&gt;如果你希望返回比较好看的形式，可以用pretty<br></code></pre></td></tr></table></figure><p>db.col.find().pretty()</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs elixir">    实际上还有一个findOne方法专门用来找单个文档    <br><br><span class="hljs-comment">#### 比较逻辑   </span><br><br>|操作|格式|范例|RDBMS中的类似语句|<br>|--|--|--|--|<br>|等于|&#123;`&lt;key&gt;`<span class="hljs-symbol">:`&lt;value&gt;`</span>&#125;|db.col.find(&#123;<span class="hljs-string">&quot;by&quot;</span><span class="hljs-symbol">:<span class="hljs-string">&quot;123&quot;</span></span>&#125;).pretty()|where by = <span class="hljs-string">&#x27;123&#x27;</span>|<br>|小于|&#123;`&lt;key&gt;`<span class="hljs-symbol">:</span>&#123;<span class="hljs-variable">$lt</span><span class="hljs-symbol">:`&lt;value&gt;`</span>&#125;&#125;|db.col.find(&#123;<span class="hljs-string">&quot;likes&quot;</span><span class="hljs-symbol">:</span>&#123;<span class="hljs-variable">$lt</span><span class="hljs-symbol">:</span><span class="hljs-number">50</span>&#125;&#125;).pretty()|where likes &lt; <span class="hljs-number">50</span>|<br>|小于或等于|&#123;`&lt;key&gt;`<span class="hljs-symbol">:</span>&#123;<span class="hljs-variable">$lte</span><span class="hljs-symbol">:`&lt;value&gt;`</span>&#125;&#125;|db.col.find(&#123;<span class="hljs-string">&quot;likes&quot;</span><span class="hljs-symbol">:</span>&#123;<span class="hljs-variable">$lte</span><span class="hljs-symbol">:</span><span class="hljs-number">50</span>&#125;&#125;).pretty()|where likes &lt;= <span class="hljs-number">50</span>|<br>|大于|&#123;`&lt;key&gt;`<span class="hljs-symbol">:</span>&#123;<span class="hljs-variable">$gt</span><span class="hljs-symbol">:`&lt;value&gt;`</span>&#125;&#125;|db.col.find(&#123;<span class="hljs-string">&quot;likes&quot;</span><span class="hljs-symbol">:</span>&#123;<span class="hljs-variable">$gt</span><span class="hljs-symbol">:</span><span class="hljs-number">50</span>&#125;&#125;).pretty()|where likes &gt; <span class="hljs-number">50</span>|<br>|大于或等于|&#123;`&lt;key&gt;`<span class="hljs-symbol">:</span>&#123;<span class="hljs-variable">$gte</span><span class="hljs-symbol">:`&lt;value&gt;`</span>&#125;&#125;|db.col.find(&#123;<span class="hljs-string">&quot;likes&quot;</span><span class="hljs-symbol">:</span>&#123;<span class="hljs-variable">$gte</span><span class="hljs-symbol">:</span><span class="hljs-number">50</span>&#125;&#125;).pretty()|where likes &gt;= <span class="hljs-number">50</span>|<br>|不等于|&#123;`&lt;key&gt;`<span class="hljs-symbol">:</span>&#123;<span class="hljs-variable">$ne</span><span class="hljs-symbol">:`&lt;value&gt;`</span>&#125;&#125;|db.col.find(&#123;<span class="hljs-string">&quot;likes&quot;</span><span class="hljs-symbol">:</span>&#123;<span class="hljs-variable">$ne</span><span class="hljs-symbol">:</span><span class="hljs-number">50</span>&#125;&#125;).pretty()|where likes != <span class="hljs-number">50</span>|<br><br><span class="hljs-comment">#### 逻辑运算  </span><br>* <span class="hljs-keyword">and</span>  <br>同时传入多个键即可  <br></code></pre></td></tr></table></figure><p>db.col.find({key1:value1, key2:value2}).pretty()</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><br><span class="hljs-bullet">*</span> or  <br>使用关键词<span class="hljs-code">`$or`</span><br></code></pre></td></tr></table></figure><p>db.col.find(<br> {</p><pre><code>$or: [   &#123;key1: value1&#125;, &#123;key2:value2&#125;]</code></pre><p> }<br>).pretty()</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><br>#### Limit与Skip方法  <br>* Limit() 方法  <br>如果你需要在`MongoDB`中读取指定数量的数据记录，可以使用`MongoDB`的`Limit`方法  <br>`limit()`方法接受一个数字参数，该参数指定从MongoDB中读取的记录条数  <br>未指定`limit`方法中的参数则显示集合中的所有数据  <br></code></pre></td></tr></table></figure><p>db.COLLECTION_NAME.find().limit(NUMBER)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">&gt;</span><span class="bash">案例：查找前两条数据</span><br></code></pre></td></tr></table></figure><p>db.col.find({},{“title”:1,_id:0}).limit(2)</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><br>* Skip() 方法  <br>除了可以使用`limit`方法来读取指定数量的数据外，还可以使用`skip`方法来跳过指定数量的数据  <br>skip方法同样接受一个数字参数作为跳过的记录条数。默认参数为 <span class="hljs-number">0</span>   <br></code></pre></td></tr></table></figure><blockquote><p>db.COLLECTION_NAME.find().limit(NUMBER).skip(NUMBER)</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">&gt;</span><span class="bash">案例：查找第二条数据</span><br></code></pre></td></tr></table></figure><p>db.col.find({},{“title”:1,_id:0}).limit(1).skip(1)</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs clean"><br>#### 排序  <br>* sort() 方法  <br>`sort` 方法可以通过参数指定排序的字段，并使用 <span class="hljs-number">1</span> 和 <span class="hljs-number">-1</span> 来指定排序的方式  <br><span class="hljs-number">1</span> 为升序排列，而 <span class="hljs-number">-1</span> 是用于降序排列  <br></code></pre></td></tr></table></figure><p>db.COLLECTION_NAME.find().sort({KEY:1})</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs clean"><br># 索引  <br>索引通常能够极大的提高查询的效率  <br>索引是特殊的数据结构，索引存储在一个易于遍历读取的数据集合中，索引是对数据库表中一列或多列的值进行排序的一种结构  <br>&gt;如果没有索引，MongoDB在读取数据时必须扫描集合中的每个文件并选取那些符合查询条件的记录。这种扫描全集合的查询效率是非常低的，特别在处理大量的数据时，查询可以要花费几十秒甚至几分钟，这对网站的性能是非常致命的  <br><br>## 常用操作  <br>### 创建  <br></code></pre></td></tr></table></figure><p>db.collection.createIndex(keys, options)</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs gherkin"><br>|<span class="hljs-string">参数</span>|<span class="hljs-string">值类型</span>|<span class="hljs-string">信息</span>|<br>|<span class="hljs-string">--</span>|<span class="hljs-string">--</span>|<span class="hljs-string">--</span>|<br>|<span class="hljs-string">background</span>|<span class="hljs-string">Boolean</span>|<span class="hljs-string">建索引过程会阻塞其它数据库操作，background可指定以后台方式创建索引，即增加 &quot;background&quot; 可选参数。 &quot;background&quot; 默认值为false。</span>|<br>|<span class="hljs-string">unique</span>|<span class="hljs-string">Boolean</span>|<span class="hljs-string">建立的索引是否唯一。指定为true创建唯一索引。默认值为false.</span>|<br>|<span class="hljs-string">name</span>|<span class="hljs-string">string</span>|<span class="hljs-string">索引的名称。如果未指定，MongoDB的通过连接索引的字段名和排序顺序生成一个索引名称。</span>|<br>|<span class="hljs-string">dropDups</span>|<span class="hljs-string">Boolean</span>|<span class="hljs-string">3.0+版本已废弃。在建立唯一索引时是否删除重复记录,指定 true 创建唯一索引。默认值为 false.</span>|<br>|<span class="hljs-string">sparse</span>|<span class="hljs-string">Boolean</span>|<span class="hljs-string">对文档中不存在的字段数据不启用索引；这个参数需要特别注意，如果设置为true的话，在索引字段中不会查询出不包含对应字段的文档.。默认值为 false.</span><br>|<span class="hljs-string">expireAfterSeconds</span>|<span class="hljs-string">integer</span>|<span class="hljs-string">指定一个以秒为单位的数值，完成 TTL设定，设定集合的生存时间。</span>|<br>|<span class="hljs-string">v</span>|<span class="hljs-string">index version</span>|<span class="hljs-string">索引的版本号。默认的索引版本取决于mongod创建索引时运行的版本。</span>|<br>|<span class="hljs-string">weights</span>|<span class="hljs-string">document</span>|<span class="hljs-string">索引权重值，数值在 1 到 99,999 之间，表示该索引相对于其他索引字段的得分权重。</span>|<br>|<span class="hljs-string">default_language</span>|<span class="hljs-string">string</span>|<span class="hljs-string">对于文本索引，该参数决定了停用词及词干和词器的规则的列表。 默认为英语</span>|<br>|<span class="hljs-string">language_override</span>|<span class="hljs-string">string</span>|<span class="hljs-string">对于文本索引，该参数指定了包含在文档中的字段名，语言覆盖默认的language，默认值为 language.</span>|<br><br>&gt;案例：以`title`键建立索引<br></code></pre></td></tr></table></figure><p>db.col.createIndex({“title”:1})</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">&gt;案例：以`title`与`name`键在后台建立索引<br></code></pre></td></tr></table></figure><p>db.values.createIndex({title: 1, name: 1}, {background: true})</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">&gt;</span><span class="bash">通过在创建索引时加 background:<span class="hljs-literal">true</span> 的选项，让创建工作在后台执行</span><br><br><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">## 查看</span></span>  <br>* 查看集合索引  <br></code></pre></td></tr></table></figure><p>db.col.getIndexes()</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><br><span class="hljs-bullet">* </span>查看集合索引大小  <br></code></pre></td></tr></table></figure><p>db.col.totalIndexSize()</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs clean"><br>### 删除  <br>* 删除集合所有索引  <br></code></pre></td></tr></table></figure><p>db.col.dropIndexes()</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><br><span class="hljs-bullet">* </span>删除集合指定索引  <br></code></pre></td></tr></table></figure><p>db.col.dropIndex(“索引名称”)</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs"><br><br># 杂项  <br>## 条件操作符  <br><br>|一般操作符|Mongo操作符|意义|<br>|--|--|--|<br>|&gt; | $gt|大于|<br>|&lt; | $lt|小于|<br>|&gt;= | $gte|大于等于|<br>|&lt;= | $lte|小于等于|<br><br>## `$type` 操作符  <br>`$type`操作符是基于BSON类型来检索集合中匹配的数据类型，并返回结果   <br><br>|类型|数字|备注|<br>|--|--|<br>|Double|1 ||<br>|String|2 ||<br>|Object|3 ||<br>|Array|4 ||<br>|Binary data|5 ||<br>|Undefined|6|已废弃。|<br>|Object id|7 ||<br>|Boolean|8 ||<br>|Date|9 ||<br>|Null|10 ||<br>|Regular Expression|11 ||<br>|JavaScript|13| |<br>|Symbol|14 ||<br>|JavaScript (with scope)|15 ||<br>|32-bit integer|16 ||<br>|Timestamp|17 ||<br>|64-bit integer|18 ||<br>|Min key|255|Query with -1.|<br>|Max key|127 ||<br><br>&gt;案例：寻找标题为字符串类型的文档<br></code></pre></td></tr></table></figure><p>db.col.find({“title” : {$type : 2}})<br>db.col.find({“title” : {$type : ‘string’}})</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs"><br><br>## 聚合  <br>`MongoDB`中聚合(aggregate)主要用于处理数据(诸如统计平均值,求和等)，并返回计算后的数据结果  <br><br>### aggregate() 方法  <br>MongoDB中聚合的方法使用aggregate()  <br></code></pre></td></tr></table></figure><p>db.COLLECTION_NAME.aggregate(AGGREGATE_OPERATION)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash"><br>|表达式|描述|实例|<br>|--|--|--|<br>|<span class="hljs-variable">$sum</span>|计算总和。|`db.mycol.aggregate([&#123;<span class="hljs-variable">$group</span> : &#123;_id : <span class="hljs-string">&quot;<span class="hljs-variable">$by_user</span>&quot;</span>, num_tutorial : &#123;<span class="hljs-variable">$sum</span> : <span class="hljs-string">&quot;<span class="hljs-variable">$likes</span>&quot;</span>&#125;&#125;&#125;])` |<br>|<span class="hljs-variable">$avg</span>|计算平均值|`db.mycol.aggregate([&#123;<span class="hljs-variable">$group</span> : &#123;_id : <span class="hljs-string">&quot;<span class="hljs-variable">$by_user</span>&quot;</span>, num_tutorial : &#123;<span class="hljs-variable">$avg</span> : <span class="hljs-string">&quot;<span class="hljs-variable">$likes</span>&quot;</span>&#125;&#125;&#125;]) `|<br>|<span class="hljs-variable">$min</span>|获取集合中所有文档对应值得最小值。|`db.mycol.aggregate([&#123;<span class="hljs-variable">$group</span> : &#123;_id : <span class="hljs-string">&quot;<span class="hljs-variable">$by_user</span>&quot;</span>, num_tutorial : &#123;<span class="hljs-variable">$min</span> : <span class="hljs-string">&quot;<span class="hljs-variable">$likes</span>&quot;</span>&#125;&#125;&#125;])`|<br>|<span class="hljs-variable">$max</span>|获取集合中所有文档对应值得最大值。|`db.mycol.aggregate([&#123;<span class="hljs-variable">$group</span> : &#123;_id : <span class="hljs-string">&quot;<span class="hljs-variable">$by_user</span>&quot;</span>, num_tutorial : &#123;<span class="hljs-variable">$max</span> : <span class="hljs-string">&quot;<span class="hljs-variable">$likes</span>&quot;</span>&#125;&#125;&#125;])`|<br>|<span class="hljs-variable">$push</span>|在结果文档中插入值到一个数组中。|`db.mycol.aggregate([&#123;<span class="hljs-variable">$group</span> : &#123;_id : <span class="hljs-string">&quot;<span class="hljs-variable">$by_user</span>&quot;</span>, url : &#123;<span class="hljs-variable">$push</span>: <span class="hljs-string">&quot;<span class="hljs-variable">$url</span>&quot;</span>&#125;&#125;&#125;])`|<br>|<span class="hljs-variable">$addToSet</span>|在结果文档中插入值到一个数组中，但不创建副本。|`db.mycol.aggregate([&#123;<span class="hljs-variable">$group</span> : &#123;_id : <span class="hljs-string">&quot;<span class="hljs-variable">$by_user</span>&quot;</span>, url : &#123;<span class="hljs-variable">$addToSet</span> : <span class="hljs-string">&quot;<span class="hljs-variable">$url</span>&quot;</span>&#125;&#125;&#125;])`|<br>|<span class="hljs-variable">$first</span>|根据资源文档的排序获取第一个文档数据。|`db.mycol.aggregate([&#123;<span class="hljs-variable">$group</span> : &#123;_id : <span class="hljs-string">&quot;<span class="hljs-variable">$by_user</span>&quot;</span>, first_url : &#123;<span class="hljs-variable">$first</span> : <span class="hljs-string">&quot;<span class="hljs-variable">$url</span>&quot;</span>&#125;&#125;&#125;])`|<br>|<span class="hljs-variable">$last</span>|根据资源文档的排序获取最后一个文档数据|`db.mycol.aggregate([&#123;<span class="hljs-variable">$group</span> : &#123;_id : <span class="hljs-string">&quot;<span class="hljs-variable">$by_user</span>&quot;</span>, last_url : &#123;<span class="hljs-variable">$last</span> : <span class="hljs-string">&quot;<span class="hljs-variable">$url</span>&quot;</span>&#125;&#125;&#125;])`|<br><br>&gt;  <br></code></pre></td></tr></table></figure><p>{<br> _id: ObjectId(7df78ad8902c)<br> title: ‘MongoDB Overview’,<br> description: ‘MongoDB is no sql database’,<br> by_user: ‘runoob.com’,<br>},<br>{<br> _id: ObjectId(7df78ad8902d)<br> title: ‘NoSQL Overview’,<br> description: ‘No sql database is very fast’,<br> by_user: ‘runoob.com’,<br>},<br>{<br> _id: ObjectId(7df78ad8902e)<br> title: ‘Neo4j Overview’,<br> description: ‘Neo4j is no sql database’,<br> by_user: ‘Neo4j’,<br>},</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">&gt;</span><span class="bash">案例：计算每个作者所写的文章数</span> <br></code></pre></td></tr></table></figure><p>db.mycol.aggregate([{$group : {_id : “$by_user”, num_tutorial : {$sum : 1}}}])</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs gherkin"><br><span class="hljs-comment">### 管道的概念  </span><br>管道在`Unix`和`Linux`中一般用于将当前命令的输出结果作为下一个命令的参数。  <br><br>`MongoDB`的聚合管道将`MongoDB`文档在一个管道处理完毕后将结果传递给下一个管道处理。管道操作是可以重复的。  <br><br>&gt;表达式：处理输入文档并输出。表达式是无状态的，只能用于计算当前聚合管道的文档，不能处理其它的文档。<br><br>聚合框架中常用操作：<br><br>|<span class="hljs-string">运算符</span>|<span class="hljs-string">信息</span>|<br>|<span class="hljs-string">--</span>|<span class="hljs-string">--</span>|<br>|<span class="hljs-string">$project</span>|<span class="hljs-string">修改输入文档的结构。可以用来重命名、增加或删除域，也可以用于创建计算结果以及嵌套文档。</span>|<br>|<span class="hljs-string">$match</span>|<span class="hljs-string">用于过滤数据，只输出符合条件的文档。$match使用MongoDB的标准查询操作。</span>|<br>|<span class="hljs-string">$limit</span>|<span class="hljs-string">用来限制MongoDB聚合管道返回的文档数。</span>|<br>|<span class="hljs-string">$skip</span>|<span class="hljs-string">在聚合管道中跳过指定数量的文档，并返回余下的文档。</span>|<br>|<span class="hljs-string">$unwind</span>|<span class="hljs-string">将文档中的某一个数组类型字段拆分成多条，每条包含数组中的一个值。</span>|<br>|<span class="hljs-string">$group</span>|<span class="hljs-string">将集合中的文档分组，可用于统计结果。</span>|<br>|<span class="hljs-string">$sort</span>|<span class="hljs-string">将输入文档排序后输出。</span>|<br>|<span class="hljs-string">$geoNear</span>|<span class="hljs-string">输出接近某一地理位置的有序文档。</span>|<br><br>&gt;案例：结果中只有_id,tilte和author三个字段  <br></code></pre></td></tr></table></figure><p>db.article.aggregate(<br>  { $project : {</p><pre><code>  title : 1 ,  author : 1 ,</code></pre><p>  }}<br>);</p><pre><code>&gt;实际上有还有一个默认添加的字段`_id`，如果想要取消指定`_id:0`即可  </code></pre></li></ul><hr><p>未完成：<a href="https://www.runoob.com/mongodb/mongodb-replication.html">https://www.runoob.com/mongodb/mongodb-replication.html</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>MongoDB</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Charles-抓包</title>
    <link href="/post/cdc32bf4/"/>
    <url>/post/cdc32bf4/</url>
    
    <content type="html"><![CDATA[<h1 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h1><p><code>Charles</code>是一个Web代理（<a href="https://www.charlesproxy.com/documentation/additional/http-proxy/">HTTP Proxy</a> / <a href="https://www.charlesproxy.com/documentation/additional/http-monitor/">HTTP Monitor</a>）抓包工具<br><code>Charles</code>可以 接收/发送/记录 你的 请求/相应 网络数据  </p><p>官网：<a href="https://www.charlesproxy.com/">https://www.charlesproxy.com/</a><br>文档：<a href="https://www.charlesproxy.com/documentation/">https://www.charlesproxy.com/documentation/</a><br>下载：<a href="https://www.charlesproxy.com/download/">https://www.charlesproxy.com/download/</a>  </p><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul><li><a href="https://www.charlesproxy.com/documentation/proxying/ssl-proxying/"><code>SSL Proxying</code></a><br>能看到SSL的请求与响应  </li><li><a href="https://www.charlesproxy.com/documentation/proxying/throttling/"><code>Bandwidth Throttling</code></a>  </li><li>AJAX debugging<br>可以将<code>XML</code>/<code>JSON</code>格式的 请求/响应 以文本或树的形式展现出来  </li><li><a href="https://www.charlesproxy.com/documentation/additional/amf/">AMF</a><br>可以以树形视图查看Flash Remoting / Flex Remoting消息的内容  </li><li>可以重复发送特定的请求  </li><li>可以编辑请求来进行测试  </li><li>提供断点功能来拦截和编辑请求或响应  </li><li>使用W3C验证器验证记录的HTML，CSS和RSS / atom响应  </li></ul><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>下载：<a href="https://www.charlesproxy.com/download/">https://www.charlesproxy.com/download/</a><br>下载完毕以后直接安装即可  </p><blockquote><h2 id="破解"><a href="#破解" class="headerlink" title="破解"></a>破解</h2><p>安装以后，打开程序，找到输入注册码的项<br><img src="/Charles-%E6%8A%93%E5%8C%85/20200911114410472.png"><br>输入以下内容完成破解<br>Registered Name: <code>https://zhile.io</code><br>License Key: <code>48891cf209c6d32bf4</code>  </p></blockquote><h1 id="HTTP代理设置"><a href="#HTTP代理设置" class="headerlink" title="HTTP代理设置"></a>HTTP代理设置</h1><h2 id="PC代理端口号设置"><a href="#PC代理端口号设置" class="headerlink" title="PC代理端口号设置"></a>PC代理端口号设置</h2><p><img src="/Charles-%E6%8A%93%E5%8C%85/20200911115300285.png"><br><img src="/Charles-%E6%8A%93%E5%8C%85/20200911023407862.png"><br>可以在这里设置<code>Charles</code>的代理端口号<br>顺便把一些选项给打开  </p><h2 id="手机设置Charles代理"><a href="#手机设置Charles代理" class="headerlink" title="手机设置Charles代理"></a>手机设置<code>Charles</code>代理</h2><p>这里以<code>mumu模拟器为例</code><br><img src="/Charles-%E6%8A%93%E5%8C%85/mumu_proxry.gif"><br>在完毕以后，<code>Charles</code>会弹出是否允许的提问<br><img src="/Charles-%E6%8A%93%E5%8C%85/20200911020913026.png"><br>允许即可  </p><h1 id="HTTPS代理设置"><a href="#HTTPS代理设置" class="headerlink" title="HTTPS代理设置"></a>HTTPS代理设置</h1><p>如果想要让<code>Charles</code>抓取HTTPS包解析出正确的数据，就需要安装<code>Charles SSL证书</code>，让设备信任这个代理  </p><h2 id="PC-SSL设置"><a href="#PC-SSL设置" class="headerlink" title="PC SSL设置"></a>PC SSL设置</h2><h3 id="安装证书"><a href="#安装证书" class="headerlink" title="安装证书"></a>安装证书</h3><p><img src="/Charles-%E6%8A%93%E5%8C%85/20200911021937269.png"><br><img src="/Charles-%E6%8A%93%E5%8C%85/PC_install_CR.gif"><br>注意将证书存储改为：受信任的根证书颁发机构  </p><h3 id="接受设置"><a href="#接受设置" class="headerlink" title="接受设置"></a>接受设置</h3><p><img src="/Charles-%E6%8A%93%E5%8C%85/20200911023538442.png"><br><img src="/Charles-%E6%8A%93%E5%8C%85/20200911023644056.png"></p><h3 id="安卓安装证书"><a href="#安卓安装证书" class="headerlink" title="安卓安装证书"></a>安卓安装证书</h3><p><img src="/Charles-%E6%8A%93%E5%8C%85/Andr_install_CR.gif"><br>浏览器中打开 charlesproxy.com/getssl 下载证书安装即可  </p>]]></content>
    
    
    
    <tags>
      
      <tag>Charles</tag>
      
      <tag>抓包</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Frida</title>
    <link href="/post/ac853d21/"/>
    <url>/post/ac853d21/</url>
    
    <content type="html"><![CDATA[<p>Frida官方文档的食用记录  </p><h1 id="文档-网址"><a href="#文档-网址" class="headerlink" title="文档/网址"></a>文档/网址</h1><table><thead><tr><th>信息</th><th>网址</th></tr></thead><tbody><tr><td>Frida官网</td><td><a href="https://frida.re/">https://frida.re/</a></td></tr><tr><td>Frida官方文档</td><td><a href="https://frida.re/docs/home/">https://frida.re/docs/home/</a></td></tr></tbody></table><h1 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h1><h2 id="什么是Frida"><a href="#什么是Frida" class="headerlink" title="什么是Frida"></a>什么是<code>Frida</code></h2><p><code>Frida</code>是一个动态代码检查工具<br>它可以让你将<code>JavaScript</code>代码诸如到<code>Windows</code>,<code>macOS</code>,<code>Android</code>等系统的程序中<br><code>Frida</code>也为你提供了一些基于其API的小工具，你可以按需获取使用  </p><h2 id="Python-API-与-JavaScript-debugging"><a href="#Python-API-与-JavaScript-debugging" class="headerlink" title="Python API 与 JavaScript debugging"></a>Python API 与 JavaScript debugging</h2><p>Firda 是由C语言编写的。它将 GoogleV8引擎插入到目标进程中。在进程中，你的JS可以访问内存，hooking函数，甚至可以在进程内部调用函数来运行<br>这个过程是通过在程序和JS之间建立双向通信通道来进行的<br>使用Python和JS可以让你快速使用无风险API进行开发（无风险:Firida可以帮助你捕获异常或者错误，但是不会崩溃导致程序崩溃）<br>实际上你可以使用多种不同的方式来使用<code>Frida</code> Node.js, Python， Swift， .NET 都可以  </p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h1 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h1><pre><code></code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>Frida</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python-JPype-运行java代码</title>
    <link href="/post/a751dfb9/"/>
    <url>/post/a751dfb9/</url>
    
    <content type="html"><![CDATA[<h1 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h1><p>官网：<a href="http://jpype.sourceforge.net/">http://jpype.sourceforge.net/</a><br>官方文档：<a href="http://jpype.sourceforge.net/documentation.html">http://jpype.sourceforge.net/documentation.html</a></p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><blockquote><p><code>JPype</code>请务必不要用<code>pip</code>直接安装，直接安装的话可能会在运行的时候出现一些错误，例如找不到getDefaultJVMPath函数  </p></blockquote><h2 id="java环境安装"><a href="#java环境安装" class="headerlink" title="java环境安装"></a>java环境安装</h2><p>JRE下载：<a href="https://www.java.com/zh_CN/download/?bucket_value=desktop-baiduspider2-unknown&in_query=no">链接</a><br>JDK下载：<a href="https://www.oracle.com/java/technologies/javase/javase-jdk8-downloads.html">链接</a><br>下载完毕，直接安装即可<br>完毕以后，配置java环境变量：<a href="https://www.cnblogs.com/cnwutianhao/p/5487758.html">链接</a>  </p><h2 id="JPype安装"><a href="#JPype安装" class="headerlink" title="JPype安装"></a>JPype安装</h2><p>找寻对应自己版本的whl文件下载：<a href="https://www.lfd.uci.edu/~gohlke/pythonlibs/#jpype">whll链接</a><br>下载好以后用<code>pip</code>安装<code>whl文件</code>  </p><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="处理-java文件"><a href="#处理-java文件" class="headerlink" title="处理.java文件"></a>处理.java文件</h2><p><code>JPype</code>并不能直接运行<code>.java</code>代码<br>需要将<code>.java文件</code>代码转换<code>.class文件</code>后再转为<code>.jar文件</code>后才能用<code>JPype</code>运行  </p><h3 id="java转-class"><a href="#java转-class" class="headerlink" title=".java转.class"></a><code>.java</code>转<code>.class</code></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">javac 文件名bai.java<br></code></pre></td></tr></table></figure><blockquote><p>可能会遇到 GBK字符编码问题：<a href="https://blog.csdn.net/gao_zhennan/article/details/89261672">解决</a>  </p></blockquote><h3 id="class转-jar"><a href="#class转-jar" class="headerlink" title=".class转.jar"></a><code>.class</code>转<code>.jar</code></h3><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal">jar cvf [生成jar的名称.jar] [列出<span class="hljs-class"><span class="hljs-keyword">class</span>文件] </span><br></code></pre></td></tr></table></figure><h2 id="JPype代码编写"><a href="#JPype代码编写" class="headerlink" title="JPype代码编写"></a>JPype代码编写</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> jpype <span class="hljs-keyword">import</span> startJVM, JClass, getDefaultJVMPath, shutdownJVM<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_run_java_script</span>():</span><br>    <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    通过调用 java代码获取no</span><br><span class="hljs-string">    options = &#123;&#x27;jar_path&#x27;:jar路径&#125;</span><br><span class="hljs-string">    &#x27;&#x27;&#x27;</span><br>    <span class="hljs-comment"># 启动Java环境</span><br>    startJVM(<br>        getDefaultJVMPath(), <span class="hljs-comment">#  这里是jre的jvm.dll路径,这个方法能让JPype自动去获取，你可以自己写</span><br>        <span class="hljs-string">&quot;-ea&quot;</span>,<br>        <span class="hljs-string">&quot;-Djava.class.path=&quot;</span>+<span class="hljs-string">&quot;ddd.jar&quot;</span>) <span class="hljs-comment">#  jar路径</span><br><br>    <span class="hljs-comment"># 加载自定义的Java代码中的 Java类</span><br>    MyClass = JClass(<span class="hljs-string">&quot;MyClass&quot;</span>)<br>    <span class="hljs-comment"># Java类实例化</span><br>    myclass = MyClass()<br>    <span class="hljs-comment"># 执行成员方法</span><br>    myclass.hello()<br>    <span class="hljs-comment"># 关闭Java环境</span><br>    shutdownJVM()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>Java</tag>
      
      <tag>JPype</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Javascript-Babel</title>
    <link href="/post/2dd4e617/"/>
    <url>/post/2dd4e617/</url>
    
    <content type="html"><![CDATA[<h1 id="Babel是什么"><a href="#Babel是什么" class="headerlink" title="Babel是什么"></a>Babel是什么</h1><h2 id="Javascript标准ECMA"><a href="#Javascript标准ECMA" class="headerlink" title="Javascript标准ECMA"></a>Javascript标准ECMA</h2><p>百度百科：<a href="https://baike.baidu.com/item/ECMAScript/1889420?fr=aladdin">https://baike.baidu.com/item/ECMAScript/1889420?fr=aladdin</a><br>ES6支持表格：<a href="https://kangax.github.io/compat-table/es6">https://kangax.github.io/compat-table/es6</a>  </p><blockquote><p>Babel的作用<br>如果你的浏览器不支持ES6，Babel可以将将代码转换ES4或者其它版本，让你的浏览器支持  </p></blockquote><h2 id="什么是Babel"><a href="#什么是Babel" class="headerlink" title="什么是Babel"></a>什么是Babel</h2><p>官网描述：Babel 是一个工具链，主要用于将 <code>ECMAScript 2015+ </code>(EC6)版本的代码转换为向后兼容的 <code>JavaScript</code> 语法，以便能够运行在当前和旧版本的浏览器或其他环境中  </p><blockquote><p>例子： 实现语法转换</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// Babel 输入： ES6 箭头函数</span><br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>].map(<span class="hljs-function">(<span class="hljs-params">n</span>) =&gt;</span> n + <span class="hljs-number">1</span>);<br><br><span class="hljs-comment">// Babel 输出： ES5 语法实现的同等功能</span><br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>].map(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">n</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> n + <span class="hljs-number">1</span>;<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="插件化"><a href="#插件化" class="headerlink" title="插件化"></a>插件化</h2><p><code>Babel</code>构建在插件之上<br>使用现有的或者自己编写的插件可以组成一个转换管道<br>通过使用或创建一个 <code>preset</code> 即可轻松使用一组插件  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 一个插件就是一个函数</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">&#123;types: t&#125;</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> &#123;<br>    visitor: &#123;<br>      <span class="hljs-function"><span class="hljs-title">Identifier</span>(<span class="hljs-params">path</span>)</span> &#123;<br>        <span class="hljs-comment">// 翻转name: JavaScript -&gt; tpircSavaJ</span><br>        <span class="hljs-keyword">let</span> name = path.node.name; <br>        path.node.name = name.split(<span class="hljs-string">&#x27;&#x27;</span>).reverse().join(<span class="hljs-string">&#x27;&#x27;</span>);<br>      &#125;<br>    &#125;<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p><a href="https://www.babeljs.cn/docs/usage">https://www.babeljs.cn/docs/usage</a>  </p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ol><li><p>安装packages  </p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> install --save-dev @babel/core @babel/cli @babel/preset-env<br><span class="hljs-built_in">npm</span> install --save @babel/polyfill<br></code></pre></td></tr></table></figure></li><li><p>根目录下创建一个文件<code>babel.config.json</code>写入  </p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;presets&quot;</span>: [<br>    [<br>      <span class="hljs-string">&quot;@babel/env&quot;</span>,<br>      &#123;<br>        <span class="hljs-attr">&quot;targets&quot;</span>: &#123;<br>          <span class="hljs-attr">&quot;edge&quot;</span>: <span class="hljs-string">&quot;17&quot;</span>,<br>          <span class="hljs-attr">&quot;firefox&quot;</span>: <span class="hljs-string">&quot;60&quot;</span>,<br>          <span class="hljs-attr">&quot;chrome&quot;</span>: <span class="hljs-string">&quot;67&quot;</span>,<br>          <span class="hljs-attr">&quot;safari&quot;</span>: <span class="hljs-string">&quot;11.1&quot;</span>,<br>        &#125;,<br>        <span class="hljs-attr">&quot;useBuiltIns&quot;</span>: <span class="hljs-string">&quot;usage&quot;</span>,<br>      &#125;<br>    ]<br>  ]<br>&#125;<br></code></pre></td></tr></table></figure><p> 上面所列明的浏览器版本只是用于展示的示例（标明可以用什么版本以后的），你可以根据需要调整  </p></li><li><p>测试编译代码  </p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal">./node_modules/.bin/babel src --<span class="hljs-keyword">out</span>-dir <span class="hljs-class"><span class="hljs-keyword">lib</span></span><br></code></pre></td></tr></table></figure></li></ol><ul><li><p>src<br>输入js文件 目录/路径  </p></li><li><p>lib<br>输出js文件目录/路径  </p><p>如果填入文件路径，那么就编译单个文件<br>如果填入目录的话，里面所有的js文件都会被编译  </p></li></ul><p>在命令执行完毕后，输出目录会有对应代码出现  </p><h2 id="帮助"><a href="#帮助" class="headerlink" title="帮助"></a>帮助</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">.<span class="hljs-regexp">/node_modules/</span>.bin/babel --help<br></code></pre></td></tr></table></figure><h2 id="核心库基本使用"><a href="#核心库基本使用" class="headerlink" title="核心库基本使用"></a>核心库基本使用</h2><p><code>Babel</code>的核心功能位于<code>@babel/core</code>模块中<br>你可以这样子在js代码里引入  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> babel = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/core&quot;</span>);<br>babel.transform(<span class="hljs-string">&quot;code&quot;</span>, optionsObject);<br></code></pre></td></tr></table></figure><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> babel = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/core&quot;</span>);<br><br><span class="hljs-keyword">const</span> code = <span class="hljs-string">`</span><br><span class="hljs-string">const sayHello = ()=&gt;&#123;</span><br><span class="hljs-string">    console.log(&#x27;Hello Babel&#x27;)</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">sayHello()</span><br><span class="hljs-string">`</span><br><span class="hljs-keyword">const</span> optionsObject = &#123;&#125;<br><span class="hljs-keyword">const</span> result = babel.transform(<span class="hljs-string">&quot;code&quot;</span>, optionsObject);<br><span class="hljs-built_in">console</span>.log(result)<br>&gt;&gt;&gt;&#123;<br>  metadata: &#123;&#125;,<br>  options: &#123;<br>    cloneInputAst: <span class="hljs-literal">true</span>,<br>    babelrc: <span class="hljs-literal">false</span>,<br>    configFile: <span class="hljs-literal">false</span>,<br>    passPerPreset: <span class="hljs-literal">false</span>,<br>    envName: <span class="hljs-string">&#x27;development&#x27;</span>,<br>    cwd: <span class="hljs-string">&#x27;F:\\Environment\\Node_js&#x27;</span>,<br>    root: <span class="hljs-string">&#x27;F:\\Environment\\Node_js&#x27;</span>,<br>    plugins: [],<br>    presets: [],<br>    parserOpts: &#123; <span class="hljs-attr">sourceType</span>: <span class="hljs-string">&#x27;module&#x27;</span>, <span class="hljs-attr">sourceFileName</span>: <span class="hljs-literal">undefined</span>, <span class="hljs-attr">plugins</span>: [] &#125;,<br>    generatorOpts: &#123;<br>      filename: <span class="hljs-literal">undefined</span>,<br>      auxiliaryCommentBefore: <span class="hljs-literal">undefined</span>,<br>      auxiliaryCommentAfter: <span class="hljs-literal">undefined</span>,<br>      retainLines: <span class="hljs-literal">undefined</span>,<br>      comments: <span class="hljs-literal">true</span>,<br>      shouldPrintComment: <span class="hljs-literal">undefined</span>,<br>      compact: <span class="hljs-string">&#x27;auto&#x27;</span>,<br>      minified: <span class="hljs-literal">undefined</span>,<br>      sourceMaps: <span class="hljs-literal">false</span>,<br>      sourceRoot: <span class="hljs-literal">undefined</span>,<br>      sourceFileName: <span class="hljs-string">&#x27;unknown&#x27;</span><br>    &#125;<br>  &#125;,<br>  ast: <span class="hljs-literal">null</span>,<br>  code: <span class="hljs-string">&quot;const sayHello = () =&gt; &#123;\n  console.log(&#x27;Hello Babel&#x27;);\n&#125;;\n\nsayHello();&quot;</span>,<br>  map: <span class="hljs-literal">null</span>,<br>  sourceType: <span class="hljs-string">&#x27;module&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>因为没有指定需要适应什么东西，所以ES6的代码并没有转换  </p><h1 id="babel-parser"><a href="#babel-parser" class="headerlink" title="@babel/parser"></a>@babel/parser</h1><p><code>Babel parser</code>是一个<code>Babel</code>的<code>JavaScript</code>分析模块  </p><ul><li>默认启用的最新ECMAScript版本  </li><li>支持 JSX, Flow, Typescript  </li></ul><blockquote><p>这个模块是基于 <a href="https://github.com/marijnh/acorn">acorn</a> 和 <a href="https://github.com/RReverser/acorn-jsx">acorn-jsx</a> ，感谢<a href="https://github.com/RReverser">@RReverser</a> and <a href="https://github.com/marijnh">@marijnh</a></p></blockquote><h2 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h2><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> install @babel/parser -g<br></code></pre></td></tr></table></figure><p>要装在哪里，是否全局安装，按照自己的情况来  </p><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><h3 id="解析函数"><a href="#解析函数" class="headerlink" title="解析函数"></a>解析函数</h3><ul><li><p>babelParser.parse(code, [options])<br><code>parse()</code>将提供的代码作为一个完整的<code>ECMAScript</code>程序进行解析  </p></li><li><p>babelParser.parseExpression(code, [options])<br>parseExpression() 用于解析单个<code>Expression</code>，当你性能比<code>parse()</code>要高  </p></li></ul><h4 id="Options参数"><a href="#Options参数" class="headerlink" title="Options参数"></a>Options参数</h4><ul><li><p>allowImportExportEverywhere<br>默认情况下，<code>import</code> 和 <code>export</code> 声明语句只能出现在程序的最顶层<br>把这个设置为<code>true</code>，可以使得语句在任何地方都可以声明  </p></li><li><p>allowAwaitOutsideFunction<br>默认情况下，仅在 异步函数内部 或 启用<code>topLevelAwait插件</code>时 在模块的顶层内允许使用<code>await</code><br>把这个设置为<code>true</code>，可以使得语句在任何地方都可以声明  </p></li><li><p>allowReturnOutsideFunction<br>默认情况下，如果在顶层中使用<code>return</code>语句会引起错误<br>把这个设置为<code>true</code>，就不会报错  </p></li><li><p>allowSuperOutsideMethod<br>默认情况下，在类和对象方法之外不允许使用<code>super</code><br>把这个设置为<code>true</code>就可以声明  </p></li><li><p>allowUndeclaredExports<br>默认情况下，<code>export</code>一个在当前作用域下未声明的内容会报错<br>把这个设置为<code>true</code>就可以防止解析器过早地抛出未声明的错误  </p></li><li><p>createParenthesizedExpressions<br>默认情况下，<code>parser</code>会在<code>expression</code>节点设置<code>extra.parenthesized</code><br>把这个设置为<code>true</code>，则会设置<code>ParenthesizedExpression</code>AST节点  </p></li><li><p>errorRecovery<br>默认情况下，如果<code>Babel</code>发现一些 不正常的代码 就会抛出错误<br>把这个设置为<code>true</code>，则会在保存解析错误的同时继续解析代码，错误的记录将被保存在 最终生成的AST的<code>errors</code>属性中<br>注意，那些严重的错误依然会终止解析  </p></li><li><p>plugins<br>记录希望启动的插件的数组  </p></li><li><p>sourceType<br>代码的解析方式，你可以填入<code>&quot;script&quot;</code>（默认）,<code>&quot;module&quot;</code> 或 <code>&quot;unambiguous&quot;</code><br>如果设置为”unambiguous”，那么系统会根据ES6语法中的<code>imports</code>和<code>export</code>来判断是<code>&quot;module&quot;</code>还是<code>&quot;script&quot;</code>  </p></li><li><p>sourceFilename<br>将输出的AST节点与其源文件名相关联<br>在你处理多个文件时，这个功能会很有用  </p></li><li><p>startLine<br>默认情况下，第一行代码就是<code>line 1</code>。你可以传入一个数字，作为起始行数<br>这个功能在你整合其他插件的时候会很有用  </p></li><li><p>strictMode<br>默认情况下，只有在声明了”use strict”条件下，ECMAScript代码才会被严格解析<br>将此选项设置为<code>true</code>则始终以严格模式解析文件  </p></li><li><p>ranges<br>添加ranges属性到每一个节点中  </p><blockquote><p>ranges: [node.start, node.end]</p></blockquote></li><li><p>tokens<br>将所有已经解析的<code>tokens</code>保存到<code>File</code>节点的<code>tokens</code>属性中  </p></li></ul><h2 id="输出-Output"><a href="#输出-Output" class="headerlink" title="输出 Output"></a>输出 Output</h2><p><code>Babel parser</code>是根据 <a href="https://github.com/babel/babel/tree/master/packages/babel-parser/ast/spec.md">Babel AST format</a> 创建AST的<br>而<code>Babel AST format</code>是基于 <a href="https://github.com/estree/estree">ESTree 规范</a> 建立的  </p><p><a href="https://github.com/estree/estree/blob/master/es5.md#literal">ESTree 代码生成对应节点文档</a><br><a href="https://github.com/babel/babel/blob/master/packages/babel-parser/ast/spec.md#stringliteral">Babel parser 代码生成对应节点文档</a></p><blockquote><p><code>Babel parser</code>与ESTree的不同之处  </p><ul><li>用<a href="https://github.com/babel/babel/tree/master/packages/babel-parser/ast/spec.md#stringliteral"><code>StringLiteral</code></a>, <a href="https://github.com/babel/babel/tree/master/packages/babel-parser/ast/spec.md#numericliteral"><code>NumericLiteral</code></a>, <a href="https://github.com/babel/babel/tree/master/packages/babel-parser/ast/spec.md#booleanliteral"><code>BooleanLiteral</code></a>, <a href="https://github.com/babel/babel/tree/master/packages/babel-parser/ast/spec.md#nullliteral"><code>NullLiteral</code></a>, <a href="https://github.com/babel/babel/tree/master/packages/babel-parser/ast/spec.md#regexpliteral"><code>RegExpLiteral</code></a>取代<a href="https://github.com/estree/estree/blob/master/es5.md#literal"><code>Literal</code></a>  </li><li>用 <a href="https://github.com/babel/babel/tree/master/packages/babel-parser/ast/spec.md#objectproperty"><code>ObjectProperty</code></a> 和 <a href="https://github.com/babel/babel/tree/master/packages/babel-parser/ast/spec.md#objectmethod"><code>ObjectMethod</code></a>取代<a href="https://github.com/estree/estree/blob/master/es5.md#property"><code>Property</code></a>  </li><li>用<a href="https://github.com/estree/estree/blob/master/es2015.md#methoddefinition"><code>MethodDefinition</code></a>取代<a href="https://github.com/babel/babel/tree/master/packages/babel-parser/ast/spec.md#classmethod"><code>ClassMethod</code></a></li><li><a href="https://github.com/babel/babel/tree/master/packages/babel-parser/ast/spec.md#programs"><code>Program</code></a> and <a href="https://github.com/babel/babel/tree/master/packages/babel-parser/ast/spec.md#blockstatement"><code>BlockStatement</code></a> 包含的<code>directives</code>用 <a href="https://github.com/babel/babel/tree/master/packages/babel-parser/ast/spec.md#directive"><code>Directive</code></a> 和 <a href="https://github.com/babel/babel/tree/master/packages/babel-parser/ast/spec.md#directiveliteral"><code>DirectiveLiteral</code></a>来填充  </li><li><a href="https://github.com/babel/babel/tree/master/packages/babel-parser/ast/spec.md#functionexpression"><code>FunctionExpression</code></a>中的 <a href="https://github.com/babel/babel/tree/master/packages/babel-parser/ast/spec.md#classmethod"><code>ClassMethod</code></a>, <a href="https://github.com/babel/babel/tree/master/packages/babel-parser/ast/spec.md#objectproperty"><code>ObjectProperty</code></a>,<a href="https://github.com/babel/babel/tree/master/packages/babel-parser/ast/spec.md#objectmethod"><code>ObjectMethod</code></a>属性被引入到<code>main方法</code>节点中  </li></ul></blockquote><h2 id="Semver"><a href="#Semver" class="headerlink" title="Semver"></a>Semver</h2><p>大多数情况下<code>Babel Parser</code>会遵循<code>Semver</code>规定  </p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-keyword">require</span>(<span class="hljs-string">&quot;@babel/parser&quot;</span>).parse(<span class="hljs-string">&quot;code&quot;</span>, &#123;<br>  /<span class="hljs-regexp">/ parse in strict mode and allow module declarations</span><br><span class="hljs-regexp">  sourceType: &quot;module&quot;,</span><br><span class="hljs-regexp"></span><br><span class="hljs-regexp">  plugins: [</span><br><span class="hljs-regexp">    /</span><span class="hljs-regexp">/ enable jsx and flow syntax</span><br><span class="hljs-regexp">    &quot;jsx&quot;,</span><br><span class="hljs-regexp">    &quot;flow&quot;</span><br><span class="hljs-regexp">  ]</span><br><span class="hljs-regexp">&#125;);</span><br></code></pre></td></tr></table></figure><p>剩余请看：<a href="https://www.babeljs.cn/docs/babel-parser">https://www.babeljs.cn/docs/babel-parser</a>  </p><h1 id="babel-traverse"><a href="#babel-traverse" class="headerlink" title="@babel/traverse"></a>@babel/traverse</h1><p>此库通常用于修改节点  </p><h2 id="安装-2"><a href="#安装-2" class="headerlink" title="安装"></a>安装</h2><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> install @babel/traverse -g<br></code></pre></td></tr></table></figure><p>要装在哪里，是否全局安装，按照自己的情况来  </p><h2 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> parser <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@babel/parser&quot;</span>;<br><span class="hljs-keyword">import</span> traverse <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@babel/traverse&quot;</span>;<br><br><span class="hljs-keyword">const</span> code = <span class="hljs-string">`function square(n) &#123;</span><br><span class="hljs-string">  return n * n;</span><br><span class="hljs-string">&#125;`</span>;<br><br><span class="hljs-keyword">const</span> ast = parser.parse(code);<br><br>traverse(ast, &#123;<br>  <span class="hljs-function"><span class="hljs-title">enter</span>(<span class="hljs-params">path</span>)</span> &#123;<br>    <span class="hljs-keyword">if</span> (path.isIdentifier(&#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;n&quot;</span> &#125;)) &#123;<br>      path.node.name = <span class="hljs-string">&quot;x&quot;</span>;<br>    &#125;<br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="安装-3"><a href="#安装-3" class="headerlink" title="安装"></a>安装</h2><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> install --save @babel/traverse<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Javascript</tag>
      
      <tag>Babel</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>javascript-控制流平坦化</title>
    <link href="/post/1cf031df/"/>
    <url>/post/1cf031df/</url>
    
    <content type="html"><![CDATA[<h1 id="有用的链接"><a href="#有用的链接" class="headerlink" title="有用的链接"></a>有用的链接</h1><p>在线开源混淆工具：<a href="https://obfuscator.io/">https://obfuscator.io</a><br>在线AST解析：<a href="https://astexplorer.net/">https://astexplorer.net</a>  </p><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>通过引入状态机与循环，破坏代码上下文之间的阅读连续性和代码块之间的关联性<br>将若干个分散的小整体整合成一个巨大的循环体  </p><ul><li>无法还原成原来具体的函数  </li><li>无法以函数为单位的调试方法，大幅度增加调试难度  </li><li>降低代码运行效率，提高爬虫运行时执行js的资源成本  </li><li>可根据js运行时检测到的某些因素自由跳转到蜜罐或跳出代码执行  </li></ul><h2 id="描述过程的简单例子"><a href="#描述过程的简单例子" class="headerlink" title="描述过程的简单例子"></a>描述过程的简单例子</h2><p><img src="/javascript-%E6%8E%A7%E5%88%B6%E6%B5%81%E5%B9%B3%E5%9D%A6%E5%8C%96/20200831124831164.png">  例如图中的方式就是 将代码运行流程交给一个变量<code>next</code>来控制<br>每次执行完一小段代码后，都修改next的值，使得下次判断会执行另外的代码块  </p><h2 id="常见实现方式"><a href="#常见实现方式" class="headerlink" title="常见实现方式"></a>常见实现方式</h2><ol><li>多维数组<br><img src="/javascript-%E6%8E%A7%E5%88%B6%E6%B5%81%E5%B9%B3%E5%9D%A6%E5%8C%96/20200831010457188.png">  </li><li>数值比较<br><img src="/javascript-%E6%8E%A7%E5%88%B6%E6%B5%81%E5%B9%B3%E5%9D%A6%E5%8C%96/20200831010519241.png">  </li></ol><h3 id="总体"><a href="#总体" class="headerlink" title="总体"></a>总体</h3><p><img src="/javascript-%E6%8E%A7%E5%88%B6%E6%B5%81%E5%B9%B3%E5%9D%A6%E5%8C%96/20200831010617054.png"></p><h1 id="小规模控制流平坦化处理"><a href="#小规模控制流平坦化处理" class="headerlink" title="小规模控制流平坦化处理"></a>小规模控制流平坦化处理</h1><h2 id="准备实验代码"><a href="#准备实验代码" class="headerlink" title="准备实验代码"></a>准备实验代码</h2><p>首先写一段js源码  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params"></span>)</span>&#123;<br>  <span class="hljs-keyword">var</span> i = [<span class="hljs-number">101</span>, <span class="hljs-number">102</span>, <span class="hljs-number">103</span>, <span class="hljs-number">104</span>, <span class="hljs-number">105</span>, <span class="hljs-number">106</span>, <span class="hljs-number">107</span>];<br>  i[<span class="hljs-number">1</span>] = i[<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>  output_str = [];<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> ind=<span class="hljs-number">0</span>; ind &lt; i.length; ind++)&#123;<br>  output_str.push(<span class="hljs-built_in">String</span>.fromCharCode(i[ind]))<br>  &#125;<br>  <span class="hljs-keyword">return</span> output_str<br>&#125;<br><span class="hljs-built_in">console</span>.log(test().join(<span class="hljs-string">&#x27;&#x27;</span>))<br></code></pre></td></tr></table></figure><p>拿去在线混淆网站混淆  <a href="https://obfuscator.io/">https://obfuscator.io/</a><br><img src="/javascript-%E6%8E%A7%E5%88%B6%E6%B5%81%E5%B9%B3%E5%9D%A6%E5%8C%96/20200831010352740.png"><br>输入原代码以后在下方设置混淆选项<br>然后点混淆拿到混淆后的代码，重新格式化以后拿到    </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> _0xf74e59 = &#123;<br>        <span class="hljs-string">&#x27;IvmKa&#x27;</span>: <span class="hljs-string">&#x27;1|3|2|0|4&#x27;</span>,<br>        <span class="hljs-string">&#x27;Ndyet&#x27;</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">_0x419593, _0x22a11f</span>) </span>&#123;<br>            <span class="hljs-keyword">return</span> _0x419593 &lt; _0x22a11f;<br>        &#125;,<br>        <span class="hljs-string">&#x27;STiJR&#x27;</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">_0x2d5759, _0x3449ae</span>) </span>&#123;<br>            <span class="hljs-keyword">return</span> _0x2d5759 + _0x3449ae;<br>        &#125;<br>    &#125;;<br>    <span class="hljs-keyword">var</span> _0x42bf99 = _0xf74e59[<span class="hljs-string">&#x27;IvmKa&#x27;</span>][<span class="hljs-string">&#x27;split&#x27;</span>](<span class="hljs-string">&#x27;|&#x27;</span>);<br>    <span class="hljs-keyword">var</span> _0x3c36ca = <span class="hljs-number">0x0</span>;<br>    <span class="hljs-keyword">while</span> (!![]) &#123;<br>        <span class="hljs-keyword">switch</span> (_0x42bf99[_0x3c36ca++]) &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;0&#x27;</span>:<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> _0x27bf7e = <span class="hljs-number">0x0</span>; _0xf74e59[<span class="hljs-string">&#x27;Ndyet&#x27;</span>](_0x27bf7e, _0x18a535[<span class="hljs-string">&#x27;length&#x27;</span>]); _0x27bf7e++) &#123;<br>                    output_str[<span class="hljs-string">&#x27;push&#x27;</span>](<span class="hljs-built_in">String</span>[<span class="hljs-string">&#x27;fromCharCode&#x27;</span>](_0x18a535[_0x27bf7e]));<br>                &#125;<br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;1&#x27;</span>:<br>                <span class="hljs-keyword">var</span> _0x18a535 = [<span class="hljs-number">0x65</span>, <span class="hljs-number">0x66</span>, <span class="hljs-number">0x67</span>, <span class="hljs-number">0x68</span>, <span class="hljs-number">0x69</span>, <span class="hljs-number">0x6a</span>, <span class="hljs-number">0x6b</span>];<br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;2&#x27;</span>:<br>                output_str = [];<br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;3&#x27;</span>:<br>                _0x18a535[<span class="hljs-number">0x1</span>] = _0xf74e59[<span class="hljs-string">&#x27;STiJR&#x27;</span>](_0x18a535[<span class="hljs-number">0x1</span>], <span class="hljs-number">0x1</span>);<br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;4&#x27;</span>:<br>                <span class="hljs-keyword">return</span> output_str;<br>        &#125;<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br><span class="hljs-built_in">console</span>[<span class="hljs-string">&#x27;log&#x27;</span>](test()[<span class="hljs-string">&#x27;join&#x27;</span>](<span class="hljs-string">&#x27;&#x27;</span>));<br></code></pre></td></tr></table></figure><p>代码特点：有一个循环来控制代码运行流程  </p><h2 id="处理思路"><a href="#处理思路" class="headerlink" title="处理思路"></a>处理思路</h2><ol><li>全局观察<br>大致观察每一个代码结构  </li></ol><ul><li><p>是否有类似于<code>DOM</code>操作的代码<br>Node.js环境下课没有DOM这种东西，运行会报错  </p></li><li><p>是否为纯计算型的循环体<br>如果只是纯粹的计算，那么拿到结果就好，过程并不重要<br>比如说上面的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> _0xf74e59 = &#123;<br>    <span class="hljs-string">&#x27;IvmKa&#x27;</span>: <span class="hljs-string">&#x27;1|3|2|0|4&#x27;</span>,<br>    <span class="hljs-string">&#x27;Ndyet&#x27;</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">_0x419593, _0x22a11f</span>) </span>&#123;<br>        <span class="hljs-keyword">return</span> _0x419593 &lt; _0x22a11f;<br>    &#125;,<br>    <span class="hljs-string">&#x27;STiJR&#x27;</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">_0x2d5759, _0x3449ae</span>) </span>&#123;<br>        <span class="hljs-keyword">return</span> _0x2d5759 + _0x3449ae;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>这种赋值，切割字符之类的，无二义性的东西直接记录一下结果就过了，不用管过程  </p></li><li><p>是否有<code>try-catch</code>异常捕获结构<br>比如说用<code>try-catch</code>包围一个DOM操作，Node.js执行的时候报错，捕获到错误以后，相当于代码识别出你不是浏览器了，之后就可以跳转到死机代码或直接跳出，达到防御目的  </p></li></ul><ol start="2"><li>整体分析与载入<br>推荐断点位置：</li></ol><ul><li>断点定于while开头部分  </li><li>断点定于try代码体第一行  </li></ul><p>while循环体整体取出构造原始函数  </p><ol start="3"><li>构造函数<br>查缺补漏，在运行过程中通过不断地运行报错，补充确实的函数或数据  </li></ol><h2 id="处理"><a href="#处理" class="headerlink" title="处理"></a>处理</h2><p>对于小型的代码混淆，也许你还能看得出入口和出口大概是在什么地方<br>但对于那种动则几千行的大型混淆来说，几乎就不能看出什么东西来了  </p><blockquote><p>大型代码混淆指不定会有蜜罐<br>比如说发现你没有DOM，给你吐脏数据<br>比如说上下两步操作实践超过时长，判定你打了断点，让你死机  </p></blockquote><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>由于这个函数没有传递参数，是相对固定的执行条件，那么可以通过输出每次执行的代码来得到代码的执行顺序<br>添加输出的这个操作可以通过AST来实现  </p><h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><p>将代码丢进 <a href="https://astexplorer.net/">https://astexplorer.net/</a> 进行AST分析  </p>]]></content>
    
    
    
    <tags>
      
      <tag>javascript</tag>
      
      <tag>爬虫</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Puppeteer-Pyppeteer</title>
    <link href="/post/54ad1f51/"/>
    <url>/post/54ad1f51/</url>
    
    <content type="html"><![CDATA[<h1 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h1><p><code>Puppeteer</code>是一个<code>Node</code> 库，它提供了一个高级 API 来通过 <code>DevTools</code> 协议控制 <code>Chromium</code> 或 <code>Chrome</code><br>有开发者开源了支持Python的<code>Puppeteer</code>库，名为<code>Pyppeteer</code></p><h1 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h1><table><thead><tr><th>内容</th><th>链接</th></tr></thead><tbody><tr><td>Puppeteer Github地址</td><td><a href="https://github.com/puppeteer/puppeteer">https://github.com/puppeteer/puppeteer</a></td></tr><tr><td>Pyppeteer Github地址</td><td><a href="https://github.com/miyakogi/pyppeteer">https://github.com/miyakogi/pyppeteer</a></br><a href="https://github.com/pyppeteer/pyppeteer">https://github.com/pyppeteer/pyppeteer</a></td></tr><tr><td>Pyppeteer 官方文档</td><td><a href="https://miyakogi.github.io/pyppeteer/reference.html#pyppeteer.browser.Browser">https://miyakogi.github.io/pyppeteer/ref……</a></td></tr><tr><td>Pyppeteer 网友中文文档</td><td><a href="https://blog.zhangkunzhi.com/2019/05/13/pyppeteer%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E6%89%8B%E5%86%8C/index.html">https://blog.zhangkunzhi.com/2019/0…..</a></td></tr></tbody></table><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>Puppeteer只能运行在python3.6+环境中  </p><p>Puppeteer API 是分层次的，反映了浏览器结构  </p><blockquote><p>注意：在下面的图表中，浅色框体内容目前不在 Puppeteer 中体现  </p></blockquote><p><img src="/Puppeteer-Pyppeteer/20200822070824427.png">  </p><p><code>Puppeteer</code> 使用 <code>DevTools</code> 协议 与浏览器进行通信。<br><code>Browser</code> 实例可以拥有浏览器上下文。<br><code>BrowserContext</code> 实例定义了一个浏览会话并可拥有多个页面。<br><code>Page</code> 至少有一个框架：主框架。 可能还有其他框架由 <code>iframe</code> 或 框<code>架标签</code> 创建。<br><code>frame</code> 至少有一个执行上下文 - 默认的执行上下文 - 框架的 <code>JavaScript</code> 被执行。 一个框架可能有额外的与 扩展 关联的执行上下文。<br>Worker 具有单一执行上下文，并且便于与 WebWorkers 进行交互。</p><h1 id="部分官方文档-中文文档-实践"><a href="#部分官方文档-中文文档-实践" class="headerlink" title="部分官方文档 中文文档 实践"></a>部分官方文档 中文文档 实践</h1><h2 id="0-Hello-World"><a href="#0-Hello-World" class="headerlink" title="0_Hello World"></a>0_Hello World</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python</span><br><span class="hljs-comment"># -*- encoding: utf-8 -*-</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">@File    :   0_hello_world.py</span><br><span class="hljs-string">@Time    :   2020/08/22 19:01:03</span><br><span class="hljs-string">@Author  :   Recluse Xu</span><br><span class="hljs-string">@Version :   1.0</span><br><span class="hljs-string">@Contact :   444640050@qq.com</span><br><span class="hljs-string">@Desc    :   pyppeteer Hello world 在第一次运行这个程序的时候，pyppeteer会从网上自己下载Chromium</span><br><span class="hljs-string">    官方文档：https://miyakogi.github.io/pyppeteer/reference.html#pyppeteer.page.Page.target</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><br><span class="hljs-comment"># here put the import lib</span><br><span class="hljs-keyword">import</span> asyncio<br><span class="hljs-keyword">from</span> pyppeteer <span class="hljs-keyword">import</span> launch<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    <span class="hljs-comment"># 创建浏览器对象</span><br>    browser = <span class="hljs-keyword">await</span> launch(&#123;<span class="hljs-string">&#x27;headless&#x27;</span>: <span class="hljs-literal">False</span>&#125;)<br>    <span class="hljs-comment"># 打开一个页面</span><br>    page = <span class="hljs-keyword">await</span> browser.newPage()<br>    <span class="hljs-comment"># 页面访问一个连接</span><br>    <span class="hljs-keyword">await</span> page.goto(<span class="hljs-string">&#x27;http://www.baidu.com&#x27;</span>)<br>    <span class="hljs-comment"># 给网页弄个截图</span><br>    <span class="hljs-keyword">await</span> page.screenshot(&#123;<span class="hljs-string">&#x27;path&#x27;</span>: <span class="hljs-string">&#x27;example/0_Basic_usage_of_the_library/pyppeteer/baidu.png&#x27;</span>&#125;)<br>    <span class="hljs-comment"># 关闭浏览器</span><br>    <span class="hljs-keyword">await</span> browser.close()<br><br>asyncio.get_event_loop().run_until_complete(main())<br><br></code></pre></td></tr></table></figure><h2 id="1-Launch-args"><a href="#1-Launch-args" class="headerlink" title="1_Launch_args"></a>1_Launch_args</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python</span><br><span class="hljs-comment"># -*- encoding: utf-8 -*-</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">@File    :   1_launch_args.py</span><br><span class="hljs-string">@Time    :   2020/08/22 19:31:40</span><br><span class="hljs-string">@Author  :   Recluse Xu</span><br><span class="hljs-string">@Version :   1.0</span><br><span class="hljs-string">@Contact :   444640050@qq.com</span><br><span class="hljs-string">@Desc    :   None</span><br><span class="hljs-string">    官方文档：https://miyakogi.github.io/pyppeteer/reference.html#pyppeteer.page.Page.target</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><br><span class="hljs-comment"># here put the import lib</span><br><span class="hljs-keyword">import</span> asyncio<br><span class="hljs-keyword">from</span> pyppeteer <span class="hljs-keyword">import</span> launch<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    <span class="hljs-comment"># 创建浏览器对象</span><br>    browser = <span class="hljs-keyword">await</span> launch(&#123;<br>        <span class="hljs-comment"># 无头模式</span><br>        <span class="hljs-string">&#x27;headless&#x27;</span>: <span class="hljs-literal">False</span>,<br>        <span class="hljs-comment"># 忽略https错误，默认false</span><br>        <span class="hljs-string">&#x27;ignorehttpserrrors&#x27;</span>: <span class="hljs-literal">True</span>,<br>        <span class="hljs-comment"># 界面大小</span><br>        <span class="hljs-string">&#x27;viewport&#x27;</span>: &#123;<span class="hljs-string">&#x27;width&#x27;</span>: <span class="hljs-number">1280</span>, <span class="hljs-string">&#x27;height&#x27;</span>: <span class="hljs-number">800</span>&#125;,<br>        <span class="hljs-comment"># 脚本执行完后是否自动关闭浏览器</span><br>        <span class="hljs-string">&#x27;autoClose&#x27;</span>: <span class="hljs-literal">True</span>,<br>        <span class="hljs-comment"># Chromium 或者 Chrome 的路径,如果填入的话，就不用默认的 Chromium</span><br>        <span class="hljs-comment"># &#x27;executablePath&#x27;: &#x27;&#x27;</span><br>        <span class="hljs-comment"># 用户数据目录的路径</span><br>        <span class="hljs-comment"># &#x27;userDataDir&#x27;: &#x27;example/0_Basic_usage_of_the_library/pyppeteer/&#x27;,</span><br>        <span class="hljs-comment"># 打印日志的日志级别。默认与根记录器</span><br>        <span class="hljs-comment"># &#x27;log level&#x27;: &#x27;&#x27;</span><br>        &#125;)<br><br>    page = <span class="hljs-keyword">await</span> browser.newPage()<br>    <span class="hljs-keyword">await</span> page.goto(<span class="hljs-string">&#x27;http://www.baidu.com&#x27;</span>)<br>    <span class="hljs-keyword">await</span> page.screenshot(&#123;<span class="hljs-string">&#x27;path&#x27;</span>: <span class="hljs-string">&#x27;example/0_Basic_usage_of_the_library/pyppeteer/baidu.png&#x27;</span>&#125;)<br>    <span class="hljs-keyword">await</span> browser.close()<br><br>asyncio.get_event_loop().run_until_complete(main())<br><br></code></pre></td></tr></table></figure><h2 id="2-BrowserClass"><a href="#2-BrowserClass" class="headerlink" title="2_BrowserClass"></a>2_BrowserClass</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python</span><br><span class="hljs-comment"># -*- encoding: utf-8 -*-</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">@File    :   2_BrowserClass.py</span><br><span class="hljs-string">@Time    :   2020-8-22 20:20:16</span><br><span class="hljs-string">@Author  :   Recluse Xu</span><br><span class="hljs-string">@Version :   1.0</span><br><span class="hljs-string">@Contact :   444640050@qq.com</span><br><span class="hljs-string">@Desc    :   浏览器类相关</span><br><span class="hljs-string">    官方文档：https://miyakogi.github.io/pyppeteer/reference.html#pyppeteer.page.Page.target</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><br><span class="hljs-comment"># here put the import lib</span><br><span class="hljs-keyword">import</span> asyncio<br><span class="hljs-keyword">from</span> pyppeteer <span class="hljs-keyword">import</span> launch<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    <span class="hljs-comment"># 创建浏览器对象</span><br>    browser = <span class="hljs-keyword">await</span> launch(&#123;<br>        <span class="hljs-string">&#x27;headless&#x27;</span>: <span class="hljs-literal">False</span>,<br>        <span class="hljs-string">&#x27;ignorehttpserrrors&#x27;</span>: <span class="hljs-literal">True</span>,<br>        <span class="hljs-string">&#x27;viewport&#x27;</span>: &#123;<span class="hljs-string">&#x27;width&#x27;</span>: <span class="hljs-number">1280</span>, <span class="hljs-string">&#x27;height&#x27;</span>: <span class="hljs-number">800</span>&#125;,<br>        <span class="hljs-string">&#x27;autoClose&#x27;</span>: <span class="hljs-literal">True</span>,<br>        &#125;)<br><br>    <span class="hljs-comment"># 创建一个新页面</span><br>    page = <span class="hljs-keyword">await</span> browser.newPage()<br><br>    <span class="hljs-comment"># 创建一个无痕模式浏览器内容， 以无痕模式内容浏览东西的话不会报错cookie之类的数据</span><br>    <span class="hljs-comment"># context = await browser.createIncognitoBrowserContext()</span><br>    <span class="hljs-comment"># page = await context.newPage()</span><br>    <span class="hljs-comment"># await page.goto(&#x27;https://example.com&#x27;)</span><br><br>    <span class="hljs-keyword">await</span> page.goto(<span class="hljs-string">&#x27;http://www.baidu.com&#x27;</span>)<br><br>    <span class="hljs-comment"># 获取网页中的所有内容</span><br>    c = browser.browserContexts<br>    print(c)<br><br>    <span class="hljs-comment"># 返回浏览器进程</span><br>    c = browser.process<br>    print(c)<br><br>    <span class="hljs-comment"># 返回浏览器UerAgent</span><br>    c = browser.userAgent<br>    print(c)<br><br>    <span class="hljs-comment"># 断开连接</span><br>    browser.disconnect()<br><br>asyncio.get_event_loop().run_until_complete(main())<br><br></code></pre></td></tr></table></figure><h2 id="3-BrowserContextClass"><a href="#3-BrowserContextClass" class="headerlink" title="3_BrowserContextClass"></a>3_BrowserContextClass</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python</span><br><span class="hljs-comment"># -*- encoding: utf-8 -*-</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">@File    :   3_BrowserContextClass.py</span><br><span class="hljs-string">@Time    :   2020-8-22 20:20:16</span><br><span class="hljs-string">@Author  :   Recluse Xu</span><br><span class="hljs-string">@Version :   1.0</span><br><span class="hljs-string">@Contact :   444640050@qq.com</span><br><span class="hljs-string">@Desc    :   浏览器内容类相关 BrowserContext Class</span><br><span class="hljs-string">    官方文档：https://miyakogi.github.io/pyppeteer/reference.html#pyppeteer.page.Page.target</span><br><span class="hljs-string">BrowserContext 类 提供了多个独立的浏览器会话  </span><br><span class="hljs-string">当浏览器启动，浏览器会创建一个默认的 BrowserContext实例，这个实例中包含了一个默认的page</span><br><span class="hljs-string">如果一个 BrowserContext实例 通过window.open打开了新的BrowserContext实例，那么新实例会附属于旧实例</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><br><span class="hljs-comment"># here put the import lib</span><br><span class="hljs-keyword">import</span> asyncio<br><span class="hljs-keyword">from</span> pyppeteer <span class="hljs-keyword">import</span> launch<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    browser = <span class="hljs-keyword">await</span> launch(&#123;<br>        <span class="hljs-string">&#x27;headless&#x27;</span>: <span class="hljs-literal">False</span>,<br>        <span class="hljs-string">&#x27;ignorehttpserrrors&#x27;</span>: <span class="hljs-literal">True</span>,<br>        <span class="hljs-string">&#x27;viewport&#x27;</span>: &#123;<span class="hljs-string">&#x27;width&#x27;</span>: <span class="hljs-number">1280</span>, <span class="hljs-string">&#x27;height&#x27;</span>: <span class="hljs-number">800</span>&#125;,<br>        <span class="hljs-string">&#x27;autoClose&#x27;</span>: <span class="hljs-literal">True</span>,<br>        &#125;)<br><br>    page = <span class="hljs-keyword">await</span> browser.newPage()<br>    <span class="hljs-keyword">await</span> page.goto(<span class="hljs-string">&#x27;http://www.baidu.com&#x27;</span>)<br><br>    context = browser.browserContexts[<span class="hljs-number">0</span>]<br><br>    <span class="hljs-comment"># 返回BrowserContext实例的浏览器</span><br>    c = context.browser<br>    print(c)<br><br>    <span class="hljs-comment"># 返回BrowserContext中所有激活的target</span><br>    c = context.targets()<br>    print(c)<br><br>    <span class="hljs-comment"># 关闭BrowserContext实例，属于其下的子BrowserContext实例也会被一并关闭</span><br>    context.close()<br><br><br>asyncio.get_event_loop().run_until_complete(main())<br><br></code></pre></td></tr></table></figure><h2 id="4-PageClass-Selector"><a href="#4-PageClass-Selector" class="headerlink" title="4_PageClass_Selector"></a>4_PageClass_Selector</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python</span><br><span class="hljs-comment"># -*- encoding: utf-8 -*-</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">@File    :   4_PageClass_Selector.py</span><br><span class="hljs-string">@Time    :   2020-8-22 20:20:16</span><br><span class="hljs-string">@Author  :   Recluse Xu</span><br><span class="hljs-string">@Version :   1.0</span><br><span class="hljs-string">@Contact :   444640050@qq.com</span><br><span class="hljs-string">@Desc    :   页面类 Page Class</span><br><span class="hljs-string">    官方文档：https://miyakogi.github.io/pyppeteer/reference.html#pyppeteer.page.Page.target</span><br><span class="hljs-string">Page类提供了与标签交互的方法，一个浏览器可以有多个Page对象</span><br><span class="hljs-string"></span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><br><span class="hljs-comment"># here put the import lib</span><br><span class="hljs-keyword">import</span> asyncio<br><span class="hljs-keyword">from</span> pyppeteer <span class="hljs-keyword">import</span> launch<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    browser = <span class="hljs-keyword">await</span> launch(&#123;<br>        <span class="hljs-string">&#x27;headless&#x27;</span>: <span class="hljs-literal">False</span>,<br>        <span class="hljs-string">&#x27;ignorehttpserrrors&#x27;</span>: <span class="hljs-literal">True</span>,<br>        <span class="hljs-string">&#x27;viewport&#x27;</span>: &#123;<span class="hljs-string">&#x27;width&#x27;</span>: <span class="hljs-number">1280</span>, <span class="hljs-string">&#x27;height&#x27;</span>: <span class="hljs-number">800</span>&#125;,<br>        <span class="hljs-string">&#x27;autoClose&#x27;</span>: <span class="hljs-literal">True</span>,<br>        &#125;)<br><br>    page = <span class="hljs-keyword">await</span> browser.newPage()<br>    <span class="hljs-keyword">await</span> page.goto(<span class="hljs-string">&#x27;http://www.baidu.com&#x27;</span>)<br><br>    <span class="hljs-comment"># Page.J(selector: str) 或者 Page.uerySelector() </span><br>    <span class="hljs-comment"># 方法可以通过 选择器 获取一个元素</span><br>    <span class="hljs-comment"># 如果方法找到与选择器匹配的元素，则返回其ElementHandle实例。如果没有找到，返回None。</span><br>    c = <span class="hljs-keyword">await</span> page.J(<span class="hljs-string">&quot;#s_lg_img&quot;</span>)<br>    print(c)<br><br>    <span class="hljs-comment"># Page.JJ(selector: str) 或者 Page.querySelectorAll()</span><br>    <span class="hljs-comment"># 方法可以通过 选择器 获取一些元素</span><br>    c = <span class="hljs-keyword">await</span> page.JJ(<span class="hljs-string">&quot;.c-color-gray2&quot;</span>)<br>    print(c)<br><br>    <span class="hljs-comment"># Page.Jeval(selector: str, pageFunction: str, *args) 或者 Page.querySelectorEval()</span><br>    <span class="hljs-comment"># 方法可以通过 选择器 获取 一个元素 ，并且将元素作为参数，传入到pageFunction中执行一些代码</span><br>    <span class="hljs-comment"># 如果这个函数没有找到匹配的元素，会报错</span><br>    <span class="hljs-comment"># 参数:</span><br>    <span class="hljs-comment"># selector 选择器字符串</span><br>    <span class="hljs-comment"># pageFunction (str) javascript回调函数，在找到元素一些以后，元素会以数组的形式当做一个参数传入到定义的回调函数中</span><br>    <span class="hljs-comment"># args (Any) – 可以传给pageFunction的参数</span><br>    c = <span class="hljs-keyword">await</span> page.Jeval(<span class="hljs-string">&quot;#s_lg_img&quot;</span>, <span class="hljs-string">&quot;function zxc(a)&#123;return &#x27;Found Element :&#x27; + a&#125;&quot;</span>)<br>    print(c)<br><br>    <span class="hljs-comment"># Page.JJeval(selector: str, pageFunction: str, *args) 或者 Page.querySelectorAllEval()</span><br>    <span class="hljs-comment"># 方法可以通过 选择器 获取 一些元素 ，并且将元素作为参数，传入到pageFunction中执行一些代码</span><br>    <span class="hljs-comment"># 如果这个函数没有找到匹配的元素，会报错</span><br>    <span class="hljs-comment"># 参数同上</span><br>    c = <span class="hljs-keyword">await</span> page.JJeval(<span class="hljs-string">&quot;.c-color-gray2&quot;</span>, <span class="hljs-string">&quot;function zxc(a)&#123;return &#x27;Found Element :&#x27; + a&#125;&quot;</span>)<br>    print(c)<br><br>    <span class="hljs-comment"># Page.Jx(expression: str) 或者 xpath()</span><br>    <span class="hljs-comment"># 传入xpath表达式，返回结果为list</span><br>    c = <span class="hljs-keyword">await</span> page.xpath(<span class="hljs-string">&#x27;//*[@id=&quot;s_lg_img&quot;]&#x27;</span>)<br>    print(c)<br><br><br>asyncio.get_event_loop().run_until_complete(main())<br><br></code></pre></td></tr></table></figure><h2 id="5-PageClass-Operations"><a href="#5-PageClass-Operations" class="headerlink" title="5_PageClass_Operations"></a>5_PageClass_Operations</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python</span><br><span class="hljs-comment"># -*- encoding: utf-8 -*-</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">@File    :   5_PageClass_Operations.py</span><br><span class="hljs-string">@Time    :   2020-8-22 23:03:54</span><br><span class="hljs-string">@Author  :   Recluse Xu</span><br><span class="hljs-string">@Version :   1.0</span><br><span class="hljs-string">@Contact :   444640050@qq.com</span><br><span class="hljs-string">@Desc    :   页面类 Page Class</span><br><span class="hljs-string">    官方文档：https://miyakogi.github.io/pyppeteer/reference.html#pyppeteer.page.Page.target</span><br><span class="hljs-string">Page类提供了与标签交互的方法，一个浏览器可以有多个Page对象</span><br><span class="hljs-string"></span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><br><span class="hljs-comment"># here put the import lib</span><br><span class="hljs-keyword">import</span> asyncio<br><span class="hljs-keyword">from</span> pyppeteer <span class="hljs-keyword">import</span> launch<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    browser = <span class="hljs-keyword">await</span> launch(&#123;<br>        <span class="hljs-string">&#x27;headless&#x27;</span>: <span class="hljs-literal">False</span>,<br>        <span class="hljs-string">&#x27;ignorehttpserrrors&#x27;</span>: <span class="hljs-literal">True</span>,<br>        <span class="hljs-string">&#x27;viewport&#x27;</span>: &#123;<span class="hljs-string">&#x27;width&#x27;</span>: <span class="hljs-number">1280</span>, <span class="hljs-string">&#x27;height&#x27;</span>: <span class="hljs-number">800</span>&#125;,<br>        <span class="hljs-string">&#x27;autoClose&#x27;</span>: <span class="hljs-literal">True</span>,<br>        &#125;)<br><br>    page = <span class="hljs-keyword">await</span> browser.newPage()<br>    <span class="hljs-keyword">await</span> page.goto(<span class="hljs-string">&#x27;http://www.baidu.com&#x27;</span>)<br><br>    <span class="hljs-comment"># Page.url</span><br>    <span class="hljs-comment"># 返回页面url</span><br>    c = page.url<br>    print(c)<br><br>    <span class="hljs-comment"># Page.viewport</span><br>    <span class="hljs-comment"># 得到页面viewport信息</span><br>    c = page.viewport<br>    print(c)<br><br>    <span class="hljs-comment"># Page.title()</span><br>    <span class="hljs-comment"># 返回页面标题</span><br>    c = <span class="hljs-keyword">await</span> page.title()<br>    print(c)<br><br>    <span class="hljs-comment"># Page.touchscreen</span><br>    <span class="hljs-comment"># 返回页面Touchscreen对象</span><br>    c = page.touchscreen<br>    print(c)<br><br>    <span class="hljs-comment"># Page.tracing</span><br>    <span class="hljs-comment"># 返回页面追踪对象</span><br>    c = page.tracing<br>    print(c)<br><br>    <span class="hljs-comment"># Page.mouse</span><br>    <span class="hljs-comment"># 得到页面的 Mouse 对象</span><br>    c = page.mouse<br>    print(c)<br><br>    <span class="hljs-comment"># isClosed() → bool[source]</span><br>    <span class="hljs-comment"># 页面是否已经关闭</span><br>    c = page.isClosed()<br>    print(c)<br><br>    <span class="hljs-comment"># keyboard</span><br>    <span class="hljs-comment"># 得到页面的 keyboard 对象</span><br>    c = page.keyboard<br>    print(c)<br><br>    <span class="hljs-comment"># mainFrame</span><br>    <span class="hljs-comment"># 得到页面的 Frame 对象</span><br>    c = page.mainFrame<br>    print(c)<br><br>    <span class="hljs-comment"># Page.content() → str</span><br>    <span class="hljs-comment"># 返回页面html</span><br>    c = <span class="hljs-keyword">await</span> page.content()<br>    print(c)<br><br><br>asyncio.get_event_loop().run_until_complete(main())<br></code></pre></td></tr></table></figure><h2 id="6-PageClass-JS"><a href="#6-PageClass-JS" class="headerlink" title="6_PageClass_JS"></a>6_PageClass_JS</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python</span><br><span class="hljs-comment"># -*- encoding: utf-8 -*-</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">@File    :   6_PageClass_JS.py</span><br><span class="hljs-string">@Time    :   2020-8-23 01:11:00</span><br><span class="hljs-string">@Author  :   Recluse Xu</span><br><span class="hljs-string">@Version :   1.0</span><br><span class="hljs-string">@Contact :   444640050@qq.com</span><br><span class="hljs-string">@Desc    :   页面类 Page Class</span><br><span class="hljs-string">    官方文档：https://miyakogi.github.io/pyppeteer/reference.html#pyppeteer.page.Page.target</span><br><span class="hljs-string">Page类提供了与标签交互的方法，一个浏览器可以有多个Page对象</span><br><span class="hljs-string"></span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><br><span class="hljs-comment"># here put the import lib</span><br><span class="hljs-keyword">import</span> asyncio<br><span class="hljs-keyword">from</span> pyppeteer <span class="hljs-keyword">import</span> launch<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    browser = <span class="hljs-keyword">await</span> launch(&#123;<br>        <span class="hljs-string">&#x27;headless&#x27;</span>: <span class="hljs-literal">False</span>,<br>        <span class="hljs-string">&#x27;ignorehttpserrrors&#x27;</span>: <span class="hljs-literal">True</span>,<br>        <span class="hljs-string">&#x27;viewport&#x27;</span>: &#123;<span class="hljs-string">&#x27;width&#x27;</span>: <span class="hljs-number">1280</span>, <span class="hljs-string">&#x27;height&#x27;</span>: <span class="hljs-number">800</span>&#125;,<br>        <span class="hljs-string">&#x27;autoClose&#x27;</span>: <span class="hljs-literal">True</span>,<br>        &#125;)<br><br>    page = <span class="hljs-keyword">await</span> browser.newPage()<br>    <span class="hljs-keyword">await</span> page.goto(<span class="hljs-string">&#x27;http://www.baidu.com&#x27;</span>)<br><br>    <span class="hljs-comment"># Page.evaluate(pageFunction: str, *args, force_expr: bool = False) → Any</span><br>    <span class="hljs-comment"># 执行js代码，并返回结果</span><br>    <span class="hljs-comment"># 参数</span><br>    <span class="hljs-comment">#   pageFunction (str) – js代码</span><br>    <span class="hljs-comment">#   force_expr (bool) – If True, evaluate pageFunction as expression. If False (default), try to automatically detect function or expression.</span><br>    c = <span class="hljs-keyword">await</span> page.evaluate(<span class="hljs-string">&#x27;function a()&#123;return &#123;&quot;Hello&quot;:&quot;Page.evaluate&quot;&#125;;&#125;&#x27;</span>)<br>    print(c)<br><br>    <span class="hljs-comment"># Page.evaluateHandle(pageFunction: str, *args) → pyppeteer.execution_context.JSHandle</span><br>    <span class="hljs-comment"># 在页面上执行一个js代码,返回一个JSHandle对象</span><br>    c = <span class="hljs-keyword">await</span> page.evaluateHandle(<span class="hljs-string">&#x27;document.getElementById(&quot;bottom_layer&quot;);&#x27;</span>)<br>    print(c)<br><br><br>asyncio.get_event_loop().run_until_complete(main())<br>python<br></code></pre></td></tr></table></figure><h2 id="7-PageClass-Cookie"><a href="#7-PageClass-Cookie" class="headerlink" title="7_PageClass_Cookie"></a>7_PageClass_Cookie</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python</span><br><span class="hljs-comment"># -*- encoding: utf-8 -*-</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">@File    :   7_PageClass_Cookie.py</span><br><span class="hljs-string">@Time    :   2020-8-23 01:33:25</span><br><span class="hljs-string">@Author  :   Recluse Xu</span><br><span class="hljs-string">@Version :   1.0</span><br><span class="hljs-string">@Contact :   444640050@qq.com</span><br><span class="hljs-string">@Desc    :   页面类 Page Class</span><br><span class="hljs-string">    官方文档：https://miyakogi.github.io/pyppeteer/reference.html#pyppeteer.page.Page.target</span><br><span class="hljs-string">Page类提供了与标签交互的方法，一个浏览器可以有多个Page对象</span><br><span class="hljs-string"></span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><br><span class="hljs-comment"># here put the import lib</span><br><span class="hljs-keyword">import</span> asyncio<br><span class="hljs-keyword">from</span> pyppeteer <span class="hljs-keyword">import</span> launch<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    browser = <span class="hljs-keyword">await</span> launch(&#123;<br>        <span class="hljs-string">&#x27;headless&#x27;</span>: <span class="hljs-literal">False</span>,<br>        <span class="hljs-string">&#x27;ignorehttpserrrors&#x27;</span>: <span class="hljs-literal">True</span>,<br>        <span class="hljs-string">&#x27;viewport&#x27;</span>: &#123;<span class="hljs-string">&#x27;width&#x27;</span>: <span class="hljs-number">1280</span>, <span class="hljs-string">&#x27;height&#x27;</span>: <span class="hljs-number">800</span>&#125;,<br>        <span class="hljs-string">&#x27;autoClose&#x27;</span>: <span class="hljs-literal">True</span>,<br>        &#125;)<br><br>    page = <span class="hljs-keyword">await</span> browser.newPage()<br>    <span class="hljs-keyword">await</span> page.goto(<span class="hljs-string">&#x27;http://www.baidu.com&#x27;</span>)<br><br>    <span class="hljs-comment"># Page.cookies(*urls) → dict</span><br>    <span class="hljs-comment"># 获取Cookie</span><br>    <span class="hljs-comment"># 如果指定url那就返回那个url的Cookie，没指定就返回当前页面Cookie</span><br>    c = <span class="hljs-keyword">await</span> page.cookies()<br>    print(c)<br><br>    <span class="hljs-comment"># Page.deleteCookie(*cookies)</span><br>    <span class="hljs-comment"># 删除Cookie</span><br>    <span class="hljs-comment"># cookies可以填入的参数</span><br>    <span class="hljs-comment">#   name (str): 必须传入</span><br>    <span class="hljs-comment">#   url (str)</span><br>    <span class="hljs-comment">#   domain (str)</span><br>    <span class="hljs-comment">#   path (str)</span><br>    <span class="hljs-comment">#   secure (bool)</span><br>    <span class="hljs-keyword">await</span> page.deleteCookie(&#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;BAIDUID&#x27;</span>&#125;)<br><br>    <span class="hljs-comment"># Page.setCookie(*cookies) → None[source]</span><br>    <span class="hljs-comment"># 设置Cookie</span><br>    <span class="hljs-comment"># 可选Cookie的参数：</span><br>    <span class="hljs-comment">#   name (str): required</span><br>    <span class="hljs-comment">#   value (str): required</span><br>    <span class="hljs-comment">#   url (str)</span><br>    <span class="hljs-comment">#   domain (str)</span><br>    <span class="hljs-comment">#   path (str)</span><br>    <span class="hljs-comment">#   expires (number): Unix time in seconds</span><br>    <span class="hljs-comment">#   httpOnly (bool)</span><br>    <span class="hljs-comment">#   secure (bool)</span><br>    <span class="hljs-comment">#   sameSite (str): &#x27;Strict&#x27; or &#x27;Lax&#x27;</span><br><br><br>asyncio.get_event_loop().run_until_complete(main())<br></code></pre></td></tr></table></figure><h2 id="8-PageClass-Wait"><a href="#8-PageClass-Wait" class="headerlink" title="8_PageClass_Wait"></a>8_PageClass_Wait</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python</span><br><span class="hljs-comment"># -*- encoding: utf-8 -*-</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">@File    :   8_PageClass_Wait.py</span><br><span class="hljs-string">@Time    :   2020-8-24 12:38:10</span><br><span class="hljs-string">@Author  :   Recluse Xu</span><br><span class="hljs-string">@Version :   1.0</span><br><span class="hljs-string">@Contact :   444640050@qq.com</span><br><span class="hljs-string">@Desc    :   页面类 Page Class</span><br><span class="hljs-string">    官方文档：https://miyakogi.github.io/pyppeteer/reference.html#pyppeteer.page.Page.target</span><br><span class="hljs-string">Page类提供了与标签交互的方法，一个浏览器可以有多个Page对象</span><br><span class="hljs-string"></span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><br><span class="hljs-comment"># here put the import lib</span><br><span class="hljs-keyword">import</span> asyncio<br><span class="hljs-keyword">from</span> pyppeteer <span class="hljs-keyword">import</span> launch<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    browser = <span class="hljs-keyword">await</span> launch(&#123;<br>        <span class="hljs-string">&#x27;headless&#x27;</span>: <span class="hljs-literal">False</span>,<br>        <span class="hljs-string">&#x27;ignorehttpserrrors&#x27;</span>: <span class="hljs-literal">True</span>,<br>        <span class="hljs-string">&#x27;viewport&#x27;</span>: &#123;<span class="hljs-string">&#x27;width&#x27;</span>: <span class="hljs-number">1280</span>, <span class="hljs-string">&#x27;height&#x27;</span>: <span class="hljs-number">800</span>&#125;,<br>        <span class="hljs-string">&#x27;autoClose&#x27;</span>: <span class="hljs-literal">True</span>,<br>        &#125;)<br><br>    page = <span class="hljs-keyword">await</span> browser.newPage()<br>    <span class="hljs-keyword">await</span> page.goto(<span class="hljs-string">&#x27;http://www.baidu.com&#x27;</span>)<br><br>    <span class="hljs-comment"># Page.waitFor(selectorOrFunctionOrTimeout: Union[str, int, float], options: dict = None, *args, **kwargs) → Awaitable[T_co]</span><br>    <span class="hljs-comment"># 等待函数执行，超时，元素出现。</span><br>    <span class="hljs-comment"># 这个函数的作用会因为第一个参数传入不同的内容而不同</span><br>    <span class="hljs-comment">#   如果selectorOrFunctionOrTimeout是number (int或float)，那么它将被视为超时(以毫秒为单位)，并返回在超时后执行的future。</span><br>    <span class="hljs-comment">#   如果selectorOrFunctionOrTimeout是一个JavaScript函数字符串，那么这个方法是waitForFunction()的快捷方式。</span><br>    <span class="hljs-comment">#   如果selectorOrFunctionOrTimeout是选择器字符串或xpath字符串，则此方法是waitForSelector（）或waitForXPath（）的快捷方式。 如果字符串以//开头，则将该字符串视为xpath。</span><br>    <span class="hljs-comment"># Pyppeteer尝试自动检测功能或选择器，但有时会漏检。</span><br>    <span class="hljs-comment"># 如果不能按预期工作，请直接使用waitForFunction（）或waitForSelector（）。</span><br>    <span class="hljs-comment"># 参数：</span><br>    <span class="hljs-comment">#   selectorOrFunctionOrTimeout – 选择器, xpath, 函数名 或者时间数字（毫秒）.</span><br>    <span class="hljs-comment">#   args (Any) – 传递给函数的参数</span><br>    <span class="hljs-comment"># 返回值:</span><br>    <span class="hljs-comment">#   Return awaitable object which resolves to a JSHandle of the success value.</span><br><br><br>    <span class="hljs-comment"># Page.waitForFunction(pageFunction: str, options: dict = None, *args, **kwargs) → Awaitable[T_co]</span><br>    <span class="hljs-comment"># 等待，直到函数完成并返回一个值</span><br>    <span class="hljs-comment"># Parameters:args (Any) – 传递给 pageFunction 的参数.</span><br>    <span class="hljs-comment"># Returns:Return awaitable object which resolves when the pageFunction returns a truthy value. It resolves to a JSHandle of the truthy value.</span><br>    <span class="hljs-comment"># 可选参数:</span><br>    <span class="hljs-comment">#   polling (str|number): pageFunction 执行间隔, 默认是 raf. 如果参数传入一个数字，那么它将被视为函数执行的毫秒间隔</span><br>    <span class="hljs-comment">#       raf: 不断执行requestAnimationFrame回调中的pageFunction. This is the tightest polling mode which is suitable to observe styling changes.</span><br>    <span class="hljs-comment">#       mutation: 在每次DOM更变的时候执行 pageFunction</span><br>    <span class="hljs-comment">#   timeout (int|float): 最大等待时间 毫秒. 默认为 30000 (30 seconds). 传入0可以禁用此项.</span><br><br>    <span class="hljs-comment"># Page.waitForNavigation(options: dict = None, **kwargs) → Optional[pyppeteer.network_manager.Response]</span><br>    <span class="hljs-comment"># 等待 导航navigation</span><br>    <span class="hljs-comment"># 参数和goto()相同</span><br>    <span class="hljs-comment"># 当页面导航到新URL或重新加载时，这将返回Response</span><br>    <span class="hljs-comment"># 运行将间接导致页面导航的代码时，它很有用</span><br>    navigationPromise = page.waitForNavigation()<br>    <span class="hljs-keyword">await</span> page.click(<span class="hljs-string">&#x27;#bottom_layer &gt; div.s-bottom-layer-left &gt; p:nth-child(5) &gt; a&#x27;</span>)<br>    <span class="hljs-keyword">await</span> navigationPromise  <span class="hljs-comment"># 等待，直到导航结束</span><br><br>    <span class="hljs-comment"># Page.waitForRequest(urlOrPredicate: Union[str, Callable[[pyppeteer.network_manager.Request], bool]], options: Dict[KT, VT] = None, **kwargs) → pyppeteer.network_manager.Request</span><br>    <span class="hljs-comment"># 等待Request</span><br>    <span class="hljs-comment"># 参数:</span><br>    <span class="hljs-comment">#   urlOrPredicate – 等待的url</span><br>    <span class="hljs-comment">#   选项:</span><br>    <span class="hljs-comment">#       timeout (int|float): 最大等待时间, 默认为 30 秒, 传入0禁用此项.</span><br>    <span class="hljs-keyword">await</span> page.waitForRequest(<span class="hljs-string">&#x27;http://www.baidu.com&#x27;</span>)<br>    <span class="hljs-keyword">await</span> page.waitForRequest(<span class="hljs-keyword">lambda</span> req: req.url == <span class="hljs-string">&#x27;http://www.baidu.com&#x27;</span> <span class="hljs-keyword">and</span> req.method == <span class="hljs-string">&#x27;GET&#x27;</span>)<br><br>    <span class="hljs-comment"># Page.waitForResponse(urlOrPredicate: Union[str, Callable[[pyppeteer.network_manager.Response], bool]], options: Dict[KT, VT] = None, **kwargs) → pyppeteer.network_manager.Response</span><br>    <span class="hljs-comment"># 等待Response</span><br>    <span class="hljs-comment"># 参数同Page.waitForRequest</span><br><br>    <span class="hljs-comment"># Page.waitForSelector(selector: str, options: dict = None, **kwargs) → Awaitable[T_co]</span><br>    <span class="hljs-comment"># 等待与选择器匹配的元素出现，要是页面已经有了匹配的元素，那么会立即返回</span><br>    <span class="hljs-comment"># Returns:Return awaitable object which resolves when element specified by selector string is added to DOM.</span><br>    <span class="hljs-comment"># 参数:</span><br>    <span class="hljs-comment">#   selector (str) – 选择器</span><br>    <span class="hljs-comment">#   可选项：</span><br>    <span class="hljs-comment">#       visible (bool):等待元素在DOM中出现，并且可见; i.e. to not have display: none or visibility: hidden CSS properties. Defaults to False.</span><br>    <span class="hljs-comment">#       hidden (bool): 等待元素在DOM中出现，隐藏的都算, i.e. have display: none or visibility: hidden CSS properties. Defaults to False.</span><br>    <span class="hljs-comment">#       timeout (int|float): 最大等待时间（毫秒）.默认为30000 (30 秒). 传递0禁用此项.</span><br><br>    <span class="hljs-comment"># Page.waitForXPath(xpath: str, options: dict = None, **kwargs) → Awaitable[T_co]</span><br>    <span class="hljs-comment"># 等待与xpath匹配的元素出现，要是页面已经有了匹配的元素，那么会立即返回</span><br>    <span class="hljs-comment"># 参数同 Page.waitForSelector</span><br><br>asyncio.get_event_loop().run_until_complete(main())<br><br></code></pre></td></tr></table></figure><h2 id="9-PageClass-Other"><a href="#9-PageClass-Other" class="headerlink" title="9_PageClass_Other"></a>9_PageClass_Other</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python</span><br><span class="hljs-comment"># -*- encoding: utf-8 -*-</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">@File    :   9_PageClass_Other.py</span><br><span class="hljs-string">@Time    :   2020-8-22 23:03:54</span><br><span class="hljs-string">@Author  :   Recluse Xu</span><br><span class="hljs-string">@Version :   1.0</span><br><span class="hljs-string">@Contact :   444640050@qq.com</span><br><span class="hljs-string">@Desc    :   页面类 Page Class</span><br><span class="hljs-string">    官方文档：https://miyakogi.github.io/pyppeteer/reference.html#pyppeteer.page.Page.target</span><br><span class="hljs-string">Page类提供了与标签交互的方法，一个浏览器可以有多个Page对象</span><br><span class="hljs-string"></span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><br><span class="hljs-comment"># here put the import lib</span><br><span class="hljs-keyword">import</span> asyncio<br><span class="hljs-keyword">from</span> pyppeteer <span class="hljs-keyword">import</span> launch<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    browser = <span class="hljs-keyword">await</span> launch(&#123;<br>        <span class="hljs-string">&#x27;headless&#x27;</span>: <span class="hljs-literal">False</span>,<br>        <span class="hljs-string">&#x27;ignorehttpserrrors&#x27;</span>: <span class="hljs-literal">True</span>,<br>        <span class="hljs-string">&#x27;viewport&#x27;</span>: &#123;<span class="hljs-string">&#x27;width&#x27;</span>: <span class="hljs-number">1280</span>, <span class="hljs-string">&#x27;height&#x27;</span>: <span class="hljs-number">800</span>&#125;,<br>        <span class="hljs-string">&#x27;autoClose&#x27;</span>: <span class="hljs-literal">True</span>,<br>        &#125;)<br><br>    page = <span class="hljs-keyword">await</span> browser.newPage()<br>    <span class="hljs-keyword">await</span> page.goto(<span class="hljs-string">&#x27;http://www.baidu.com&#x27;</span>)<br><br>    <span class="hljs-comment"># Page.addScriptTag(options: Dict[KT, VT] = None, **kwargs) → pyppeteer.element_handle.ElementHandle</span><br>    <span class="hljs-comment"># 给页面添加一个script标签，可以写入一些东西</span><br>    <span class="hljs-comment"># url, path, content三个参数中必须选一个填入</span><br>    <span class="hljs-comment"># 会返回已经被添加好的 ElementHandle 实例</span><br>    <span class="hljs-comment"># 参数：</span><br>    <span class="hljs-comment">#   url (string): URL of a script to add.</span><br>    <span class="hljs-comment">#   path (string): Path to the local JavaScript file to add.</span><br>    <span class="hljs-comment">#   content (string): JavaScript string to add.</span><br>    <span class="hljs-comment">#   type (string): Script type. Use module in order to load a JavaScript ES6 module</span><br>    <span class="hljs-keyword">await</span> page.addScriptTag(&#123;<br>        <span class="hljs-string">&quot;content&quot;</span>: <span class="hljs-string">&quot;console.log(&#x27;Hello addScriptTag&#x27;)&quot;</span><br>    &#125;)<br><br>    <span class="hljs-comment"># Page.addStyleTag(options: Dict[KT, VT] = None, **kwargs) → pyppeteer.element_handle.ElementHandle</span><br>    <span class="hljs-comment"># 给页面添加一个style标签，可以写入一些东西</span><br>    <span class="hljs-comment"># url, path, content三个参数中必须选一个填入</span><br>    <span class="hljs-comment"># 参数：</span><br>    <span class="hljs-comment">#   url (string): URL of the link tag to add.</span><br>    <span class="hljs-comment">#   path (string): Path to the local CSS file to add.</span><br>    <span class="hljs-comment">#   content (string): CSS string to add.</span><br>    <span class="hljs-keyword">await</span> page.addScriptTag(&#123;<br>        <span class="hljs-string">&quot;url&quot;</span>: <span class="hljs-string">&quot;https://cdn.bootcdn.net/ajax/libs/twitter-bootstrap/5.0.0-alpha1/css/bootstrap.css&quot;</span><br>    &#125;)<br><br>    <span class="hljs-comment"># Page.bringToFront 将页面置于最前（激活选项卡）</span><br>    <span class="hljs-keyword">await</span> page.bringToFront()<br><br>    <span class="hljs-comment"># Page.click(selector: str, options: dict = None, **kwargs)</span><br>    <span class="hljs-comment"># 此方法使用选择器获取元素，如果需要，将其滚动到视图中，然后使用鼠标在元素的中心单击</span><br>    <span class="hljs-comment"># 如果没有元素匹配选择器，该方法将引发PageError</span><br>    <span class="hljs-comment"># 参数</span><br>    <span class="hljs-comment">#   button (str): left, right, or middle, defaults to left.</span><br>    <span class="hljs-comment">#   clickCount (int): defaults to 1.</span><br>    <span class="hljs-comment">#   delay (int|float): Time to wait between mousedown and mouseup in milliseconds. defaults to 0.</span><br>    <span class="hljs-keyword">await</span> page.click(<span class="hljs-string">&#x27;#su&#x27;</span>)<br><br><br>    <span class="hljs-comment">#  Page.setUserAgent(userAgent: str)</span><br>    <span class="hljs-comment">#  设置UserAgent</span><br>    <span class="hljs-keyword">await</span> page.setUserAgent(<span class="hljs-string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/83.0.4103.116 Safari/537.36&#x27;</span>)<br><br>    <span class="hljs-comment"># Page.setViewport(viewport: dict)</span><br>    <span class="hljs-comment"># 设置Viewport</span><br>    <span class="hljs-comment"># 可填入选项：</span><br>    <span class="hljs-comment">#   width (int): page width in pixel.</span><br>    <span class="hljs-comment">#   height (int): page height in pixel.</span><br>    <span class="hljs-comment">#   deviceScaleFactor (float): Default to 1.0.</span><br>    <span class="hljs-comment">#   isMobile (bool): Default to False.</span><br>    <span class="hljs-comment">#   hasTouch (bool): Default to False.</span><br>    <span class="hljs-comment">#   isLandscape (bool): Default to False.</span><br>    <span class="hljs-keyword">await</span> page.setViewport(&#123;<br>        <span class="hljs-string">&#x27;width&#x27;</span>: <span class="hljs-number">1024</span>,<br>        <span class="hljs-string">&#x27;height&#x27;</span>: <span class="hljs-number">1024</span>,<br>    &#125;)<br><br>    <span class="hljs-comment"># Page.emulateMedia(mediaType: str = None)</span><br>    <span class="hljs-comment"># 设置CSS  media type</span><br>    <span class="hljs-comment"># 你可以填入 &#x27;screen&#x27;, &#x27;print&#x27;, None 中的一个</span><br>    <span class="hljs-keyword">await</span> page.emulateMedia(<span class="hljs-string">&#x27;screen&#x27;</span>)<br><br><br>    <span class="hljs-comment"># Page.exposeFunction(name: str, pyppeteerFunction: Callable[[…], Any])</span><br>    <span class="hljs-comment"># 将一个Python函数绑定到浏览器window对象中，可以在使用过程中调用</span><br>    <span class="hljs-comment"># 参数：</span><br>    <span class="hljs-comment">#   name (string) – Name of the function on the window object.</span><br>    <span class="hljs-comment">#   pyppeteerFunction (Callable) – Function which will be called on python process. This function should not be asynchronous function.</span><br><br>    <span class="hljs-comment"># Page.focus(selector: str)</span><br>    <span class="hljs-comment"># 为选择器匹配的元素设置焦点</span><br>    <span class="hljs-comment"># 若没有元素被匹配，则报错</span><br>    <span class="hljs-keyword">await</span> page.focus(<span class="hljs-string">&#x27;#kw&#x27;</span>)<br><br><br>    <span class="hljs-comment"># Page.goBack(options: dict = None, **kwargs) → Optional[pyppeteer.network_manager.Response]</span><br>    <span class="hljs-comment"># 页面回退，基于Page访问记录，如果不能回退，则会返回None</span><br>    <span class="hljs-comment"># 参数与goto()一致</span><br>    <span class="hljs-keyword">await</span> page.goBack()<br><br>    <span class="hljs-comment"># goForward(options: dict = None, **kwargs) → Optional[pyppeteer.network_manager.Response]</span><br>    <span class="hljs-comment"># 页面前进，基于Page访问记录，如果不能回退，则会返回None</span><br>    <span class="hljs-comment"># 参数与goto()一致</span><br>    <span class="hljs-keyword">await</span> page.goForward()<br><br><br>    <span class="hljs-comment"># goto(url: str, options: dict = None, **kwargs) → Optional[pyppeteer.network_manager.Response]</span><br>    <span class="hljs-comment"># 页面访问url</span><br>    <span class="hljs-comment"># 参数：</span><br>    <span class="hljs-comment">#   timeout (int): 最大请求时间,默认为 30 秒, 传入0可以禁用此项. 此默认值可以通过 setDefaultNavigationTimeout()方法 来设置.</span><br>    <span class="hljs-comment">#   waitUntil (str|List[str]): 什么时候认为请求已经成功了, 默认是load项. 可选项目：</span><br>    <span class="hljs-comment">#       load: 当 load 事件被触发</span><br>    <span class="hljs-comment">#       domcontentloaded: 当 DOMContentLoaded 事件被触发</span><br>    <span class="hljs-comment">#       networkidle0: 500ms内没有正在连接的网络请求</span><br>    <span class="hljs-comment">#       networkidle2: 500ms内正在连接的网络请求不超过两个</span><br>    <span class="hljs-comment"># 可能引发的错误</span><br>    <span class="hljs-comment">#   url无效</span><br>    <span class="hljs-comment">#   请求超时</span><br>    <span class="hljs-comment">#   资源读取失败</span><br>    <span class="hljs-keyword">await</span> page.goto(<span class="hljs-string">&#x27;https://www.baidu.com/&#x27;</span>)<br><br>    <span class="hljs-comment"># hover(selector: str)</span><br>    <span class="hljs-comment"># 鼠标悬停在选择器匹配的元素上</span><br>    <span class="hljs-comment"># 若没有元素被匹配，则报错</span><br>    <span class="hljs-keyword">await</span> page.hover(<span class="hljs-string">&#x27;#su&#x27;</span>)<br><br><br><br>    <span class="hljs-comment"># metrics() → Dict[str, Any]</span><br>    <span class="hljs-comment"># 返回页面 metrics 信息</span><br>    <span class="hljs-comment"># 信息批注</span><br>    <span class="hljs-comment">#   Timestamp (number): The timestamp when the metrics sample was taken.</span><br>    <span class="hljs-comment">#   Documents (int): Number of documents in the page.</span><br>    <span class="hljs-comment">#   Frames (int): Number of frames in the page.</span><br>    <span class="hljs-comment">#   JSEventListeners (int): Number of events in the page.</span><br>    <span class="hljs-comment">#   Nodes (int): Number of DOM nodes in the page.</span><br>    <span class="hljs-comment">#   LayoutCount (int): Total number of full partial page layout.</span><br>    <span class="hljs-comment">#   RecalcStyleCount (int): Total number of page style recalculations.</span><br>    <span class="hljs-comment">#   LayoutDuration (int): Combined duration of page duration.</span><br>    <span class="hljs-comment">#   RecalcStyleDuration (int): Combined duration of all page style recalculations.</span><br>    <span class="hljs-comment">#   ScriptDuration (int): Combined duration of JavaScript execution.</span><br>    <span class="hljs-comment">#   TaskDuration (int): Combined duration of all tasks performed by the browser.</span><br>    <span class="hljs-comment">#   JSHeapUsedSize (float): Used JavaScript heap size.</span><br>    <span class="hljs-comment">#   JSHeapTotalSize (float): Total JavaScript heap size.</span><br>    c = <span class="hljs-keyword">await</span> page.metrics()<br>    print(c)<br><br>    <span class="hljs-comment"># Page.reload(options: dict = None, **kwargs) → Optional[pyppeteer.network_manager.Response]</span><br>    <span class="hljs-comment"># 刷新这个页面</span><br>    <span class="hljs-comment"># 参数与goto()一致</span><br>    <span class="hljs-keyword">await</span> page.reload()<br><br>    <span class="hljs-comment"># Page.screenshot(options: dict = None, **kwargs) → Union[bytes, str]</span><br>    <span class="hljs-comment"># 给网页弄一张截图</span><br>    <span class="hljs-comment"># 参数：</span><br>    <span class="hljs-comment">#   path (str): The file path to save the image to. The screenshot type will be inferred from the file extension.</span><br>    <span class="hljs-comment">#   type (str): Specify screenshot type, can be either jpeg or png. Defaults to png.</span><br>    <span class="hljs-comment">#   quality (int): The quality of the image, between 0-100. Not applicable to png image.</span><br>    <span class="hljs-comment">#   fullPage (bool): When true, take a screenshot of the full scrollable page. Defaults to False.</span><br>    <span class="hljs-comment">#   clip (dict): An object which specifies clipping region of the page. This option should have the following fields:</span><br>    <span class="hljs-comment">#   x (int): x-coordinate of top-left corner of clip area.</span><br>    <span class="hljs-comment">#   y (int): y-coordinate of top-left corner of clip area.</span><br>    <span class="hljs-comment">#   width (int): width of clipping area.</span><br>    <span class="hljs-comment">#   height (int): height of clipping area.</span><br>    <span class="hljs-comment">#   omitBackground (bool): Hide default white background and allow capturing screenshot with transparency.</span><br>    <span class="hljs-comment">#   encoding (str): The encoding of the image, can be either &#x27;base64&#x27; or &#x27;binary&#x27;. Defaults to &#x27;binary&#x27;.</span><br>    <span class="hljs-keyword">await</span> page.screenshot(&#123;<span class="hljs-string">&#x27;path&#x27;</span>: <span class="hljs-string">&#x27;example/0_Basic_usage_of_the_library/pyppeteer/baidu.png&#x27;</span>&#125;)<br><br>    <span class="hljs-comment"># Page.select(selector: str, *values) → List[str]</span><br>    <span class="hljs-comment"># 选择 options 并返回被选的值</span><br>    <span class="hljs-comment"># 若没有元素被匹配，则报错</span><br><br>    <span class="hljs-comment"># Page.setBypassCSP(enabled: bool) → None</span><br>    <span class="hljs-comment"># 设置Content-Security-Policy</span><br><br>    <span class="hljs-comment"># Page.setCacheEnabled(enabled: bool = True) → None</span><br>    <span class="hljs-comment"># 是否启用Cache</span><br><br>    <span class="hljs-comment"># Page.setContent(html: str) → None</span><br>    <span class="hljs-comment"># 设置网页HTML内容</span><br><br>    <span class="hljs-comment"># Page.setJavaScriptEnabled(enabled: bool)</span><br>    <span class="hljs-comment"># 设置js是否启用</span><br><br>    <span class="hljs-comment"># Page.setOfflineMode(enabled: bool) </span><br>    <span class="hljs-comment"># 设置是否启用离线模式</span><br><br><br>    <span class="hljs-comment"># Page.setRequestInterception(value: bool) </span><br>    <span class="hljs-comment"># 启用/禁用请求拦截。</span><br>    <span class="hljs-comment"># 激活请求拦截可以启用请求类的abort（），continue_（）和response（）方法。 这提供了修改页面发出的网络请求的功能。</span><br><br>    <span class="hljs-comment"># Page.tap(selector: str)</span><br>    <span class="hljs-comment"># Tap选择器匹配的元素</span><br>    <span class="hljs-comment"># 若没有元素被匹配，则报错</span><br><br>    <span class="hljs-comment"># Page.xpath(expression: str) → List[pyppeteer.element_handle.ElementHandle][source]</span><br>    <span class="hljs-comment"># 返回匹配xpath的元素 list</span><br>    <span class="hljs-comment"># 要是没有匹配项则返回空的list</span><br><br><br>    <span class="hljs-comment"># Page.type(selector: str, text: str, options: dict = None, **kwargs)</span><br>    <span class="hljs-comment"># 在指定元素中输入内容</span><br>    <span class="hljs-comment"># 若没有元素被匹配，则报错</span><br><br><br><br><br>    <span class="hljs-comment"># Page.close()</span><br>    <span class="hljs-comment"># 关闭page</span><br>    <span class="hljs-keyword">await</span> page.close()<br><br><br>asyncio.get_event_loop().run_until_complete(main())<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Puppeteer</tag>
      
      <tag>Pyppeteer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS-反爬</title>
    <link href="/post/4280fd2e/"/>
    <url>/post/4280fd2e/</url>
    
    <content type="html"><![CDATA[<h1 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h1><h2 id="CSS是什么"><a href="#CSS是什么" class="headerlink" title="CSS是什么"></a>CSS是什么</h2><p>层叠样式表(英文全称：Cascading Style Sheets)是一种用来表现HTML或XML等文件样式的计算机语言<br>CSS不仅可以静态地修饰网页，还可以配合各种脚本语言动态地对网页各元素进行格式化  </p><h2 id="CSS过程"><a href="#CSS过程" class="headerlink" title="CSS过程"></a>CSS过程</h2><p><img src="/CSS-%E5%8F%8D%E7%88%AC/20200821052643339.png">  </p><h2 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h2><p><img src="/CSS-%E5%8F%8D%E7%88%AC/20200821053049847.png"><br>伪类：实际上不是真正的类名，而是一个内置影式的有特殊功能的类  </p><h1 id="CSS反爬"><a href="#CSS反爬" class="headerlink" title="CSS反爬"></a>CSS反爬</h1><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul><li>成本低  <ul><li>只需要前端混淆样式（不需要后台配合）  </li><li>不需要复杂的加密技术  </li><li>不需要验证码，流量监控等额外配置  </li></ul></li><li>效果好  <ul><li>难以识别  </li><li>抓取内容与预期相近  </li><li>反爬措施不易发觉  </li><li>可以弄假数据  </li><li>没有成熟的破解套路  </li></ul></li></ul><h2 id="字体反爬"><a href="#字体反爬" class="headerlink" title="字体反爬"></a>字体反爬</h2><ul><li>字体反爬通常会操作<code>font-family</code>字段，让其指向自定义的字体  </li><li>通过定义字体的方法，将HTML中用不常见的unicode映射到常用字体中  </li><li>爬虫抓取的数据只能抓到unicode，从而保护了真实数据  </li></ul><h3 id="应对"><a href="#应对" class="headerlink" title="应对"></a>应对</h3><ol><li>下载<code>woff</code>字体文件，转化为 <code>tff</code>文件  </li><li>用字体编辑器打开<code>tff</code>文件，确认unicode与实际值的映射关系  </li><li>将HTML内容按照映射关系进行替换  </li></ol><h4 id="难点"><a href="#难点" class="headerlink" title="难点"></a>难点</h4><p>有些网站会动态生成<code>woff</code></p><h2 id="CSS背景反爬"><a href="#CSS背景反爬" class="headerlink" title="CSS背景反爬"></a>CSS背景反爬</h2><p>其原理是CSS Sprite(雪碧图)，一种利用一张图做多个效果的操作的技术<br>在过去，常用于优化网页提升速度。雪碧图的方式只要求请求一次HTTP相比于多次请求来说性能更优  </p><ul><li>数据利用背景图片展示给用户，而不是直接用文本  </li><li>图片包含一张雪碧图，数据利用背景偏移量获取  </li><li>抓取时看不到实际值  </li></ul><h3 id="应对-1"><a href="#应对-1" class="headerlink" title="应对"></a>应对</h3><ol><li>下载雪碧图，手动检查其对应值  </li><li>调试工具中调整<code>background-position</code>的偏移量，找到各偏移量与实际值的映射关系  </li><li>在爬虫中获取袁术元素偏移量，将其转为实际值  </li></ol><h2 id="CSS伪类反爬"><a href="#CSS伪类反爬" class="headerlink" title="CSS伪类反爬"></a>CSS伪类反爬</h2><ul><li>不直接将内容展现在HTML中  </li><li>通过伪类的<code>content</code>属性将要展示的值展示出来  </li></ul><h3 id="难点-1"><a href="#难点-1" class="headerlink" title="难点"></a>难点</h3><p>获取元素的伪类属性  </p><h3 id="应对-2"><a href="#应对-2" class="headerlink" title="应对"></a>应对</h3><ul><li>利用<code>Puppeteer</code>或<code>Selenium</code>在网页中执行JS来获取content  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> el = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;.valuable-content&#x27;</span>)  <span class="hljs-comment">// 利用选择器选出目标元素</span><br><span class="hljs-keyword">const</span> styles = getComputedStyle(el, <span class="hljs-string">&#x27;before&#x27;</span>) <span class="hljs-comment">// 获取样式（这里可能是before或者after）</span><br><span class="hljs-built_in">console</span>.log(styles.content)  <span class="hljs-comment">// 打印样式查看</span><br></code></pre></td></tr></table></figure><h2 id="元素定位反爬"><a href="#元素定位反爬" class="headerlink" title="元素定位反爬"></a>元素定位反爬</h2>利用绝对定位将某一个数字或字符将原数字或字符通过一定的偏移量替换  </li><li>替换的数字或字符通常来说是随机的  </li><li>直接抓取会抓到错误信息  </li></ul><h3 id="应对-3"><a href="#应对-3" class="headerlink" title="应对"></a>应对</h3><p>计算替换元素偏移量，与被替换元素做比对，还原真实值  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 元素获取</span><br><span class="hljs-keyword">const</span> elPr = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;.mb-10 .b-airfly:nth-child(1) .fix_price&#x27;</span>)<br><span class="hljs-comment">// 被替换元素类别</span><br><span class="hljs-keyword">let</span> strArr = <span class="hljs-built_in">Array</span>.from(elPr.querySelectorAll(<span class="hljs-string">&#x27;b:first-child &gt; i&#x27;</span>)).map(<span class="hljs-function"><span class="hljs-params">el</span> =&gt;</span> el.innerText)<br><span class="hljs-comment">// 替换元素</span><br>elPr.querySelectorAll(<span class="hljs-string">&#x27;b:not(:first-child)&#x27;</span>).forEach(<span class="hljs-function"><span class="hljs-params">el</span> =&gt;</span> &#123;<br>    <span class="hljs-comment">// 偏移量</span><br>    <span class="hljs-keyword">const</span> left = <span class="hljs-built_in">Number</span>(getComputedStyle(el).left.replace(<span class="hljs-string">&#x27;px&#x27;</span>,<span class="hljs-string">&#x27;&#x27;</span>))<br>    <span class="hljs-comment">// 替换值</span><br>    strArr[strArr.length + left/<span class="hljs-number">16</span>] = el.innerText<br>&#125;)<br><span class="hljs-comment">// 真实值</span><br><span class="hljs-built_in">console</span>.log(strArr.join(<span class="hljs-string">&#x27;&#x27;</span>)) <br></code></pre></td></tr></table></figure><h2 id="利用字符分割"><a href="#利用字符分割" class="headerlink" title="利用字符分割"></a>利用字符分割</h2><ul><li>将字符串用标签分割开来  </li><li>由于其实内联块级(inline-block)，依旧是一行展示  </li><li>通常还混淆有不显示的标签(display:none)  </li></ul><h3 id="应对-4"><a href="#应对-4" class="headerlink" title="应对"></a>应对</h3><p>将内联块级标签的<code>innerText</code>拼接起来<br>注意过滤掉所有的<code>display:none</code>属性  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 元素获取</span><br><span class="hljs-keyword">const</span> elIp = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;.ip&#x27;</span>)<br><span class="hljs-keyword">let</span> str = <span class="hljs-string">&quot;&quot;</span><br><span class="hljs-comment">// 过滤 display: none</span><br><span class="hljs-keyword">const</span> elList = elIp.querySelectorAll(<span class="hljs-string">&#x27;*:not([style=&quot;display: none;&quot;])&#x27;</span>);<br><span class="hljs-comment">// 拼接</span><br>elList.forEach(<span class="hljs-function">(<span class="hljs-params">el, i</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span>(i === elList.length - <span class="hljs-number">1</span> )<br>        <span class="hljs-keyword">return</span> str += el.innerText<br>&#125;)<br><span class="hljs-built_in">console</span>.log(str)<br></code></pre></td></tr></table></figure><h2 id="推荐CSS反爬步骤"><a href="#推荐CSS反爬步骤" class="headerlink" title="推荐CSS反爬步骤"></a>推荐CSS反爬步骤</h2><ol><li>通过调试工具，人工查看CSS样式  </li><li>判断CSS反爬类型  </li><li>根据不同的类型采用不同的应对措施  </li><li>对于新的CSS反爬，研究其原理，采用合适的反爬策略  </li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>CSS</tag>
      
      <tag>反爬虫</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>编码和加密-js-Python</title>
    <link href="/post/3b5ddb7/"/>
    <url>/post/3b5ddb7/</url>
    
    <content type="html"><![CDATA[<h1 id="编码与加密常识"><a href="#编码与加密常识" class="headerlink" title="编码与加密常识"></a>编码与加密常识</h1><h2 id="基础通识"><a href="#基础通识" class="headerlink" title="基础通识"></a>基础通识</h2><ul><li>MD5<br>提取结果通常是 32 位，不受明文长度影响   </li><li>Base64<br>编码结果末尾通常会出现一或二个等于符号，受明文长度影响  </li><li>SHA1<br>加密结果值为 40 位，不受明文长度影响  </li><li>SHA256<br>加密结果值为 64 位，不受明文长度影响  </li></ul><h2 id="盲猜技巧"><a href="#盲猜技巧" class="headerlink" title="盲猜技巧"></a>盲猜技巧</h2><ul><li>一长串无规律数字与字母组合的字符大概率是 AES、DES、SHA 相关加密  </li><li>另外，AES、RSA 等对称和非对称加密都喜欢将结果值用 Base64 进行编码，这样易于传递  </li><li>如果你看到一长串字符里出现 <code>+</code> 、<code>\</code> 和末尾的 <code>=</code> ，那大概率就是上一行描述的加密算法加密后又进行了 <code>Base64</code> 编码的结果  </li><li>32 位的字符串有概率是 <code>MD5</code> 摘要结果  </li><li>64 位的字符串有概率是 <code>SHA</code> 加密结果  </li></ul><p>通过全局搜索找寻可疑字符串，在所有文件中寻找关键字<br>在需要的地方打上断点，找寻到目标的加密逻辑  </p><h2 id="复现做法"><a href="#复现做法" class="headerlink" title="复现做法"></a>复现做法</h2><p>在找寻到以后，可以选择：  </p><ul><li>参照js逻辑用其它语言重新实现  </li><li>直接调用js的加密函数  </li></ul><p>从非常长的 javascript文件 中归纳逻辑，建议将一些关键的变量或者函数复制粘贴到另一个 javascript文件 中，运行以后根据 没有定义 的报错 来逐一补全所需，直到得到结果  </p><h1 id="Ascii"><a href="#Ascii" class="headerlink" title="Ascii"></a>Ascii</h1><p>ASCII (American Standard Code for Information Interchange)美国信息交换标准代码 是基于拉丁字母的一套电脑编码系统，主要用于显示现代英语和其他西欧语言<br>它是最通用的信息交换标准，并等同于国际标准<code>ISO/IEC 646</code><br>ASCII第一次以规范标准的类型发表是在1967年，最后一次更新则是在1986年，到目前为止共定义了128个字符  </p><h2 id="码表"><a href="#码表" class="headerlink" title="码表"></a>码表</h2><p>在计算机中，所有的数据在存储和运算时都要使用二进制数表示（因为计算机用高电平和低电平分别表示<code>1</code>和<code>0</code>）  </p><blockquote><p>例如，像a、b、c、d这样的52个字母（包括大写）以及0、1等数字还有一些常用的符号（例如*、#、@等）  </p></blockquote><p>在计算机中存储时也要使用二进制数来表示，为了记录具体用哪些二进制数字表示哪个符号，人们建立了码表。每个人都可以约定自己的一套编码方式（码表）<br>为了让大家互相通信而不造成混乱，那么大家就必须使用相同的编码规则，于是美国有关的标准化组织就出台了<code>ASCII</code>编码，统一规定了上述常用符号用哪些二进制数来表示<br><img src="/%E7%BC%96%E7%A0%81%E5%92%8C%E5%8A%A0%E5%AF%86-js-Python/20200819033739113.png">  </p><h2 id="在Python中获取"><a href="#在Python中获取" class="headerlink" title="在Python中获取"></a>在Python中获取</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_ascii</span>(<span class="hljs-params">text: <span class="hljs-built_in">str</span></span>):</span><br>    <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> text:<br>        print(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;x&#125;</span>&#x27;</span>, <span class="hljs-built_in">ord</span>(x))<br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    get_ascii(<span class="hljs-string">&#x27;Hello world&#x27;</span>)<br></code></pre></td></tr></table></figure><h1 id="Base64"><a href="#Base64" class="headerlink" title="Base64"></a>Base64</h1><p>Base64是一种基于64个<code>可打印字符</code>来表示二进制数据的方法<br>是网络上最常见的用于传输编码方式之一<br><code>3个字节</code> = <code>8位</code> = <code>24比特</code>， 对应于4个<code>Base64</code>单元<br>即3个字节可以由4个可打印字符来表示  </p><blockquote><p>可打印字符：A-Z、a-z、0-9 （一共62个字符）<br>剩余两个字符在不同的系统中表示不同  </p></blockquote><p>多用于处理文本数据 与 二进制数据的表示、传输、存储<br>例如：网页上的图片  </p><blockquote><p>例: 输入6666<br><img src="/%E7%BC%96%E7%A0%81%E5%92%8C%E5%8A%A0%E5%AF%86-js-Python/20200819035440360.png"><br>由于后面还没够3字节，所以就会补充一些字符  </p></blockquote><p><code>Base64</code>核心原理是将二进制数据进行分组，每 24Bit/3字节 一大组，再把大组的数据分成 6Bit 的小分组  </p><p>由于6Bit数据只能表示64个不同字符(2^6=64)，所以叫<code>Base64 </code>  </p><blockquote><p>大厂会自己定制特定的字符表，来达到混淆的目的<br>虽然都是base64,但其个字符与值的关系是被更改过的  </p></blockquote><h2 id="码表-1"><a href="#码表-1" class="headerlink" title="码表"></a>码表</h2><p><img src="/%E7%BC%96%E7%A0%81%E5%92%8C%E5%8A%A0%E5%AF%86-js-Python/20200827043358055.png"><br>默认的码表是 <code>大写字母 + 小写字母 + 数字 + &#39;+&#39; + &#39;/&#39;</code><br>这东西其实能自己定义  </p><h2 id="Python代码浏览运行过程"><a href="#Python代码浏览运行过程" class="headerlink" title="Python代码浏览运行过程"></a>Python代码浏览运行过程</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python</span><br><span class="hljs-comment"># -*- encoding: utf-8 -*-</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">@File    :   7_base64_charset.py</span><br><span class="hljs-string">@Time    :   2020/08/27 12:05:58</span><br><span class="hljs-string">@Author  :   Recluse Xu</span><br><span class="hljs-string">@Version :   1.0</span><br><span class="hljs-string">@Contact :   444640050@qq.com</span><br><span class="hljs-string">@Desc    :   自定义字符集的base64编码与解码</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><br><span class="hljs-comment"># here put the import lib</span><br><span class="hljs-keyword">import</span> string<br><span class="hljs-keyword">import</span> random<br><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    定义自己的64个字符</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><br><span class="hljs-comment"># 从标准库里将大写字母，小写字母，数字（一共62个字符）</span><br>char64 = string.ascii_uppercase + string.ascii_lowercase + string.digits<br><span class="hljs-comment"># 额外添加两个字符(一共64个字符)</span><br>char64 += <span class="hljs-string">&#x27;+&#x27;</span>+<span class="hljs-string">&#x27;/&#x27;</span><br>char64 = <span class="hljs-built_in">list</span>(char64)<br><span class="hljs-comment"># 打乱码表</span><br>random.shuffle(char64)<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">cut</span>(<span class="hljs-params">obj, sec</span>):</span><br>    <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    将字符串按照指定数量进行切分</span><br><span class="hljs-string">    &#x27;&#x27;&#x27;</span><br>    <span class="hljs-keyword">return</span> [obj[i:i+sec] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(obj), sec)]<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">ascii_2_base64</span>(<span class="hljs-params">ascii_str: <span class="hljs-built_in">str</span></span>) -&gt; str:</span><br>    <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    正常来说，一个ASCII字符占8位</span><br><span class="hljs-string">    一个base64字符占6位</span><br><span class="hljs-string">    3*8 = 24 = 4*6位</span><br><span class="hljs-string">    这个函数就是用来做这个转换的</span><br><span class="hljs-string">    单个字符位数不够的，计算时会用0补全</span><br><span class="hljs-string">    整个字符位数不够的，在最后会用=来补足</span><br><span class="hljs-string"></span><br><span class="hljs-string">    b1    b2    b3</span><br><span class="hljs-string">    n1  n2  n3  n4</span><br><span class="hljs-string"></span><br><span class="hljs-string">    &#x27;&#x27;&#x27;</span><br>    print(<span class="hljs-string">&#x27;传入的数据字符串\t&#x27;</span>, ascii_str)<br>    <span class="hljs-comment"># 将数据转为bytes</span><br>    origin_bytes = ascii_str.encode()<br>    print(<span class="hljs-string">&#x27;将传入数据转为bytes\t&#x27;</span>, origin_bytes)<br><br>    <span class="hljs-comment"># 转为八位二进制</span><br>    base64_8_bin = [<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;<span class="hljs-built_in">str</span>(<span class="hljs-built_in">bin</span>(b)).replace(<span class="hljs-string">&#x27;0b&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>):<span class="hljs-number">0</span>&gt;<span class="hljs-number">8</span>&#125;</span>&quot;</span> <span class="hljs-keyword">for</span> b <span class="hljs-keyword">in</span> origin_bytes]<br>    print(<span class="hljs-string">&#x27;将数据转为八位二进制\t&#x27;</span>, base64_8_bin)<br><br>    <span class="hljs-comment"># 按每6位切分</span><br>    base64_6_bin = cut(<span class="hljs-string">&#x27;&#x27;</span>.join(base64_8_bin), <span class="hljs-number">6</span>)<br>    print(<span class="hljs-string">&#x27;每6位切分一次数据\t&#x27;</span>, base64_6_bin)<br><br>    <span class="hljs-comment"># 最后一位位数补足到6位</span><br>    base64_6_bin[-<span class="hljs-number">1</span>] += <span class="hljs-string">&#x27;0&#x27;</span> * (<span class="hljs-number">6</span> - <span class="hljs-built_in">len</span>(base64_6_bin[-<span class="hljs-number">1</span>]))<br>    print(<span class="hljs-string">&#x27;将最后一位的位数补足\t&#x27;</span>, base64_6_bin)<br><br>    <span class="hljs-comment"># 将被切分的数据重新转为10进制</span><br>    base64_int = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-keyword">lambda</span> x: <span class="hljs-built_in">int</span>(x, <span class="hljs-number">2</span>), base64_6_bin))<br>    print(<span class="hljs-string">&#x27;每段二进制数转十进制\t&#x27;</span>, base64_int)<br><br>    <span class="hljs-comment"># 码表中寻找目标字符替换对应项</span><br>    base64_str = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-keyword">lambda</span> x: char64[x], base64_int))<br>    print(<span class="hljs-string">&#x27;码表中寻找目标字符替换\t&#x27;</span>, base64_str)<br><br>    <span class="hljs-comment"># 位数不够的地方补=</span><br>    base64_str += [<span class="hljs-string">&#x27;=&#x27;</span>] * (<span class="hljs-number">3</span> - <span class="hljs-built_in">len</span>(base64_8_bin) % <span class="hljs-number">3</span>)<br>    print(<span class="hljs-string">&#x27;用=将数据补全到24*n位\t&#x27;</span>, base64_str)<br><br>    <span class="hljs-comment"># 最终结果</span><br>    base64_str = <span class="hljs-string">&#x27;&#x27;</span>.join(base64_str)<br>    print(<span class="hljs-string">&#x27;ascii转base64 最终结果\t&#x27;</span>, base64_str)<br>    <span class="hljs-keyword">return</span> base64_str<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">base64_2_ascii</span>(<span class="hljs-params">base64_str: <span class="hljs-built_in">str</span></span>) -&gt; str:</span><br>    <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    做和上面相反的操作</span><br><span class="hljs-string">    &#x27;&#x27;&#x27;</span><br>    print(<span class="hljs-string">&#x27;传入的数据字符串\t&#x27;</span>, base64_str)<br>    <span class="hljs-comment"># 处理最后一个字符，通过码表判断是否为填充用的字符，是则在记录后去除</span><br>    <span class="hljs-keyword">if</span> base64_str[-<span class="hljs-number">1</span>] <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> char64:<br>        base64_str = base64_str.replace(base64_str[-<span class="hljs-number">1</span>], <span class="hljs-string">&#x27;&#x27;</span>)<br>    print(<span class="hljs-string">&#x27;按码表处理填充字符\t&#x27;</span>, base64_str)<br>    <br>    <span class="hljs-comment"># 码表中寻找目标十进制数字序号替换对应项</span><br>    base64_int = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-keyword">lambda</span> x: char64.index(x), base64_str))<br>    print(<span class="hljs-string">&#x27;码表中寻找目标序号替换\t&#x27;</span>, base64_int)<br><br>    <span class="hljs-comment"># 十进制数字序号转六位二进制</span><br>    base64_6_bin = [<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;<span class="hljs-built_in">bin</span>(x)[<span class="hljs-number">2</span>:]:<span class="hljs-number">0</span>&gt;<span class="hljs-number">6</span>&#125;</span>&quot;</span> <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> base64_int]<br>    print(<span class="hljs-string">&#x27;十进制序号转六位二进制\t&#x27;</span>, base64_6_bin)<br><br>    <span class="hljs-comment"># 六位二进制转八位二进制</span><br>    base64_8_bin = cut(<span class="hljs-string">&#x27;&#x27;</span>.join(base64_6_bin), <span class="hljs-number">8</span>)<br>    print(<span class="hljs-string">&#x27;六位二进制转八位二进制\t&#x27;</span>, base64_8_bin)<br><br>    <span class="hljs-comment"># 抛弃位数不足的位数</span><br>    base64_8_bin = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">filter</span>(<span class="hljs-keyword">lambda</span> x: <span class="hljs-built_in">len</span>(x) == <span class="hljs-number">8</span>, base64_8_bin))<br>    print(<span class="hljs-string">&#x27;抛弃位数不足八位的项\t&#x27;</span>, base64_8_bin)<br><br>    <span class="hljs-comment"># 八位二进制转ascii字符</span><br>    ascii_str = [<span class="hljs-built_in">chr</span>(<span class="hljs-built_in">int</span>(x, <span class="hljs-number">2</span>)) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> base64_8_bin]<br>    print(<span class="hljs-string">&#x27;八位二进制转ascii字符\t&#x27;</span>, ascii_str)<br><br>    ascii_str = <span class="hljs-string">&#x27;&#x27;</span>.join(ascii_str)<br>    print(<span class="hljs-string">&#x27;base64转ascii 最终结果\t&#x27;</span>, ascii_str)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    base64_str = ascii_2_base64(<span class="hljs-string">&#x27;Hello&#x27;</span>)<br>    print()<br>    base64_2_ascii(base64_str)<br></code></pre></td></tr></table></figure><h1 id="MD5"><a href="#MD5" class="headerlink" title="MD5"></a>MD5</h1><p>信息指纹<br>MD5信息摘要算法（英语：MD5 Message-Digest Algorithm），一种被广泛使用的密码散列函数，可以产生出一个128位（16字节）的散列值（hash value）<br>多用于确保信息传输完整一致  </p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>输入任意长度的信息，经过处理，都会输出128位的信息（信息指纹）  </p><h2 id="获取"><a href="#获取" class="headerlink" title="获取"></a>获取</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_string_md5</span>(<span class="hljs-params">text</span>):</span><br>    m = hashlib. md5()<br>    m. update(text.encode(<span class="hljs-string">&quot;utf-8&quot;</span>))<br>    print(m. hexdigest())<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    get_string_md5(<span class="hljs-string">&#x27;Hello world&#x27;</span>)<br></code></pre></td></tr></table></figure><h2 id="更多信息"><a href="#更多信息" class="headerlink" title="更多信息"></a>更多信息</h2><p>MD5是不可逆的，是不能算回原文的<br>网上所谓的破解只是弄了一个超级大的数据，把绝大多数常用的东西算出来MD5结果，你输入什么就返回什么  </p><blockquote><p>MD5的抗碰撞性已经被人破解<br>简单而言，就是能根据一个MD5值，通过一些算法，快速得得到一些内容，其MD5结果与原本MD5一致<br>校验码一致，内容不一致，使得校验的安全性无法确定  </p></blockquote><h1 id="加密算法类别"><a href="#加密算法类别" class="headerlink" title="加密算法类别"></a>加密算法类别</h1><h2 id="对称加密算法"><a href="#对称加密算法" class="headerlink" title="对称加密算法"></a>对称加密算法</h2><p>一方通过秘钥将信息加密后，将密文传给另一方，另一方通过相同的秘钥解开密文得到明文  </p><h2 id="非对称加密算法"><a href="#非对称加密算法" class="headerlink" title="非对称加密算法"></a>非对称加密算法</h2><p>A要向B发送消息，A与B都要昌盛一对用于加密和解密的公钥和私钥，公钥用于加密，私钥用于解密<br>各自的私钥各自保密，各自的公钥对对方公开  </p><ol><li>A要发送信息时，A用B的公钥加密信息   </li><li>A将密文用B公钥加密过后的信息发送给B  </li><li>B收到密文后，用B自己的私钥解密密文  </li></ol><p>对于B发送给A的信息也一样<br>由于只有私钥能够解密，这个过程中所有其它收到密文和公钥的人都无法解密信息  </p><h2 id="区别与实际"><a href="#区别与实际" class="headerlink" title="区别与实际"></a>区别与实际</h2><table><thead><tr><th></th><th>对称加密算法</th><th>非对称加密算法</th></tr></thead><tbody><tr><td>安全性</td><td>较低</td><td>较快</td></tr><tr><td>处理速度</td><td>较快</td><td>较慢</td></tr></tbody></table><p>常见的情况是：将 对称加密的秘钥 用 非对称加密公钥 进行加密，接收方使用 非对称加密私钥 解密得到 对称加密的秘钥，然后双方使用 对称加密 进行通信  </p><h1 id="AES"><a href="#AES" class="headerlink" title="AES"></a>AES</h1><p>AES高级加密标准（Advanced Encryption Standard，AES），又称Rijndael加密法，是美国联邦政府采用的一种区块加密标准<br>AES是对称秘钥加密中最流行的算法之一<br>AES是DES的替代品  </p><h2 id="要素"><a href="#要素" class="headerlink" title="要素"></a>要素</h2><h3 id="秘钥"><a href="#秘钥" class="headerlink" title="秘钥"></a>秘钥</h3><p>支持三种秘钥长度128/192/256<br>秘钥越长，越安全，但是处理速度也越慢    </p><h3 id="填充-Padding"><a href="#填充-Padding" class="headerlink" title="填充 Padding"></a>填充 Padding</h3><p>AES并非一股脑将明文加密成密文的，而是把明文拆分成一个个独立的明文块（一块128bit）加密的<br>如果一段明文拆开多个块后，最后一个块没到128bit，那么久需要对明文块进行填充  </p><h4 id="常见填充类型"><a href="#常见填充类型" class="headerlink" title="常见填充类型"></a>常见填充类型</h4><ul><li>NoPadding<br>要求明文本身就符合分块要求，不允许不符合要求的明文  </li><li>ZeroPadding<br>用0进行填充，填充到位数够为止<br>并不推荐使用，当文明快最后一位是0时，解密可能出错  </li><li>PKCS7Padding<br>推荐使用<br>假设数据长度需要填充n(n&gt;0)个字节才对齐，那么填充n个字节，每个字节都是n;如果数据本身就已经对齐了，则填充一块长度为块大小的数据，每个字节都是块大小  </li></ul><h3 id="工作模式"><a href="#工作模式" class="headerlink" title="工作模式"></a>工作模式</h3><p>AES的工作模式，体现在把明文块加密成密文块的处理过程中<br>AES加密算法提供了五种不同的工作模式CBC、ECB、CTR、CFB、OFB<br>模式之间的主体思想是相似的，在处理细节上有区别  </p><h4 id="ECB模式"><a href="#ECB模式" class="headerlink" title="ECB模式"></a>ECB模式</h4><p>最简单的模式，此模式下，每个明文块的加密都是独立的，互不干涉的<br>优点是简单快捷，有利于并行计算<br>缺点是明文相同的块会变成相同的密文块，安全性比较差  </p><h3 id="CBC模式"><a href="#CBC模式" class="headerlink" title="CBC模式"></a>CBC模式</h3><p>CBC模式引入了一个新的概念：初始向量IV</p><blockquote><p>初始向量IV<br>其作用与 MD5加盐 类似，目的是为了防止 同样的明文块 被加密成 同样的密文块  </p></blockquote><p>CBC模式在每一个明文块加密前会让明文块和一个值做异或操作<br>IV作为初始化变量，参与第一个明文块的异或，后续的每一个明文块和它前一个明文块所加密出来的密文快相异或<br>最终得到 同样的明文块 被加密成 不同样的密文块<br>优点：安全性被提高<br>缺点：无法并行计算，性能不比ECB。引入了IV增加了复杂度  </p><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><ol><li>把明文按128bit拆分为多个明文块  </li><li>按照选择的填充方式填充最后一个明文块  </li><li>每一个明文块利用AES加密器和秘钥加密成密文块  </li><li>拼接所有的密文块，得到结果  </li></ol><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>简单的过程表示</p><p>secret = encrypt(key_type, message)<br>输入 加密信息，明文，得到加密结果<br>message = decrypt(key_type, message)<br>输入 加密信息，密文，得到明文信息</p><p>常用的对称加密算法</p><table><thead><tr><th>算法</th><th>秘钥长度</th><th>工作模式</th><th>填充模式</th></tr></thead><tbody><tr><td>DES</td><td>56/64</td><td>ECB/CBC/PCBC/CTR/…</td><td>NoPadding/PKCS5Padding/…</td></tr><tr><td>AES</td><td>128/192/256</td><td>ECB/CBC/PCBC/CTR/…</td><td>NoPadding/PKCS5Padding/PKCS7Padding/…</td></tr></tbody></table><p>秘钥的长度越长，加密越安全，但处理速度越慢<br>工作模式与填充模式可以看做是对称加密算法的参数和格式选择  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> base64<br><span class="hljs-keyword">from</span> Crypto.Cipher <span class="hljs-keyword">import</span> AES<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AES_Cipher</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, key</span>):</span><br>        self.bs = <span class="hljs-number">16</span><br>        key = key.encode(<span class="hljs-string">&quot;utf-8&quot;</span>)<br>        self.cipher = AES.new(key, AES.MODE_ECB)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">encrypt</span>(<span class="hljs-params">self, raw</span>):</span><br>        raw = self._pad(raw)<br>        raw = raw.encode(<span class="hljs-string">&quot;utf-8&quot;</span>)<br>        encrypted = self.cipher.encrypt(raw)<br>        encoded = base64.b64encode(encrypted)<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">str</span>(encoded, <span class="hljs-string">&#x27;utf-8&#x27;</span>)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">decrypt</span>(<span class="hljs-params">self, raw</span>):</span><br>        decoded = base64.b64decode(raw)<br>        decrypted = self.cipher.decrypt(decoded)<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">str</span>(self._unpad(decrypted), <span class="hljs-string">&#x27;utf-8&#x27;</span>)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_pad</span>(<span class="hljs-params">self, s</span>):</span><br>        <span class="hljs-comment"># 填充算法，由于算法需要特定位数，位数不足就需要填充</span><br>        <span class="hljs-keyword">return</span> s + (self.bs - <span class="hljs-built_in">len</span>(s) % self.bs) * <span class="hljs-built_in">chr</span>(self.bs - <span class="hljs-built_in">len</span>(s) % self.bs)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_unpad</span>(<span class="hljs-params">self, s</span>):</span><br>        <span class="hljs-keyword">return</span> s[:-<span class="hljs-built_in">ord</span>(s[<span class="hljs-built_in">len</span>(s)-<span class="hljs-number">1</span>:])]<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    a = <span class="hljs-string">&#x27;HelloWorld&#x27;</span><br>    aes = AES_Cipher(<span class="hljs-string">&#x27;abcdefgh12345678&#x27;</span>)<br>    w = aes.encrypt(a)<br>    print(w)<br>    print(aes.decrypt(w))<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>javascript</tag>
      
      <tag>Python</tag>
      
      <tag>加密</tag>
      
      <tag>编码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Scrapy-日志</title>
    <link href="/post/ead47af8/"/>
    <url>/post/ead47af8/</url>
    
    <content type="html"><![CDATA[<h1 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h1><p><code>Scrapy</code>提供了log功能，可以通过 <code>logging</code> 模块使用</p><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>通过在<code>setting.py</code>中进行以下设置可以被用来配置<code>logging</code>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">LOG_FILE = <span class="hljs-string">&quot;mySpider.log&quot;</span><br>LOG_LEVEL = <span class="hljs-string">&quot;INFO&quot;</span><br></code></pre></td></tr></table></figure><p>此处指定了 日志文件地址 与 <code>logging</code>级别</p><h2 id="Log级别"><a href="#Log级别" class="headerlink" title="Log级别"></a>Log级别</h2><p><code>Scrapy</code>提供5层<code>Log</code>级别:</p><ul><li>CRITICAL - 严重错误(critical)</li><li>ERROR - 一般错误(regular errors)</li><li>WARNING - 警告信息(warning messages)</li><li>INFO - 一般信息(informational messages)</li><li>DEBUG - 调试信息(debugging messages)</li></ul><p>级别设置得越高，记录的log内容就越少  </p><h2 id="全部log配置"><a href="#全部log配置" class="headerlink" title="全部log配置"></a>全部log配置</h2><ul><li>LOG_ENABLED<br>默认: True，启用logging  </li><li>LOG_ENCODING<br>默认: ‘utf-8’，logging使用的编码</li><li>LOG_FILE<br>默认: None，在当前目录里创建logging输出文件的文件名  </li><li>LOG_LEVEL<br>默认: ‘DEBUG’，log的最低级别  </li><li>LOG_STDOUT<br>默认: False 如果为 True，进程所有的标准输出(及错误)将会被重定向到log中。<blockquote><p>例如，执行 print “hello” ，其将会在Scrapy log中显示</p></blockquote></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>日志</tag>
      
      <tag>Scrapy</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SQLAlchemy-ORM-Python</title>
    <link href="/post/3e8c19c1/"/>
    <url>/post/3e8c19c1/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><code>SQLAlchemy</code>是<code>Python</code>的<code>SQL``ORM</code>工具<br><code>SQLAlchemy</code>提供了一整套的持久化方式，提供高性能的数据库访问</p><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul><li><code>SQLAlchemy</code>是一个强大的<code>ORM</code>，基于关系映射和核心Core制作  </li><li>可以通过操作对象模型，实现SQL的全部功能（包括连接查询，关联等）  </li><li>拥有一个灵活全面的系统，它可以快速的加载<code>Collections</code>与<code>Objects``Collections</code>被缓存在一个<code>Session</code>中，可以一次性查询整个结果也可以单个来进行访问  </li><li><code>SQLAlchemy``Core</code>独立于ORM，它本身是一个完整的数据库抽象层，包括可扩展的基于python的SQL表达式语言、模式元数据、连接池、类型强制和自定义类型  </li><li>所有主键和外键约束都是复合的和自然的。你可以自由组合  </li></ul><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><table><thead><tr><th>信息</th><th>链接</th></tr></thead><tbody><tr><td>官网</td><td><a href="https://www.sqlalchemy.org/">https://www.sqlalchemy.org/</a></td></tr><tr><td>文档</td><td><a href="http://www.sqlalchemy.org/docs/">http://www.sqlalchemy.org/docs/</a></td></tr><tr><td>github</td><td><a href="https://github.com/sqlalchemy/sqlalchemy">https://github.com/sqlalchemy/sqlalchemy</a></td></tr></tbody></table><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pip install SQLAlchemy<br></code></pre></td></tr></table></figure><h2 id="验证安装"><a href="#验证安装" class="headerlink" title="验证安装"></a>验证安装</h2><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">import sqlalchemy<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(sqlalchemy.__version__ )</span></span><br></code></pre></td></tr></table></figure><p>如果看到了版本信息，说明已经安装成功</p><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="创建连接"><a href="#创建连接" class="headerlink" title="创建连接"></a>创建连接</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sqlalchemy <span class="hljs-keyword">import</span> create_engine<br><span class="hljs-meta">&gt;&gt;&gt; </span>engine = create_engine(<span class="hljs-string">&#x27;sqlite:///:memory:&#x27;</span>, echo=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure><ul><li>echo参数<br>这个参数用于设置<code>SQLAlchemy</code>日志的记录  <ul><li>True 显示输出，你会在控制台看到所有信息  </li><li>False 这样做会减少输出信息的量  </li></ul></li><li>create_engine函数<br>这个函数会返回一个<code>Engine</code>实例，它代表着数据库核心接口<br>调用方法以后，引擎会建立与数据库的真实DBAPI连接。连接以后将其用于发出SQL  </li></ul><h2 id="声明映射关系类"><a href="#声明映射关系类" class="headerlink" title="声明映射关系类"></a>声明映射关系类</h2><p>声明映射关系的类是根据<code>Base</code>类定义的<br>你可以通过<code>declarative_base()</code>函数来获取<code>Base类</code>  </p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">from</span> sqlalchemy.ext.declarative <span class="hljs-keyword">import</span> declarative_base<br>Base = declarative_base()<br></code></pre></td></tr></table></figure><p>在有了<code>Base类</code>后你就可以声明映射关系的类了  </p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">from</span> sqlalchemy <span class="hljs-keyword">import</span> Column, Integer, String<br><span class="hljs-keyword">class</span> <span class="hljs-symbol">User</span>(<span class="hljs-symbol">Base</span>):<br>     <span class="hljs-symbol">__tablename__</span> = &#x27;<span class="hljs-symbol">users</span>&#x27;  # 表名<br><br>     <span class="hljs-symbol">id</span> = <span class="hljs-symbol">Column</span>(<span class="hljs-symbol">Integer, <span class="hljs-symbol">primary_key</span></span>=<span class="hljs-symbol">True</span>)  # <span class="hljs-symbol">int</span>类型主键 <span class="hljs-symbol">id</span><br>     <span class="hljs-symbol">name</span> = <span class="hljs-symbol">Column</span>(<span class="hljs-symbol">String</span>(<span class="hljs-symbol">50</span>), <span class="hljs-symbol">comment</span>=&#x27;姓名&#x27;)  # <span class="hljs-symbol">String</span>类型键<span class="hljs-symbol">name</span><br>     <span class="hljs-symbol">fullname</span> = <span class="hljs-symbol">Column</span>(<span class="hljs-symbol">String</span>(<span class="hljs-symbol">50</span>), <span class="hljs-symbol">comment</span>=&#x27;全名&#x27;)  # <span class="hljs-symbol">String</span>类型键<span class="hljs-symbol">fullname</span><br>     <span class="hljs-symbol">nickname</span> = <span class="hljs-symbol">Column</span>(<span class="hljs-symbol">String</span>(<span class="hljs-symbol">50</span>), <span class="hljs-symbol">comment</span>=&#x27;昵称&#x27;)  # <span class="hljs-symbol">String</span>类型键<span class="hljs-symbol">nickname</span><br></code></pre></td></tr></table></figure><p>定义并不复杂，非常的简单明了，声明键类型与长度，添加注释<br>这个类虽然代表了映射关系，但它本身依旧可以定义和使用成员函数/属性  </p><p>meatadata是一个包含了生成命令的注册机<br>你可以使用<code>MetaData.create_all()</code>来创建表</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Base</span>.</span></span>metadata.create<span class="hljs-constructor">_all(<span class="hljs-params">engine</span>)</span><br></code></pre></td></tr></table></figure><h2 id="创建映射关系实例"><a href="#创建映射关系实例" class="headerlink" title="创建映射关系实例"></a>创建映射关系实例</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">ed_user = User(<span class="hljs-attribute">name</span>=<span class="hljs-string">&#x27;ed&#x27;</span>, <span class="hljs-attribute">fullname</span>=<span class="hljs-string">&#x27;Ed Jones&#x27;</span>, <span class="hljs-attribute">nickname</span>=<span class="hljs-string">&#x27;edsnickname&#x27;</span>)<br></code></pre></td></tr></table></figure><p>就算你没有声明构造函数，它也能根据传进来的参数对对应的项进行赋值  </p><h2 id="创建会话"><a href="#创建会话" class="headerlink" title="创建会话"></a>创建会话</h2><p>使用<code>create_engine()</code>来创建一个<code>Session</code>类（需要传入一个engine）  </p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nim"><span class="hljs-keyword">from</span> sqlalchemy.orm <span class="hljs-keyword">import</span> sessionmaker<br><span class="hljs-type">Session</span> = sessionmaker(<span class="hljs-keyword">bind</span>=engine)<br></code></pre></td></tr></table></figure><p>这个定制的<code>Session</code>类将创建绑定到我们数据库的新<code>Session对象</code><br>每当需要与数据库进行对话时，都可以实例化一个<code>Session</code>  </p><h2 id="插入-更新-数据"><a href="#插入-更新-数据" class="headerlink" title="插入/更新 数据"></a>插入/更新 数据</h2><p>将实例用<code>session.add()</code>方法添加到<code>Session</code>中，以持久化  </p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">ed_user = User(<span class="hljs-attribute">name</span>=<span class="hljs-string">&#x27;ed&#x27;</span>, <span class="hljs-attribute">fullname</span>=<span class="hljs-string">&#x27;Ed Jones&#x27;</span>, <span class="hljs-attribute">nickname</span>=<span class="hljs-string">&#x27;edsnickname&#x27;</span>)<br>session.<span class="hljs-builtin-name">add</span>(ed_user)<br></code></pre></td></tr></table></figure><p>在执行完这些代码以后，实例会被挂起，并没有发出SQL给数据<br>但如果你通过这个<code>Session</code>使用查询功能，这个实例会被找到<br>你可以通过add_all函数一次性添加多个实例  </p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs routeros">session.add_all([<br>     User(<span class="hljs-attribute">name</span>=<span class="hljs-string">&#x27;wendy&#x27;</span>, <span class="hljs-attribute">fullname</span>=<span class="hljs-string">&#x27;Wendy Williams&#x27;</span>, <span class="hljs-attribute">nickname</span>=<span class="hljs-string">&#x27;windy&#x27;</span>),<br>     User(<span class="hljs-attribute">name</span>=<span class="hljs-string">&#x27;mary&#x27;</span>, <span class="hljs-attribute">fullname</span>=<span class="hljs-string">&#x27;Mary Contrary&#x27;</span>, <span class="hljs-attribute">nickname</span>=<span class="hljs-string">&#x27;mary&#x27;</span>),<br>     User(<span class="hljs-attribute">name</span>=<span class="hljs-string">&#x27;fred&#x27;</span>, <span class="hljs-attribute">fullname</span>=<span class="hljs-string">&#x27;Fred Flintstone&#x27;</span>, <span class="hljs-attribute">nickname</span>=<span class="hljs-string">&#x27;freddy&#x27;</span>)])<br></code></pre></td></tr></table></figure><p>当你真的希望向数据库发送SQL提交事务时可以使用<code>session.commit()</code>  </p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">session</span>.<span class="hljs-keyword">commit</span>()<br></code></pre></td></tr></table></figure><h2 id="回滚"><a href="#回滚" class="headerlink" title="回滚"></a>回滚</h2><p>当发生一些冲突（如重复的主键之类的问题时）可以用回滚操作来让Session中的实例回归正常状态  </p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">session</span>.<span class="hljs-keyword">rollback</span>()<br></code></pre></td></tr></table></figure><h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><p>使用<code>session.query()</code>方法，传入关系映射类作为参数来进行查询  </p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs smali">for<span class="hljs-built_in"> instance </span>in session.query(User).order_by(User.id):<br>     print(instance.name, instance.fullname)<br></code></pre></td></tr></table></figure><p>可以指定返回的键  </p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">for</span> <span class="hljs-keyword">row</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">session</span>.query(<span class="hljs-keyword">User</span>, <span class="hljs-keyword">User</span>.name).<span class="hljs-keyword">all</span>():<br>    print(<span class="hljs-keyword">row</span>.<span class="hljs-keyword">User</span>, <span class="hljs-keyword">row</span>.name)<br></code></pre></td></tr></table></figure><blockquote><p>all()方法会返回所有结果，在数据量较多时，一次性全载入内存可能会引起问题<br>类似的，first()方法会返回第一个结果<br>可以查询特定的键为某个值的数据  </p></blockquote><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">for</span> <span class="hljs-selector-tag">row</span> <span class="hljs-selector-tag">in</span> <span class="hljs-selector-tag">session</span><span class="hljs-selector-class">.query</span>(User.name.label(<span class="hljs-string">&#x27;name_label&#x27;</span>))<span class="hljs-selector-class">.all</span>():<br>...    <span class="hljs-selector-tag">print</span>(row.name_label)<br></code></pre></td></tr></table></figure><p>结合<code>order_by</code>与切片功能来使用  </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">for</span> <span class="hljs-selector-tag">u</span> <span class="hljs-selector-tag">in</span> <span class="hljs-selector-tag">session</span><span class="hljs-selector-class">.query</span>(<span class="hljs-selector-tag">User</span>)<span class="hljs-selector-class">.order_by</span>(<span class="hljs-selector-tag">User</span><span class="hljs-selector-class">.id</span>)<span class="hljs-selector-attr">[1:3]</span>:<br>    <span class="hljs-selector-tag">print</span>(<span class="hljs-selector-tag">u</span>)<br></code></pre></td></tr></table></figure><p>过滤结果</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">for</span> <span class="hljs-type">name</span>, <span class="hljs-keyword">in</span> <span class="hljs-keyword">session</span>.query(<span class="hljs-keyword">User</span>.name).filter_by(fullname=<span class="hljs-string">&#x27;Ed Jones&#x27;</span>):<br>    print(<span class="hljs-type">name</span>)<br></code></pre></td></tr></table></figure><p>后续：<a href="https://docs.sqlalchemy.org/en/13/orm/tutorial.html">https://docs.sqlalchemy.org/en/13/orm/tutorial.html</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>SQLAlchemy</tag>
      
      <tag>ORM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>javascript-encode混淆</title>
    <link href="/post/a78cd365/"/>
    <url>/post/a78cd365/</url>
    
    <content type="html"><![CDATA[<h1 id="大体思路"><a href="#大体思路" class="headerlink" title="大体思路"></a>大体思路</h1><p>这种让你看不懂代码的方式是通过编码实现的  </p><p>编译器能都识别那些 由 16进制字符 或者 Unicode 字符<br>一般而言为了 让字符看起来非常难顶，代码作者会设计将字符转换成一些奇怪的字符<br>但为了不影响代码逻辑，这些奇怪字符的值依然与原本保持一致  </p><p>代码会被保存为非常长的字符串格式<br>在多数情况下是类似于这样  </p><ul><li><code>()[&quot;constructor&quot;][&quot;constructor&quot;](执行代码)()</code> </li><li>eval(执行代码)</li></ul><p>当然，它不会明面的把函数写上，他会绕来绕去，让你看不出  </p><h1 id="AAencode"><a href="#AAencode" class="headerlink" title="AAencode"></a>AAencode</h1><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>既然是一个开源的，那就查看一下源码吧<br>Github: <a href="https://github.com/bprayudha/jquery.aaencode">https://github.com/bprayudha/jquery.aaencode</a>  </p><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs javascript">(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">$</span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> aaencode = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">text</span>) </span>&#123;<br>        <span class="hljs-keyword">var</span> t;<br>        <span class="hljs-keyword">var</span> b = [<br>            <span class="hljs-string">&quot;(c^_^o)&quot;</span> ,<br>            <span class="hljs-string">&quot;(ﾟΘﾟ)&quot;</span> ,<br>            <span class="hljs-string">&quot;((o^_^o) - (ﾟΘﾟ))&quot;</span> ,<br>            <span class="hljs-string">&quot;(o^_^o)&quot;</span> ,<br>            <span class="hljs-string">&quot;(ﾟｰﾟ)&quot;</span> ,<br>            <span class="hljs-string">&quot;((ﾟｰﾟ) + (ﾟΘﾟ))&quot;</span> ,<br>            <span class="hljs-string">&quot;((o^_^o) +(o^_^o))&quot;</span> ,<br>            <span class="hljs-string">&quot;((ﾟｰﾟ) + (o^_^o))&quot;</span> ,<br>            <span class="hljs-string">&quot;((ﾟｰﾟ) + (ﾟｰﾟ))&quot;</span> ,<br>            <span class="hljs-string">&quot;((ﾟｰﾟ) + (ﾟｰﾟ) + (ﾟΘﾟ))&quot;</span> ,<br>            <span class="hljs-string">&quot;(ﾟДﾟ) .ﾟωﾟﾉ&quot;</span> ,<br>            <span class="hljs-string">&quot;(ﾟДﾟ) .ﾟΘﾟﾉ&quot;</span> ,<br>            <span class="hljs-string">&quot;(ﾟДﾟ) [&#x27;c&#x27;]&quot;</span> ,<br>            <span class="hljs-string">&quot;(ﾟДﾟ) .ﾟｰﾟﾉ&quot;</span> ,<br>            <span class="hljs-string">&quot;(ﾟДﾟ) .ﾟДﾟﾉ&quot;</span> ,<br>            <span class="hljs-string">&quot;(ﾟДﾟ) [ﾟΘﾟ]&quot;</span><br>        ];<br>        <span class="hljs-keyword">var</span> r = <span class="hljs-string">&quot;ﾟωﾟﾉ= /｀ｍ´）ﾉ ~┻━┻   //*´∇｀*/ [&#x27;_&#x27;]; o=(ﾟｰﾟ)  =_=3; c=(ﾟΘﾟ) =(ﾟｰﾟ)-(ﾟｰﾟ); &quot;</span>; <br>        r += <span class="hljs-string">&quot;(ﾟДﾟ) =(ﾟΘﾟ)= (o^_^o)/ (o^_^o);&quot;</span> +<br>            <span class="hljs-string">&quot;(ﾟДﾟ)=&#123;ﾟΘﾟ: &#x27;_&#x27; ,ﾟωﾟﾉ : ((ﾟωﾟﾉ==3) +&#x27;_&#x27;) [ﾟΘﾟ] &quot;</span> +<br>            <span class="hljs-string">&quot;,ﾟｰﾟﾉ :(ﾟωﾟﾉ+ &#x27;_&#x27;)[o^_^o -(ﾟΘﾟ)] &quot;</span>+<br>            <span class="hljs-string">&quot;,ﾟДﾟﾉ:((ﾟｰﾟ==3) +&#x27;_&#x27;)[ﾟｰﾟ] &#125;; (ﾟДﾟ) [ﾟΘﾟ] =((ﾟωﾟﾉ==3) +&#x27;_&#x27;) [c^_^o];&quot;</span> +<br>            <span class="hljs-string">&quot;(ﾟДﾟ) [&#x27;c&#x27;] = ((ﾟДﾟ)+&#x27;_&#x27;) [ (ﾟｰﾟ)+(ﾟｰﾟ)-(ﾟΘﾟ) ];&quot;</span>+<br>            <span class="hljs-string">&quot;(ﾟДﾟ) [&#x27;o&#x27;] = ((ﾟДﾟ)+&#x27;_&#x27;) [ﾟΘﾟ];&quot;</span>+<br>            <span class="hljs-string">&quot;(ﾟoﾟ)=(ﾟДﾟ) [&#x27;c&#x27;]+(ﾟДﾟ) [&#x27;o&#x27;]+(ﾟωﾟﾉ +&#x27;_&#x27;)[ﾟΘﾟ]+ ((ﾟωﾟﾉ==3) +&#x27;_&#x27;) [ﾟｰﾟ] + &quot;</span> +<br>            <span class="hljs-string">&quot;((ﾟДﾟ) +&#x27;_&#x27;) [(ﾟｰﾟ)+(ﾟｰﾟ)]+ ((ﾟｰﾟ==3) +&#x27;_&#x27;) [ﾟΘﾟ]+&quot;</span> +<br>            <span class="hljs-string">&quot;((ﾟｰﾟ==3) +&#x27;_&#x27;) [(ﾟｰﾟ) - (ﾟΘﾟ)]+(ﾟДﾟ) [&#x27;c&#x27;]+&quot;</span> +<br>            <span class="hljs-string">&quot;((ﾟДﾟ)+&#x27;_&#x27;) [(ﾟｰﾟ)+(ﾟｰﾟ)]+ (ﾟДﾟ) [&#x27;o&#x27;]+&quot;</span> +<br>            <span class="hljs-string">&quot;((ﾟｰﾟ==3) +&#x27;_&#x27;) [ﾟΘﾟ];(ﾟДﾟ) [&#x27;_&#x27;] =(o^_^o) [ﾟoﾟ] [ﾟoﾟ];&quot;</span> +<br>            <span class="hljs-string">&quot;(ﾟεﾟ)=((ﾟｰﾟ==3) +&#x27;_&#x27;) [ﾟΘﾟ]+ (ﾟДﾟ) .ﾟДﾟﾉ+&quot;</span>+<br>            <span class="hljs-string">&quot;((ﾟДﾟ)+&#x27;_&#x27;) [(ﾟｰﾟ) + (ﾟｰﾟ)]+((ﾟｰﾟ==3) +&#x27;_&#x27;) [o^_^o -ﾟΘﾟ]+&quot;</span> +<br>            <span class="hljs-string">&quot;((ﾟｰﾟ==3) +&#x27;_&#x27;) [ﾟΘﾟ]+ (ﾟωﾟﾉ +&#x27;_&#x27;) [ﾟΘﾟ]; &quot;</span> +<br>            <span class="hljs-string">&quot;(ﾟｰﾟ)+=(ﾟΘﾟ); (ﾟДﾟ)[ﾟεﾟ]=&#x27;\\\\&#x27;; &quot;</span> +<br>            <span class="hljs-string">&quot;(ﾟДﾟ).ﾟΘﾟﾉ=(ﾟДﾟ+ ﾟｰﾟ)[o^_^o -(ﾟΘﾟ)];&quot;</span> + <br>            <span class="hljs-string">&quot;(oﾟｰﾟo)=(ﾟωﾟﾉ +&#x27;_&#x27;)[c^_^o];&quot;</span> +<br>            <span class="hljs-string">&quot;(ﾟДﾟ) [ﾟoﾟ]=&#x27;\\\&quot;&#x27;;&quot;</span> + <br>            <span class="hljs-string">&quot;(ﾟДﾟ) [&#x27;_&#x27;] ( (ﾟДﾟ) [&#x27;_&#x27;] (ﾟεﾟ+&quot;</span> +<br>            <span class="hljs-string">&quot;(ﾟДﾟ)[ﾟoﾟ]+ &quot;</span>;<br><br>        <span class="hljs-keyword">for</span>( <span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; text.length; i++ ) &#123;<br>            n = text.charCodeAt( i );<br>            t = <span class="hljs-string">&quot;(ﾟДﾟ)[ﾟεﾟ]+&quot;</span>;<br>            <span class="hljs-keyword">if</span>( n &lt;= <span class="hljs-number">127</span> ) &#123;<br>                t += n.toString( <span class="hljs-number">8</span> ).replace( <span class="hljs-regexp">/[0-7]/g</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">c</span>) </span>&#123;<br>                  <span class="hljs-keyword">return</span> b[ c ] + <span class="hljs-string">&quot;+ &quot;</span>;<br>                &#125;);<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">var</span> m = <span class="hljs-regexp">/[0-9a-f]&#123;4&#125;$/</span>.exec( <span class="hljs-string">&quot;000&quot;</span> + n.toString(<span class="hljs-number">16</span> ) )[<span class="hljs-number">0</span>];<br>                t += <span class="hljs-string">&quot;(oﾟｰﾟo)+ &quot;</span> + m.replace( <span class="hljs-regexp">/[0-9a-f]/gi</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">c</span>) </span>&#123;<br>                  <span class="hljs-keyword">return</span> b[ <span class="hljs-built_in">parseInt</span>( c,<span class="hljs-number">16</span> ) ] + <span class="hljs-string">&quot;+ &quot;</span>;<br>                &#125;);<br>            &#125;<br>            r += t;<br><br>        &#125;<br>        <br>        r += <span class="hljs-string">&quot;(ﾟДﾟ)[ﾟoﾟ]) (ﾟΘﾟ)) (&#x27;_&#x27;);&quot;</span>;<br>        <br>        <span class="hljs-keyword">return</span> r;<br>    &#125;<br><br>    $.fn.aaencode = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-keyword">return</span> aaencode(<span class="hljs-built_in">this</span>.val());<br>    &#125;<br>&#125;)(jQuery);<br></code></pre></td></tr></table></figure><p>逐一调试观察逻辑并记录<br>（为了调试方便改写了一些格式，但内容没改）  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_aaencode</span>(<span class="hljs-params">text</span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> t;<br>    <span class="hljs-comment">// 定义一些表情字符用作替代目标, 里面的每一个表情都对应着一个真正的值</span><br>    <span class="hljs-comment">// 在那些变量被赋值后(如(c^_^o)的c和o)，整个标签符号的值才会真正显现出来</span><br>    <span class="hljs-comment">// 0-9 a-f</span><br>    <span class="hljs-keyword">var</span> b = [<br>        <span class="hljs-string">&quot;(c^_^o)&quot;</span>,<br>        <span class="hljs-string">&quot;(ﾟΘﾟ)&quot;</span>,<br>        <span class="hljs-string">&quot;((o^_^o) - (ﾟΘﾟ))&quot;</span>,<br>        <span class="hljs-string">&quot;(o^_^o)&quot;</span>,<br>        <span class="hljs-string">&quot;(ﾟｰﾟ)&quot;</span>,<br>        <span class="hljs-string">&quot;((ﾟｰﾟ) + (ﾟΘﾟ))&quot;</span>,<br>        <span class="hljs-string">&quot;((o^_^o) +(o^_^o))&quot;</span>,<br>        <span class="hljs-string">&quot;((ﾟｰﾟ) + (o^_^o))&quot;</span>,<br>        <span class="hljs-string">&quot;((ﾟｰﾟ) + (ﾟｰﾟ))&quot;</span>,<br>        <span class="hljs-string">&quot;((ﾟｰﾟ) + (ﾟｰﾟ) + (ﾟΘﾟ))&quot;</span>,<br>        <span class="hljs-string">&quot;(ﾟДﾟ) .ﾟωﾟﾉ&quot;</span>,<br>        <span class="hljs-string">&quot;(ﾟДﾟ) .ﾟΘﾟﾉ&quot;</span>,<br>        <span class="hljs-string">&quot;(ﾟДﾟ) [&#x27;c&#x27;]&quot;</span>,<br>        <span class="hljs-string">&quot;(ﾟДﾟ) .ﾟｰﾟﾉ&quot;</span>,<br>        <span class="hljs-string">&quot;(ﾟДﾟ) .ﾟДﾟﾉ&quot;</span>,<br>        <span class="hljs-string">&quot;(ﾟДﾟ) [ﾟΘﾟ]&quot;</span><br>    ];<br>    <span class="hljs-comment">// r 实际上是最终字符串</span><br>    <span class="hljs-comment">// 定义了一些变量</span><br>    <span class="hljs-keyword">var</span> r =<br>        <span class="hljs-comment">// &quot;ﾟωﾟﾉ = /｀ｍ´）ﾉ ~┻━┻   //*´∇｀*/ [&#x27;_&#x27;]</span><br>        <span class="hljs-string">&quot;ﾟωﾟﾉ= /｀ｍ´）ﾉ ~┻━┻   //*´∇｀*/ [&#x27;_&#x27;];&quot;</span> +<br>        <span class="hljs-comment">// o = 3</span><br>        <span class="hljs-comment">// _ = 3</span><br>        <span class="hljs-string">&quot; o=(ﾟｰﾟ)  =_=3;&quot;</span> +<br>        <span class="hljs-comment">// c = 0</span><br>        <span class="hljs-comment">// (ﾟΘﾟ) = 0</span><br>        <span class="hljs-string">&quot; c=(ﾟΘﾟ) =(ﾟｰﾟ)-(ﾟｰﾟ); &quot;</span>;<br>    r +=<br>        <span class="hljs-comment">// (ﾟДﾟ) = (ﾟΘﾟ) = 1</span><br>        <span class="hljs-string">&quot;(ﾟДﾟ) =(ﾟΘﾟ)= (o^_^o)/ (o^_^o);&quot;</span> +<br>        <span class="hljs-comment">// (ﾟДﾟ) = &#123;ﾟΘﾟ: &quot;_&quot;, ﾟωﾟﾉ: &quot;a&quot;, ﾟｰﾟﾉ: &quot;d&quot;, ﾟДﾟﾉ: &quot;e&quot;&#125;</span><br>        <span class="hljs-string">&quot;(ﾟДﾟ)=&#123;ﾟΘﾟ: &#x27;_&#x27; ,ﾟωﾟﾉ : ((ﾟωﾟﾉ==3) +&#x27;_&#x27;) [ﾟΘﾟ] ,ﾟｰﾟﾉ :(ﾟωﾟﾉ+ &#x27;_&#x27;)[o^_^o -(ﾟΘﾟ)] ,ﾟДﾟﾉ:((ﾟｰﾟ==3) +&#x27;_&#x27;)[ﾟｰﾟ] &#125;; &quot;</span> +<br>        <span class="hljs-comment">// (ﾟДﾟ) [ﾟΘﾟ] = &#x27;f&#x27;</span><br>        <span class="hljs-string">&quot;(ﾟДﾟ) [ﾟΘﾟ] =((ﾟωﾟﾉ==3) +&#x27;_&#x27;) [c^_^o];&quot;</span> +<br>        <span class="hljs-comment">// (ﾟДﾟ) [&#x27;c&#x27;] = &#x27;c&#x27;</span><br>        <span class="hljs-string">&quot;(ﾟДﾟ) [&#x27;c&#x27;] = ((ﾟДﾟ)+&#x27;_&#x27;) [ (ﾟｰﾟ)+(ﾟｰﾟ)-(ﾟΘﾟ) ];&quot;</span> +<br>        <span class="hljs-comment">// (ﾟДﾟ) [&#x27;o&#x27;] = &#x27;o&#x27;</span><br>        <span class="hljs-string">&quot;(ﾟДﾟ) [&#x27;o&#x27;] = ((ﾟДﾟ)+&#x27;_&#x27;) [ﾟΘﾟ];&quot;</span> +<br>        <span class="hljs-comment">// constructor</span><br>        <span class="hljs-string">&quot;(ﾟoﾟ)=(ﾟДﾟ) [&#x27;c&#x27;]+(ﾟДﾟ) [&#x27;o&#x27;]+(ﾟωﾟﾉ +&#x27;_&#x27;)[ﾟΘﾟ]+ ((ﾟωﾟﾉ==3) +&#x27;_&#x27;) [ﾟｰﾟ] + ((ﾟДﾟ) +&#x27;_&#x27;) [(ﾟｰﾟ)+(ﾟｰﾟ)]+ ((ﾟｰﾟ==3) +&#x27;_&#x27;) [ﾟΘﾟ]+((ﾟｰﾟ==3) +&#x27;_&#x27;) [(ﾟｰﾟ) - (ﾟΘﾟ)]+(ﾟДﾟ) [&#x27;c&#x27;]+((ﾟДﾟ)+&#x27;_&#x27;) [(ﾟｰﾟ)+(ﾟｰﾟ)]+ (ﾟДﾟ) [&#x27;o&#x27;]+((ﾟｰﾟ==3) +&#x27;_&#x27;) [ﾟΘﾟ];&quot;</span> +<br>        <span class="hljs-comment">// (ﾟДﾟ) [&#x27;_&#x27;] =  3[&#x27;constructor&#x27;][&#x27;constructor&#x27;] 等价于 ƒ Function() &#123; [native code] &#125;</span><br>        <span class="hljs-string">&quot;(ﾟДﾟ) [&#x27;_&#x27;] =(o^_^o) [ﾟoﾟ] [ﾟoﾟ];&quot;</span> +<br>        <span class="hljs-comment">// (ﾟεﾟ) = &#x27;return&#x27;</span><br>        <span class="hljs-string">&quot;(ﾟεﾟ)=((ﾟｰﾟ==3) +&#x27;_&#x27;) [ﾟΘﾟ]+ (ﾟДﾟ) .ﾟДﾟﾉ+((ﾟДﾟ)+&#x27;_&#x27;) [(ﾟｰﾟ) + (ﾟｰﾟ)]+((ﾟｰﾟ==3) +&#x27;_&#x27;) [o^_^o -ﾟΘﾟ]+((ﾟｰﾟ==3) +&#x27;_&#x27;) [ﾟΘﾟ]+ (ﾟωﾟﾉ +&#x27;_&#x27;) [ﾟΘﾟ]; &quot;</span> +<br>        <span class="hljs-comment">// (ﾟｰﾟ) = 3</span><br>        <span class="hljs-string">&quot;(ﾟｰﾟ)+=(ﾟΘﾟ);&quot;</span>,<br>        <span class="hljs-comment">// (ﾟДﾟ)[ﾟεﾟ] = &quot;\\&quot;</span><br>        <span class="hljs-string">&quot;(ﾟДﾟ)[ﾟεﾟ]=&#x27;\\\\&#x27;; &quot;</span> +<br>        <span class="hljs-comment">// (ﾟДﾟ).ﾟΘﾟﾉ = &quot;b&quot;</span><br>        <span class="hljs-string">&quot;(ﾟДﾟ).ﾟΘﾟﾉ=(ﾟДﾟ+ ﾟｰﾟ)[o^_^o -(ﾟΘﾟ)];&quot;</span> +<br>        <span class="hljs-comment">// (oﾟｰﾟo) = &#x27;u&#x27;</span><br>        <span class="hljs-string">&quot;(oﾟｰﾟo)=(ﾟωﾟﾉ +&#x27;_&#x27;)[c^_^o];&quot;</span> +<br>        <span class="hljs-comment">// (ﾟДﾟ) [ﾟoﾟ] = &quot;\\\&quot;&quot;</span><br>        <span class="hljs-string">&quot;(ﾟДﾟ) [ﾟoﾟ]=&#x27;\\\&quot;&#x27;;&quot;</span> +<br>        <span class="hljs-comment">// function (function (return object 中间导入的字符串 ))</span><br>        <span class="hljs-string">&quot;(ﾟДﾟ) [&#x27;_&#x27;] ( (ﾟДﾟ) [&#x27;_&#x27;] (ﾟεﾟ+(ﾟДﾟ)[ﾟoﾟ]+ (ﾟДﾟ)[ﾟoﾟ]) (ﾟΘﾟ)) (&#x27;_&#x27;);&quot;</span>;<br><br>    <span class="hljs-comment">// 遍历传入字符串的所有字符</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; text.length; i++) &#123;<br>        n = text.charCodeAt(i);<br>        <span class="hljs-comment">// charCodeAt() 方法可返回指定位置的字符的 Unicode 编码数</span><br>        <span class="hljs-comment">// 由于实际上是标记的转码字符，这里献给内容加上一个转义字符&#x27;\\&#x27;</span><br>        t = <span class="hljs-string">&quot;(ﾟДﾟ)[ﾟεﾟ]+&quot;</span>;<br>        <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">127</span>) &#123;<br>            <span class="hljs-comment">// unicode 只处理 C0控制与基本的Latin（拉丁字母），这其实已经包含了绝大部分的js源码符号</span><br>            <span class="hljs-comment">// 将 十进制数字符串 转为 为8进制数字符串</span><br>            n = n.toString(<span class="hljs-number">8</span>);<br>            <span class="hljs-comment">// 对八进制数字符串 里的每一个数字(0-7) 用 预先定义好的表情符合进行取代</span><br>            t += n.replace(<span class="hljs-regexp">/[0-7]/g</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">c</span>) </span>&#123;<br>                <span class="hljs-keyword">return</span> b[c] + <span class="hljs-string">&quot;+ &quot;</span>;<br>                <span class="hljs-comment">// 取代完以后，在最后添加一个 &#x27;+ &#x27;用于最后eval函数拼接而不出问题</span><br>            &#125;);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 对于非C0控制与基本的Latin（拉丁字母）。即 非js代码部分，诸如中文之类的</span><br>            <span class="hljs-comment">// 用 &quot;000&quot;+原字符数字转16进制</span><br>            n = <span class="hljs-string">&quot;000&quot;</span> + n.toString(<span class="hljs-number">16</span>);<br>            <span class="hljs-comment">// 用正则表达式/[0-9a-f]&#123;4&#125;$/ 在 十六进数字字符 中寻找匹配项 并返回最短匹配</span><br>            <span class="hljs-keyword">var</span> m = <span class="hljs-regexp">/[0-9a-f]&#123;4&#125;$/</span>.exec(n)[<span class="hljs-number">0</span>];<br>            <span class="hljs-comment">// 将这个 十六进数字字符 转为对应的10进制数字（因为记录表情的是一个数组，如果传入a-f字符来获取表情的话会报错，所以转10进制数），再转为表情，在最后添加一个 &#x27;+ &#x27;</span><br>            m = m.replace(<span class="hljs-regexp">/[0-9a-f]/gi</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">c</span>) </span>&#123;<br>                <span class="hljs-keyword">return</span> b[<span class="hljs-built_in">parseInt</span>(c, <span class="hljs-number">16</span>)] + <span class="hljs-string">&quot;+ &quot;</span>;<br>            &#125;);<br>            <span class="hljs-comment">// 字符结果添加前缀 u以作Unicode字符标记</span><br>            t += <span class="hljs-string">&quot;(oﾟｰﾟo)+ &quot;</span> + m;<br>        &#125;<br>        <span class="hljs-comment">// 单个字符汇总到答案</span><br>        r += t;<br><br>    &#125;<br><br>    <span class="hljs-comment">// 添加结尾字符</span><br>    r += <span class="hljs-string">&quot;(ﾟДﾟ)[ﾟoﾟ]) (ﾟΘﾟ)) (&#x27;_&#x27;);&quot;</span>;<br><br>    <span class="hljs-comment">// 返回整个字符串</span><br>    <span class="hljs-keyword">return</span> r;<br>&#125;<br></code></pre></td></tr></table></figure><p>在详细分析以后，过程是比较得明朗的  </p><h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><ol><li><p>定义一个 表情符号数组<br>为了增加迷惑性，设定一个表情符号数组，用作未来取代<code>javascript</code>代码字符    </p></li><li><p>定义外围函数包围原本的代码<br>最外面包裹着一层 执行解释函数<br>通过各种奇怪的符号构造出 <code>()[&quot;constructor&quot;][&quot;constructor&quot;](执行代码)()</code><br><code>()[&quot;constructor&quot;][&quot;constructor&quot;](执行代码)()</code>等价于<code>Function (执行代码)()</code>，能执行代码  </p></li><li><p>原本的js代码通过<code>unicode编码</code>后映射到了一个数上，作者将这个数做了区分处理  </p><ul><li>这个数在0-127之间，说明是数字字母等javascript代码原本需要用到的字符 <a href="https://www.runoob.com/charsets/ref-utf-basic-latin.html">C0 控制与基本的 Latin（拉丁字母）</a><br>这种字符作者将数转为8进制后，将每一位的数转为表情字符</li><li>这个数超出127，说明这个字符并非常规的字母数字等，而是一些较少使用的字符，如中文之类的<br>这种字符作者将数转为16进制后，将每一位的数转为表情字符，最后在前面添加一个”(oﾟｰﾟo)”（实际上是字符 u）用作标识Unicode字符  </li></ul></li></ol><ul><li>为什么可以转为表情<br>  实际上，在一开始的变量声明完毕以后，表情字符本身的值就等于序号（16进制，超出的会对应a-f）<br>  这是作者设定好的，混淆是让你看不懂，并不会破坏逻辑本身<br>  你可以尝试着去获取那些值  </li></ul><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><ol><li><p>删掉最后的<code>(&#39;_&#39;);&quot;;</code>,若是不行，可以在后面加<code>toString()</code>来把函数转为字符串输出<br>由于代码是<code>()[&quot;constructor&quot;][&quot;constructor&quot;](执行代码)()</code>这种形式的<br>如果你把最后的括号删掉，那么源代码函数就会暴露出来，直接得到源码了  </p></li><li><p>进入虚拟空间VM即可看到源码<br>在执行混淆代码之前，打上断点，步进到混淆代码内部，分析堆栈，进入虚拟空间，就能看到源码了<br>如果内部代码执行报错，那么也可以通过报错的定位进入虚拟空间  </p></li></ol><p style="text-align:right">Recluse<br>2020年8月13日14:53:10 </p>]]></content>
    
    
    
    <tags>
      
      <tag>javascript</tag>
      
      <tag>js混淆</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Node.js</title>
    <link href="/post/747d7228/"/>
    <url>/post/747d7228/</url>
    
    <content type="html"><![CDATA[<h1 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h1><p><code>Node.js</code> 是一个基于 <code>Chrome V8</code> 引擎的 <code>JavaScript</code> 运行时   </p><ul><li>官网：<a href="https://nodejs.org/zh-cn/">https://nodejs.org/zh-cn/</a>  </li><li>官方文档：<a href="https://nodejs.org/zh-cn/docs/">https://nodejs.org/zh-cn/docs/</a>  </li><li>中文文档：<a href="http://nodejs.cn/api/">http://nodejs.cn/api/</a>  </li></ul><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><ol><li><p>进入官网，下载安装包，安装<br><img src="/Node.js-%E5%9F%BA%E7%A1%80/20200816113530357.png"><br>安装过程中可以改安装路径<br>它会自动给系统添加环境变量  </p></li><li><p>测试<br>cmd中输入<code>npm</code>得到一堆信息，则说明安装成功<br><img src="/Node.js-%E5%9F%BA%E7%A1%80/20200816114606605.png"></p></li><li><p>配置node_cache路径<br>这个文件夹是<code>Node.js</code>用来存放下载包的缓存的地方  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm config <span class="hljs-built_in">set</span> cache <span class="hljs-string">&quot;cache路径&quot;</span><br></code></pre></td></tr></table></figure></li><li><p>设置全局模块存放路径<br>这个文件夹是<code>Node.js</code>用来存放通过全局安装的模块的地方<br><code>Node.js</code>会自动寻找该路径下的<code>node_modules</code>文件夹为实际存放全局模块的路径<br>我一般设置为在Node.js目录  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm config <span class="hljs-built_in">set</span> prefix <span class="hljs-string">&quot;全局模块存放的路径&quot;</span><br></code></pre></td></tr></table></figure><blockquote><p>node_modules文件夹为实际存放全局模块的路径，这也是为啥叫<code>prefix</code>不叫<code>global</code>的原因  </p></blockquote></li><li><p>修改npmrc文件<br>用文本编辑器打开<code>Node.js目录\node_modules\npm\npmrc</code>文件<br>将<code>prefix=$&#123;APPDATA&#125;\npm</code>改为<code>prefix=Node.js根目录</code><br>如果不做这个修改，则在运行<code>npm ls -g</code>的时候，仍然以默认的路径来查找已安装的全局模块  </p></li></ol><h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><h2 id="全局安装"><a href="#全局安装" class="headerlink" title="全局安装"></a>全局安装</h2><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">npm <span class="hljs-keyword">install</span> -g 包名<br></code></pre></td></tr></table></figure><h2 id="全局卸载"><a href="#全局卸载" class="headerlink" title="全局卸载"></a>全局卸载</h2><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> uninstall -g 包名<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>javascript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CentOS-环境变量配置</title>
    <link href="/post/e68da6e/"/>
    <url>/post/e68da6e/</url>
    
    <content type="html"><![CDATA[<h1 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h1><p>为了能在控制台通过命令访问到对应的程序，配置环境变量不可避免  </p><h1 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h1><h2 id="添加环境变量"><a href="#添加环境变量" class="headerlink" title="添加环境变量"></a>添加环境变量</h2><ol><li>进入环境变量文件夹  <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">cd <span class="hljs-regexp">/etc/</span>profile.d<br></code></pre></td></tr></table></figure></li><li>创建环境变量文件  <figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">sudo vim <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Anaconda</span>.</span></span>sh<br></code></pre></td></tr></table></figure></li><li>编写环境变量  <figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-comment"># set Anaconda environment</span><br>PATH=<span class="hljs-variable">$PATH</span><span class="hljs-symbol">:/home/manager/anaconda3/bin</span><br>export PATH<br></code></pre></td></tr></table></figure>注意对应自己的安装路径，写完<code>:wq</code>保存退出  </li><li>打开新的控制台测试  <figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">conda</span><br></code></pre></td></tr></table></figure>看到一堆命令提示就代表成功  </li></ol><h2 id="删除环境变量"><a href="#删除环境变量" class="headerlink" title="删除环境变量"></a>删除环境变量</h2><p>把<code>/etc/profile.d</code>里面对应的<code>.sh文件</code>删除即可</p>]]></content>
    
    
    
    <tags>
      
      <tag>服务器</tag>
      
      <tag>CentOS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>爬虫-无限debugger</title>
    <link href="/post/dd59ce18/"/>
    <url>/post/dd59ce18/</url>
    
    <content type="html"><![CDATA[<h1 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h1><ul><li>实现简单, 效果明显, 一定程度提高安全性  </li><li>反调试，阻止我们调试分析代码的运行逻辑  </li></ul><h1 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h1><p>debugger关键词的嵌套使用  </p><h1 id="应对"><a href="#应对" class="headerlink" title="应对"></a>应对</h1><ul><li>禁用所有断点<br>可以尝试，但并不一定能解决问题，甚至有可能导致死循环吃内存  </li><li>禁用断点语句<br>可以尝试，但并不一定能解决问题，甚至有可能导致死循环吃内存  </li><li>条件断点  </li><li>中间人工具替换字符串  </li><li>reres替换本地修改过的文件<br>本地代理取代对应js资源  </li><li>注入重写关键函数<br>故意进入debug函数<br>观察堆栈调用，最好找到最外层调用函数<br>注入代码再定义函数，使得函数变为空<br>需要注意不要误伤业务逻辑  </li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>爬虫</tag>
      
      <tag>前端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Chrome插件-ToggleJavaScript-禁用或启用JavaScript脚本</title>
    <link href="/post/fac1a65b/"/>
    <url>/post/fac1a65b/</url>
    
    <content type="html"><![CDATA[<h1 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h1><p>这是一个能有禁用或启用JavaScript脚本的浏览器插件<br>谷歌商店：<a href="https://chrome.google.com/webstore/detail/toggle-javascript/cidlcjdalomndpeagkjpnefhljffbnlo?utm_source=chrome-ntp-icon">https://chrome.google.com/webstore/detail/toggle-javascript/cidlcjdalomndpeagkjpnefhljffbnlo?utm_source=chrome-ntp-icon</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Chrome</tag>
      
      <tag>javascript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Chrome插件-EditThisCookie</title>
    <link href="/post/58054d20/"/>
    <url>/post/58054d20/</url>
    
    <content type="html"><![CDATA[<h1 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h1><p>这是一个用于管理Cookie的浏览器插件<br>官网:<a href="http://www.editthiscookie.com/">http://www.editthiscookie.com/</a><br>下载：<a href="https://chrome.google.com/webstore/detail/editthiscookie/fngmhnnpilhplaeedifhccceomclgfbg?utm_source=chrome-ntp-icon">https://chrome.google.com/webstore/detail/editthiscookie/fngmhnnpilhplaeedifhccceomclgfbg?utm_source=chrome-ntp-icon</a>  </p><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h2><p><img src="/Chrome%E6%8F%92%E4%BB%B6-EditThisCookie/20200811024743389.png"><br>修改设置各种值  </p><h2 id="清空该网站所有Cookie"><a href="#清空该网站所有Cookie" class="headerlink" title="清空该网站所有Cookie"></a>清空该网站所有Cookie</h2><p><img src="/Chrome%E6%8F%92%E4%BB%B6-EditThisCookie/20201214030406382.png">  </p><h2 id="导入-导出"><a href="#导入-导出" class="headerlink" title="导入/导出"></a>导入/导出</h2><p>导入导出Cookie到各种地方<br><img src="/Chrome%E6%8F%92%E4%BB%B6-EditThisCookie/20200811025600323.png">  </p>]]></content>
    
    
    
    <tags>
      
      <tag>Chrome</tag>
      
      <tag>EditThisCookie</tag>
      
      <tag>Cookie</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Javascript-加密-混淆</title>
    <link href="/post/876db760/"/>
    <url>/post/876db760/</url>
    
    <content type="html"><![CDATA[<h1 id="为什么要进行JavaScript加密-混淆"><a href="#为什么要进行JavaScript加密-混淆" class="headerlink" title="为什么要进行JavaScript加密/混淆"></a>为什么要进行JavaScript加密/混淆</h1><ul><li>JavaScript 代码运行于客户端<br>不安全，存在被篡改，窃取的可能</li><li>JavaScript 代码是公开的  </li></ul><h1 id="如何对JavaScript进行保护"><a href="#如何对JavaScript进行保护" class="headerlink" title="如何对JavaScript进行保护"></a>如何对JavaScript进行保护</h1><ul><li>代码压缩：去除空格、换行等  </li><li>代码加密：eval、emscripten、WebAssembly等  </li><li>代码混淆：变量混淆、常理混淆、控制流平坦化、调试保护等  </li></ul><h1 id="JavaScript加密实现"><a href="#JavaScript加密实现" class="headerlink" title="JavaScript加密实现"></a>JavaScript加密实现</h1><ul><li><p>eval 加密<br><img src="/Javascript-%E5%8A%A0%E5%AF%86-%E6%B7%B7%E6%B7%86/20200809061141463.png"><br>看似复杂，实际上，只要把参数内容输入到控制台就能得到结果  </p></li><li><p>Emscripten<br>将<code>C</code>/<code>C++</code>代码通过<code>Emscripten</code>编译成<code>asm.js</code>代码，<code>JavaScript</code>调用此代码即实现加密<br><code>asm.js</code>为文本格式</p></li><li><p>WebAssembly<br><img src="/Javascript-%E5%8A%A0%E5%AF%86-%E6%B7%B7%E6%B7%86/20200809062943797.png"><br>和<code>Emscripten</code>类似，但结果是<code>wasm文件</code>，运行更快，所需空间更小<br><code>wasm文件</code>为二进制文件</p></li></ul><h1 id="JavaScript混淆"><a href="#JavaScript混淆" class="headerlink" title="JavaScript混淆"></a>JavaScript混淆</h1><ul><li><p>变量混淆<br>将一些变量名、函数名、之类的变成一些奇怪的字符，让你看着难顶  </p></li><li><p>字符串混淆<br>通过对字符串进行<code>Base64</code>,<code>MD5</code>等转换为一些其它字符，使得你无法直接通过全局搜索关键字找到目标  </p></li><li><p>属性加密<br>很多代码里面都用了很多<code>Object</code>，里面包含了很多的<code>key-value</code>，他可以混淆<code>key-value</code>关系，使得你更难以寻找里面的逻辑  </p></li><li><p>控制流平坦化<br>打乱原本代码的运行流程与调用关系，让你更加难度<br><img src="/Javascript-%E5%8A%A0%E5%AF%86-%E6%B7%B7%E6%B7%86/20200809093259387.png"></p></li><li><p>僵尸代码注入<br>注入无用的代码，让你看起来更难顶  </p></li><li><p>代码压缩<br>去除空格，回车等，代码变为一行，让你更难读  </p></li><li><p>反调试<br>基于浏览器特性，循环<code>debug</code>或定时<code>debug</code>  </p></li><li><p>多态变异<br>代码一旦被调用，原代码就会变成与原来完全不同的代码，但功能保持不变，避免代码被动态分析，调试  </p></li><li><p>锁定域名<br>Javascript必须运行在指定域名的条件下  </p></li><li><p>反格式化<br>在你格式化以后，会有机制使得你运行的时候无法正确运行  </p></li><li><p>特殊编码<br>将Javascript编码成难读的代码</p></li></ul><h2 id="JavaScript混淆-开源项目"><a href="#JavaScript混淆-开源项目" class="headerlink" title="JavaScript混淆  开源项目"></a>JavaScript混淆  开源项目</h2><table><thead><tr><th>开源项目</th><th>地址</th></tr></thead><tbody><tr><td>UglifyJS</td><td><a href="https://github.com/mishoo/UglifyJS">https://github.com/mishoo/UglifyJS</a></td></tr><tr><td>terser</td><td><a href="https://github.com/terser/terser">https://github.com/terser/terser</a></td></tr><tr><td>javascript-obfuscator</td><td><a href="https://github.com/javascript-obfuscator/javascript-obfuscator">https://github.com/javascript-obfuscator/javascript-obfuscator</a></td></tr><tr><td>jsfuck</td><td><a href="https://github.com/aemkei/jsfuck">https://github.com/aemkei/jsfuck</a></td></tr><tr><td>AAencode</td><td><a href="https://github.com/bprayudha/jquery.aaencode">https://github.com/bprayudha/jquery.aaencode</a></td></tr><tr><td>JJEncrypt</td><td><a href="https://github.com/ay86/jEncrypt">https://github.com/ay86/jEncrypt</a></td></tr></tbody></table><h2 id="JavaScript混淆-商业项目"><a href="#JavaScript混淆-商业项目" class="headerlink" title="JavaScript混淆  商业项目"></a>JavaScript混淆  商业项目</h2><p><a href="https://www.javascriptobfuscator.com/">https://www.javascriptobfuscator.com/</a><br><a href="https://jscrambler.com/">https://jscrambler.com/</a><br><a href="http://stunnix.com/">http://stunnix.com/</a>  </p><h1 id="处理"><a href="#处理" class="headerlink" title="处理"></a>处理</h1><h2 id="加密分析流程"><a href="#加密分析流程" class="headerlink" title="加密分析流程"></a>加密分析流程</h2><ol><li>查看关键包  分析参数</li><li>参数 <ul><li>搜索参数<br>（参数名=）（参数名 =）（参数名:）（参数名 :）（参数名）  </li><li>查看网络面板Initiator</li><li>xhr断点调试</li><li>hook相关逻辑</li></ul></li><li>分析加密  </li><li>补全加密逻辑  </li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>反爬虫</tag>
      
      <tag>Javascript</tag>
      
      <tag>加密</tag>
      
      <tag>混淆</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>协程-进程-线程</title>
    <link href="/post/28d2e22a/"/>
    <url>/post/28d2e22a/</url>
    
    <content type="html"><![CDATA[<h1 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h1><p><img src="/%E5%8D%8F%E7%A8%8B-%E8%BF%9B%E7%A8%8B-%E7%BA%BF%E7%A8%8B/20200808082113587.png">  </p><h2 id="进程是什么"><a href="#进程是什么" class="headerlink" title="进程是什么"></a>进程是什么</h2><p>进程就是应用程序的启动实例<br>比如我们运行一个游戏，打开一个软件，就是开启了一个进程<br>进程拥有代码和打开的文件资源、数据资源、独立的内存空间  </p><h2 id="线程是什么"><a href="#线程是什么" class="headerlink" title="线程是什么"></a>线程是什么</h2><p>线程从属于进程，是程序的实际执行者<br>一个进程至少包含一个主线程，也可以有更多的子线程<br>线程拥有自己的栈空间<br>线程会在不同状态中不断转化<br><img src="/%E5%8D%8F%E7%A8%8B-%E8%BF%9B%E7%A8%8B-%E7%BA%BF%E7%A8%8B/20200808084316757.png"><br>线程不同状态之间的转化由操作系统内核中的TCB（Thread Control Block）模块实现，这一过程需要耗费一定的CPU资源  </p><h2 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h2><p>对操作系统来说，线程是最小的执行单元，进程是最小的资源管理单元<br>无论进程还是线程，都是由操作系统所管理的  </p><h3 id="痛点"><a href="#痛点" class="headerlink" title="痛点"></a>痛点</h3><ul><li>多个线程共同运作时，为了不出现问题，通常要同步加锁  </li><li>线程在 阻塞状态 和 可运行状态 之间切换需要CPU资源  </li><li>线程 上下文切换（指记录程序执行到何处）需要CPU资源  </li></ul><h2 id="什么是协程"><a href="#什么是协程" class="headerlink" title="什么是协程"></a>什么是协程</h2><p>协程是一种比线程更加轻量级的存在<br>正如一个进程可以拥有多个线程一样，一个线程也可以拥有多个协程<br><img src="/%E5%8D%8F%E7%A8%8B-%E8%BF%9B%E7%A8%8B-%E7%BA%BF%E7%A8%8B/20200808110953807.png"><br>最重要的是，协程不是被操作系统内核所管理，而完全是由程序所控制<br>这样带来的好处就是性能得到了很大的提升，不会像线程切换那样消耗资源。因此，协程的开销远远小于线程的开销。  </p><h3 id="优缺"><a href="#优缺" class="headerlink" title="优缺"></a>优缺</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>提高性能<br>相对于线程。无需线程上下文切换的开销，协程避免了无意义的调度，由此可以提高性能（但也因此，程序员必须自己承担调度的责任，同时，协程也失去了标准线程使用多CPU的能力）  </li><li>无需原子操作锁定及同步的开销  </li><li>方便切换控制流，简化编程模型  </li><li>高并发+高扩展性+低成本<br>一个CPU支持上万的协程都不是问题。所以很适合用于高并发处理。</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>无法利用多核资源<br>协程的本质是个单线程,它不能同时将 单个CPU 的多个核用上。<br>协程需要和进程配合才能运行在多CPU上。当然日常所编写的绝大部分应用都没有这个必要，除非是cpu密集型应用  </li><li>进行阻塞（Blocking）操作（如IO时）会阻塞掉整个程序  </li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>协程</tag>
      
      <tag>进程</tag>
      
      <tag>线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mitmproxy</title>
    <link href="/post/9d9c1fd2/"/>
    <url>/post/9d9c1fd2/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>顾名思义，mitmproxy 就是用于 MITM 的 proxy，MITM 即中间人攻击（Man-in-the-middle attack）。用于中间人攻击的代理首先会向正常的代理一样转发请求，保障服务端与客户端的通信，其次，会适时的查、记录其截获的数据，或篡改数据，引发服务端或客户端特定的行为  </p><p>不同于 fiddler 或 wireshark 等抓包工具，mitmproxy 不仅可以截获请求帮助开发者查看、分析，更可以通过自定义脚本进行二次开发。举例来说，利用 fiddler 可以过滤出浏览器对某个特定 url 的请求，并查看、分析其数据，但实现不了高度定制化的需求，类似于：“截获对浏览器对该 url 的请求，将返回内容置空，并将真实的返回内容存到某个数据库，出现异常时发出邮件通知”。而对于 mitmproxy，这样的需求可以通过载入自定义 python 脚本轻松实现  </p><p>mitmproxy 工作在 HTTP 层， HTTPS 的普及让客户端拥有了检测并规避中间人攻击的能力，所以要让 mitmproxy 能够正常工作，必须要让客户端（APP 或浏览器）主动信任 mitmproxy 的 SSL 证书，或忽略证书异常  </p><p>利用手机模拟器、无头浏览器来爬取 APP 或网站的数据，mitmpproxy 作为代理可以拦截、存储爬虫获取到的数据，或修改数据调整爬虫的行为  </p><h1 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h1><table><thead><tr><th>信息</th><th>链接</th></tr></thead><tbody><tr><td>官网</td><td><a href="https://mitmproxy.org/">https://mitmproxy.org/</a></td></tr><tr><td>文档</td><td><a href="https://docs.mitmproxy.org/stable/">https://docs.mitmproxy.org/stable/</a></td></tr><tr><td>Github</td><td><a href="https://github.com/mitmproxy/mitmproxy">https://github.com/mitmproxy/mitmproxy</a></td></tr><tr><td>DockerHub</td><td><a href="https://hub.docker.com/r/mitmproxy/mitmproxy/">https://hub.docker.com/r/mitmproxy/mitmproxy/</a></td></tr></tbody></table><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h2 id="安装程序"><a href="#安装程序" class="headerlink" title="安装程序"></a>安装程序</h2><p><img src="/mitmproxy/20200806041304952.png"><br>官网首页将安装包下载下来，选择一个地方安装好  </p><h2 id="安装证书"><a href="#安装证书" class="headerlink" title="安装证书"></a>安装证书</h2><h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><p>在用户目录下找到<code>mitmproxy</code>证书进行安装<br>一般会在<code>C:\Users\Administrator\.mitmproxy</code>文件夹中<br>证书名为<code>mitmproxy-ca.p12</code>，双击开始安装<br><img src="/mitmproxy/20200806041748503.png"><br>一路下一步，到这里，选择<code>受信任的根证书颁发机构</code><br>最后会弹出警告，选是即可  </p><h3 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h3><p>操作与上述似，但证书文件是<code>mitmproxy-ca-cert.pem</code>  </p><h2 id="python库安装"><a href="#python库安装" class="headerlink" title="python库安装"></a>python库安装</h2><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">pip <span class="hljs-keyword">install</span> mitmproxy<br></code></pre></td></tr></table></figure><h2 id="使用代理以验证安装"><a href="#使用代理以验证安装" class="headerlink" title="使用代理以验证安装"></a>使用代理以验证安装</h2><p><code>cmd</code>中输入<code>mitmweb</code>以启用<code>mitmweb</code><br><img src="/mitmproxy/20200806064021137.png"><br>启用后会提示 web运行信息 和 代理信息<br>将代理信息记录下来，设置到 浏览器代理 或者 系统代理之中  </p><p>若是使用<code>Chrome</code>浏览器，推荐使用插件<code>SwitchyOmega</code>来管理代理<br><a href="https://github.com/FelisCatus/SwitchyOmega">https://github.com/FelisCatus/SwitchyOmega</a><br><img src="/mitmproxy/20200806064603862.png"><br>进行设置以后，请求/响应都会通过代理进行，在不使用代理时注意关闭<br><img src="/mitmproxy/20200806064950822.png"><br>最终会抓到一些包，显示在控制台上  </p><h1 id="插件-Addons"><a href="#插件-Addons" class="headerlink" title="插件  Addons"></a>插件  Addons</h1><p><code>Mitmproxy</code>的<code>Addons</code>机制由一组API组成<br><code>Addons</code>通过响应事件与<code>mitmproxy</code>进行交互，从而使它们能够参与并改变<code>mitmproxy</code>的行为<br><code>Addons</code>是通过<a href="https://docs.mitmproxy.org/stable/concepts-options/">Option</a>配置的，这些选项可以在<code>mitmproxy</code>的配置文件中设置，也可以由用户交互地更改或通过命令行进行修改<br><code>Addons</code>是<code>mitmproxy</code>的重要组成部分，实际上很多<code>mitmproxy</code>自身的函数都是被定义在 一套<code>Addons</code> 中的<br><code>Mitmproxy</code>为第三方脚本编写程序和扩展程序提供了一套完全相同的工具来实现它自己的功能  </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">pydoc</span> <span class="hljs-selector-tag">mitmproxy</span><span class="hljs-selector-class">.http</span><br></code></pre></td></tr></table></figure><p>你可以通过这个命令来查阅API文档  </p><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">一个简单的 mitmproxy addon.</span><br><span class="hljs-string">你可以通过这个命令运行: mitmproxy -s anatomy.py</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-keyword">from</span> mitmproxy <span class="hljs-keyword">import</span> ctx<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Counter</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        self.num = <span class="hljs-number">0</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">request</span>(<span class="hljs-params">self, flow</span>):</span><br>        self.num = self.num + <span class="hljs-number">1</span><br>        ctx.log.info(<span class="hljs-string">&quot;We&#x27;ve seen %d flows&quot;</span> % self.num)<br><br>addons = [<br>    Counter()<br>]<br></code></pre></td></tr></table></figure><p>这是个简单的案例，每当发送新的请求，都会在控制台输出文字  </p><h1 id="事件-Events"><a href="#事件-Events" class="headerlink" title="事件 Events"></a>事件 Events</h1><p><code>Addons</code>通过<code>Events</code>与mitmproxy的内部机制挂钩<br>许多<code>Events</code>接收<code>Flow</code>对象作为参数，通过修改这些参数，<code>Addons</code>能改变包的信息  </p><h2 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;例子：为每一个响应添加一个统计数量的响应头&quot;&quot;&quot;</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AddHeader</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        self.num = <span class="hljs-number">0</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">response</span>(<span class="hljs-params">self, flow</span>):</span><br>        self.num = self.num + <span class="hljs-number">1</span><br>        flow.response.headers[<span class="hljs-string">&quot;count&quot;</span>] = <span class="hljs-built_in">str</span>(self.num)<br><br>addons = [<br>    AddHeader()<br>]<br></code></pre></td></tr></table></figure><p>所支持的所有<code>Events</code>：<a href="https://docs.mitmproxy.org/stable/addons-events/">https://docs.mitmproxy.org/stable/addons-events/</a>  </p><h1 id="选项-Options"><a href="#选项-Options" class="headerlink" title="选项 Options"></a>选项 Options</h1><p><code>Mitmproxy</code>核心的全局设置存储，包含了决定<code>Mitmproxy</code>及其插件行为的设置<br><code>Options</code>会从配置文件中读取，你可以通过命令行来动态改变它  </p><p>所有<code>Options</code>都使用一组受支持的类型进行。<code>Mitmproxy</code>知道如何序列化和反序列化这些类型。强行设置不合适的值会导致错误   </p><h2 id="案例-2"><a href="#案例-2" class="headerlink" title="案例"></a>案例</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">添加一个新的 mitmproxy option</span><br><span class="hljs-string">启动命令: mitmproxy -s 4_options.py --set addheader true</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-keyword">from</span> mitmproxy <span class="hljs-keyword">import</span> ctx<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AddHeader</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        self.num = <span class="hljs-number">0</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">load</span>(<span class="hljs-params">self, loader</span>):</span><br>        loader.add_option(<br>            name = <span class="hljs-string">&quot;addheader&quot;</span>,<br>            typespec = <span class="hljs-built_in">bool</span>,<br>            default = <span class="hljs-literal">False</span>,<br>            <span class="hljs-built_in">help</span> = <span class="hljs-string">&quot;Add a count header to responses&quot;</span>,<br>        )<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">response</span>(<span class="hljs-params">self, flow</span>):</span><br>        <span class="hljs-keyword">if</span> ctx.options.addheader:<br>            self.num = self.num + <span class="hljs-number">1</span><br>            flow.response.headers[<span class="hljs-string">&quot;count&quot;</span>] = <span class="hljs-built_in">str</span>(self.num)<br>addons = [<br>    AddHeader()<br>]<br></code></pre></td></tr></table></figure><p><code>load</code> <code>Event</code>会接收一个可以声明<code>Option</code>和命令的<code>mitmproxy.addonmanager.Loader</code>对象。这个<code>Addon</code>添加了一个<code>bool</code>类型的<code>addheader</code> <code>Option</code><br>在命令行里运行脚本  </p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">mitmproxy -s 4_options.py --<span class="hljs-builtin-name">set</span> addheader <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>通过代理访问一下网站，就能够在命令行看到一些信息<br>如果你观察包，你会发现<code>HTTP headers</code>并没有<code>addheader</code>项。这是因为<code>add_option</code>的默认值为<code>false</code>它并不会启动<br>按<code>O</code>进入<code>options</code>编辑器，找到<code>addheader</code>项并将它改为<code>true</code>，你就会看到添加了计数项的响应头部  </p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">HTTP</span>/<span class="hljs-number">1</span>.<span class="hljs-number">1</span> <span class="hljs-number">301</span> Moved Permanently<br><span class="hljs-attribute">Location</span>: http://www.google.com/<br><span class="hljs-attribute">Content</span>-Length: <span class="hljs-number">219</span><br><span class="hljs-attribute">count</span>: <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>在加载这个<code>Addon</code>的时候，<code>addheader</code>的设置会保存在 <a href="https://docs.mitmproxy.org/stable/concepts-options/">设置文件YAML</a>里<br>你也可以在运行命令的时候用<code>--set</code>参数来设置<code>options</code>  </p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle">mitmproxy -s .<span class="hljs-regexp">/examples/</span>addons/<span class="hljs-keyword">options</span>-simple.py --set addheader=<span class="hljs-keyword">true</span><br></code></pre></td></tr></table></figure><h2 id="配置更新"><a href="#配置更新" class="headerlink" title="配置更新"></a>配置更新</h2><p><code>configure</code> <code>event</code>能在<code>option</code>更变的时候立即做一些响应<br>当<code>option</code>发生变更，<code>configure</code> <code>event</code> 会被被触发。它会收到一组被更变的<code>options</code>的<code>set</code>，<code>Addon</code>可以检查<code>option</code>是否在<code>set</code>里，然后根据上下文的<code>option</code>对象里获取值并作出一些响应<br>这功能最常见的用法是用来检查<code>option</code>是否有效，若无效，则进行记录（反馈）  </p><h3 id="案例-3"><a href="#案例-3" class="headerlink" title="案例"></a>案例</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;React to configuration changes.&quot;&quot;&quot;</span><br><span class="hljs-keyword">import</span> typing<br><span class="hljs-keyword">from</span> mitmproxy <span class="hljs-keyword">import</span> ctx<br><span class="hljs-keyword">from</span> mitmproxy <span class="hljs-keyword">import</span> exceptions<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AddHeader</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">load</span>(<span class="hljs-params">self, loader</span>):</span><br>        loader.add_option(<br>            name = <span class="hljs-string">&quot;addheader&quot;</span>,<br>            typespec = typing.Optional[<span class="hljs-built_in">int</span>],<br>            default = <span class="hljs-literal">None</span>,<br>            <span class="hljs-built_in">help</span> = <span class="hljs-string">&quot;Add a header to responses&quot;</span>,<br>        )<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">configure</span>(<span class="hljs-params">self, updates</span>):</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;addheader&quot;</span> <span class="hljs-keyword">in</span> updates:<br>            <span class="hljs-keyword">if</span> ctx.options.addheader <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> ctx.options.addheader &gt; <span class="hljs-number">100</span>:<br>                <span class="hljs-keyword">raise</span> exceptions.OptionsError(<span class="hljs-string">&quot;addheader must be &lt;= 100&quot;</span>)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">response</span>(<span class="hljs-params">self, flow</span>):</span><br>        <span class="hljs-keyword">if</span> ctx.options.addheader <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            flow.response.headers[<span class="hljs-string">&quot;addheader&quot;</span>] = <span class="hljs-built_in">str</span>(ctx.options.addheader)<br><br><br>addons = [<br>    AddHeader()<br>]<br></code></pre></td></tr></table></figure><p>在你设置一个不符合规定的<code>addheader</code>值时，<code>configure</code> <code>event</code>会给你反馈信息  </p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gradle">mitmdump -s .<span class="hljs-regexp">/examples/</span>addons/<span class="hljs-keyword">options</span>-configure.py --set addheader=<span class="hljs-number">1000</span><br>Loading script: .<span class="hljs-regexp">/examples/</span>addons/<span class="hljs-keyword">options</span>-configure.py<br><span class="hljs-regexp">/Users/</span>cortesi<span class="hljs-regexp">/mitmproxy/mi</span>tmproxy<span class="hljs-regexp">/venv/</span>bin/mitmdump: addheader must be &lt;= <span class="hljs-number">100</span><br></code></pre></td></tr></table></figure><h2 id="options支持的数据类型"><a href="#options支持的数据类型" class="headerlink" title="options支持的数据类型"></a>options支持的数据类型</h2><p><code>str</code>, <code>int</code>, <code>float</code>, <code>bool</code>, <code>typing.Optional</code>, <code>typing.Sequence</code></p><h1 id="命令-Commands"><a href="#命令-Commands" class="headerlink" title="命令 Commands"></a>命令 Commands</h1><p><code>Commands</code>允许用户与插件进行主动交互-查询其状态，命令他们执行操作以或者让它们转换数据。<br><code>Commands</code>是一个非常强大的结构，<code>mitmproxy</code>控制台中的所有用户交互都是通过将命令绑定到<code>keys</code>来构建的</p><h2 id="案例1"><a href="#案例1" class="headerlink" title="案例1"></a>案例1</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;添加一个用户自定义Commands&quot;&quot;&quot;</span><br><span class="hljs-keyword">from</span> mitmproxy <span class="hljs-keyword">import</span> command<br><span class="hljs-keyword">from</span> mitmproxy <span class="hljs-keyword">import</span> ctx<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyAddon</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        self.num = <span class="hljs-number">0</span><br><br><span class="hljs-meta">    @command.command(<span class="hljs-params"><span class="hljs-string">&quot;myaddon.inc&quot;</span></span>)</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">inc</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        self.num += <span class="hljs-number">1</span><br>        ctx.log.info(<span class="hljs-string">f&quot;num = <span class="hljs-subst">&#123;self.num&#125;</span>&quot;</span>)<br><br><br>addons = [<br>    MyAddon()<br>]<br></code></pre></td></tr></table></figure><p>运行脚本代码</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coq">mitmproxy -s commands-<span class="hljs-built_in">simple</span>.py<br></code></pre></td></tr></table></figure><p>输入自己设置的命令即可得到结果</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clojure"><span class="hljs-symbol">:myaddon.inc</span><br></code></pre></td></tr></table></figure><p>注意：</p><ul><li>命令应该是唯一的，不要弄重复  </li><li>你只能运用那些<code>option</code>里能用的变量类型(包括返回值)</li></ul><h2 id="案例2-与flows配合使用"><a href="#案例2-与flows配合使用" class="headerlink" title="案例2 与flows配合使用"></a>案例2 与flows配合使用</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> typing<br><span class="hljs-keyword">from</span> mitmproxy <span class="hljs-keyword">import</span> command<br><span class="hljs-keyword">from</span> mitmproxy <span class="hljs-keyword">import</span> ctx<br><span class="hljs-keyword">from</span> mitmproxy <span class="hljs-keyword">import</span> flow<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyAddon</span>:</span><br><span class="hljs-meta">    @command.command(<span class="hljs-params"><span class="hljs-string">&quot;myaddon.addheader&quot;</span></span>)</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">addheader</span>(<span class="hljs-params">self, flows: typing.Sequence[flow.Flow]</span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        <span class="hljs-keyword">for</span> f <span class="hljs-keyword">in</span> flows:<br>            f.request.headers[<span class="hljs-string">&quot;myheader&quot;</span>] = <span class="hljs-string">&quot;value&quot;</span><br>        ctx.log.alert(<span class="hljs-string">&quot;done&quot;</span>)<br><br>addons = [<br>    MyAddon()<br>]<br></code></pre></td></tr></table></figure><p><code>myaddon.addheader</code>命令十分简单，它获取一系列的<code>flows</code>被为请求添加一个头部参数<br>这个案例真正有趣的地方是用户如何指定<code>flows</code>。<code>mitmproxy</code>可以检查类型信息，这意味着你能通过类型信息来设置一些过滤条件，增加灵活性<br>启动脚本</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">mitmproxy -s .<span class="hljs-regexp">/examples/</span>addons/commands-flows.py<br></code></pre></td></tr></table></figure><p>尝试不同的参数<br>只对<code>@focus</code>的<code>flows</code>执行<code>addheader</code></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-pseudo">:myaddon.addheader</span> <span class="hljs-keyword">@focus</span><br></code></pre></td></tr></table></figure><p>对所有的<code>flows</code>执行<code>addheader</code></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-pseudo">:myaddon.addheader</span> <span class="hljs-keyword">@all</span><br></code></pre></td></tr></table></figure><p>只对来自 google.com 的<code>flows</code>执行<code>addheader</code></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-pseudo">:myaddon.addheader</span> ~<span class="hljs-selector-tag">d</span> <span class="hljs-selector-tag">google</span><span class="hljs-selector-class">.com</span><br></code></pre></td></tr></table></figure><h2 id="案例3-路径类型-paths"><a href="#案例3-路径类型-paths" class="headerlink" title="案例3 路径类型 paths"></a>案例3 路径类型 paths</h2><p>命令可以带有任意数量的参数，演示一种特殊类型：<code>paths</code>  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;将文件路径作为命令参数处理&quot;&quot;&quot;</span><br><span class="hljs-keyword">import</span> typing<br><br><span class="hljs-keyword">from</span> mitmproxy <span class="hljs-keyword">import</span> command<br><span class="hljs-keyword">from</span> mitmproxy <span class="hljs-keyword">import</span> ctx<br><span class="hljs-keyword">from</span> mitmproxy <span class="hljs-keyword">import</span> flow<br><span class="hljs-keyword">from</span> mitmproxy <span class="hljs-keyword">import</span> types<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyAddon</span>:</span><br><span class="hljs-meta">    @command.command(<span class="hljs-params"><span class="hljs-string">&quot;myaddon.histogram&quot;</span></span>)</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">histogram</span>(<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">        self,</span></span><br><span class="hljs-function"><span class="hljs-params">        flows: typing.Sequence[flow.Flow],</span></span><br><span class="hljs-function"><span class="hljs-params">        path: types.Path,</span></span><br><span class="hljs-function"><span class="hljs-params">    </span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        totals = &#123;&#125;<br>        <span class="hljs-keyword">for</span> f <span class="hljs-keyword">in</span> flows:<br>            totals[f.request.host] = totals.setdefault(f.request.host, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span><br><br>        <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(path, <span class="hljs-string">&quot;w+&quot;</span>) <span class="hljs-keyword">as</span> fp:<br>            <span class="hljs-keyword">for</span> cnt, dom <span class="hljs-keyword">in</span> <span class="hljs-built_in">sorted</span>([(v, k) <span class="hljs-keyword">for</span> (k, v) <span class="hljs-keyword">in</span> totals.items()]):<br>                fp.write(<span class="hljs-string">&quot;%s: %s\n&quot;</span> % (cnt, dom))<br><br>        ctx.log.alert(<span class="hljs-string">&quot;done&quot;</span>)<br><br><br>addons = [<br>    MyAddon()<br>]<br></code></pre></td></tr></table></figure><p>命令的路径参数会作为第二参数来传入，你可以用类似于这种方式来使用它  </p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">:myaddon.histogram @all <span class="hljs-regexp">/tmp/</span>xxx<br></code></pre></td></tr></table></figure><h2 id="支持的类型"><a href="#支持的类型" class="headerlink" title="支持的类型"></a>支持的类型</h2><ul><li>Primitive types: <code>str</code>, <code>int</code>, <code>bool</code>  </li><li>Sequences: <code>typing.Sequence[str]</code>  </li><li>Flows and flow sequences: <code>flow.Flow</code> and <code>typing.Sequence[flow.Flow]</code>  </li><li>Multiple choice strings: <code>types.Choice</code>  </li><li>Meta-types: <code>types.Command</code> and <code>types.Arg</code>. These are for constructing commands that invoke other commands. This is most commonly useful in keybinding - see the built-in mitmproxy console keybindings for a rich suite of examples  </li><li>Data types: <code>types.CutSpec</code> and <code>types.Data</code>. The cuts mechanism is in alpha at the moment, and provides a convenient way to snip up flow data  </li><li>Path: <code>types.Path</code></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>mitmproxy</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RESTful架构</title>
    <link href="/post/2654e413/"/>
    <url>/post/2654e413/</url>
    
    <content type="html"><![CDATA[<h1 id="起源"><a href="#起源" class="headerlink" title="起源"></a>起源</h1><p><code>REST</code>这个词，是<code>Roy Thomas Fielding</code>在他2000年的博士论文中提出的  </p><blockquote><p>Fielding，HTTP协议（1.0版和1.1版）的主要设计者、Apache服务器软件的作者之一、Apache基金会的第一任主席  </p></blockquote><h1 id="REST"><a href="#REST" class="headerlink" title="REST"></a>REST</h1><p>Fielding将他对互联网软件的架构原则，定名为REST，即<code>Representational State Transfer</code>的缩写<br>如果一个架构符合REST原则，就称它为RESTful架构  </p><p>REST的名称”表现层状态转化”中，省略了主语。”表现层”其实指的是”资源”（Resources）的”表现层”。</p><h2 id="资源-Resources"><a href="#资源-Resources" class="headerlink" title="资源 Resources"></a>资源 Resources</h2><p>所谓”资源”，就是网络上的一个实体，或者说是网络上的一个具体信息。它可以是一段文本、一张图片、一首歌曲、一种服务，总之就是一个具体的实在<br>你可以用一个URI（统一资源定位符）指向它，每种资源对应一个特定的URI。要获取这个资源，访问它的URI就可以，因此URI就成了每一个资源的地址或独一无二的识别符  </p><h2 id="表现层-Representation"><a href="#表现层-Representation" class="headerlink" title="表现层 Representation"></a>表现层 Representation</h2><p>“资源”是一种信息实体，它可以有多种外在表现形式<br>我们把”资源”具体呈现出来的形式，叫做它的”表现层”（Representation）  </p><p>比如，文本可以用txt格式表现，也可以用HTML格式、XML格式、JSON格式表现，甚至可以采用二进制格式；图片可以用JPG格式表现，也可以用PNG格式表现  </p><p>URI只代表资源的实体，不代表它的形式。严格地说，有些网址最后的”.html”后缀名是不必要的，因为这个后缀名表示格式，属于”表现层”范畴，而URI应该只代表”资源”的位置。它的具体表现形式，应该在HTTP请求的头信息中用Accept和Content-Type字段指定，这两个字段才是对”表现层”的描述  </p><h2 id="状态转化（State-Transfer）"><a href="#状态转化（State-Transfer）" class="headerlink" title="状态转化（State Transfer）"></a>状态转化（State Transfer）</h2><p>访问一个网站，就代表了客户端和服务器的一个互动过程。在这个过程中，势必涉及到数据和状态的变化<br>互联网通信协议HTTP协议，是一个无状态协议<br>这意味着，所有的状态都保存在服务器端。因此，如果客户端想要操作服务器，必须通过某种手段，让服务器端发生”状态转化”（State Transfer）。而这种转化是建立在表现层之上的，所以就是”表现层状态转化”<br>客户端用到的手段，只能是HTTP协议<br>具体来说，就是HTTP协议里面，四个表示操作方式的动词：GET、POST、PUT、DELETE。它们分别对应四种基本操作：GET用来获取资源，POST用来新建资源（也可以用于更新资源），PUT用来更新资源，DELETE用来删除资源  </p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>综合上面的解释，我们总结一下什么是RESTful架构：  </p><ol><li>每一个URI代表一种资源  </li><li>客户端和服务器之间，传递这种资源的某种表现层  </li><li>客户端通过四个HTTP动词，对服务器端资源进行操作，实现”表现层状态转化”  </li></ol><h1 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h1><h2 id="C-S架构"><a href="#C-S架构" class="headerlink" title="C-S架构"></a>C-S架构</h2><p>数据的存储在Server端，Client端只需使用就行。两端彻底分离的好处使client端代码的可移植性变强，Server端的拓展性变强。两端单独开发，互不干扰  </p><h2 id="无状态"><a href="#无状态" class="headerlink" title="无状态"></a>无状态</h2><p>http请求本身就是无状态的，基于C-S架构，客户端的每一次请求带有充分的信息能够让服务端识别<br>请求所需的一些信息都包含在URL的查询参数、header、div，服务端能够根据请求的各种参数，无需保存客户端的状态，将响应正确返回给客户端。无状态的特征大大提高的服务端的健壮性和可拓展性  </p><p>当然，这种无状态性的约束也是有缺点的，客户端的每一次请求都必须带上相同重复的信息确定自己的身份和状态，造成传输数据的冗余性，但这种确定对于性能和使用来说，几乎是忽略不计的  </p><h2 id="统一的接口"><a href="#统一的接口" class="headerlink" title="统一的接口"></a>统一的接口</h2><p>REST架构的核心内容，统一的接口对于RESTful服务非常重要。客户端只需要关注实现接口就可以，接口的可读性加强，使用人员方便调用  </p><p>REST接口约束定义为：资源识别; 请求动作; 响应信息; 它表示通过uri标出你要操作的资源，通过请求动作（http method）标识要执行的操作，通过返回的状态码来表示这次请求的执行结果  </p><h2 id="一致的数据格式"><a href="#一致的数据格式" class="headerlink" title="一致的数据格式"></a>一致的数据格式</h2><p>服务端返回的数据格式要么是XML，要么是Json（获取数据），或者直接返回状态码，一些知名网站的开放平台的操作数据的api，post、put、patch都是返回的一个状态码  </p><p>如请求一条微博信息，服务端响应信息应该包含这条微博相关的其他URL，客户端可以进一步利用这些URL发起请求获取感兴趣的信息，再如分页可以从第一页的返回数据中获取下一页的URT也是基于这个原理  </p><h2 id="可缓存"><a href="#可缓存" class="headerlink" title="可缓存"></a>可缓存</h2><p>在万维网上，客户端可以缓存页面的响应内容。因此响应都应隐式或显式的定义为可缓存的，若不可缓存则要避免客户端在多次请求后用旧数据或脏数据来响应<br>管理得当的缓存会部分地或完全地除去客户端和服务端之间的交互，进一步改善性能和延展性  </p><h2 id="按需编码、可定制代码"><a href="#按需编码、可定制代码" class="headerlink" title="按需编码、可定制代码"></a>按需编码、可定制代码</h2><p>服务端可选择临时给客户端下发一些功能代码让客户端来执行，从而定制和扩展客户端的某些功能<br>比如服务端可以返回一些 Javascript 代码让客户端执行，去实现某些特定的功能。</p><blockquote><p>提示：REST架构中的设计准则中，只有按需编码为可选项。如果某个服务违反了其他任意一项准则，严格意思上不能称之为RESTful风格。</p></blockquote><h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><h2 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h2><p>如github开放平台的API：<a href="http://developer.github.com/v3/">http://developer.github.com/v3/</a><br>可以发现，一般的项目加版本v1，v2，v3版本号，为的是兼容一些老版本的接口，这个加版本估计只有大公司大项目才会去使用  </p><h2 id="参数命名规范"><a href="#参数命名规范" class="headerlink" title="参数命名规范"></a>参数命名规范</h2><p>query parameter可以采用驼峰命名法，也可以采用下划线命名的方式，后者比前者的识别度要高<br>其中，做前端开发基本都后后者，而做服务器接口开发基本用前者  </p><h2 id="url命名规范"><a href="#url命名规范" class="headerlink" title="url命名规范"></a>url命名规范</h2><p><code>API</code>命名应该采用约定俗成的方式，保持简洁明了<br>在RESTful架构中，每个url代表一种资源，所以url中不能有动词，只能有名词，并且名词中也应该使用复数<br>实现者应使用相应的Http动词GET、POST、PUT、PATCH、DELETE、HEAD来操作这些资源  </p><h2 id="统一返回数据格式"><a href="#统一返回数据格式" class="headerlink" title="统一返回数据格式"></a>统一返回数据格式</h2><p>对于合法的请求应该返回统一的数据格式，对于返回数据，通常会包含如下字段  </p><ul><li>code<br>包含一个整数类型的HTTP响应状态码  </li><li>status<br>包含文本：”success”，”fail”或”error”。</li><li>HTTP状态响应码<br>在500-599之间为”fail”，在400-499之间为”error”，其它均为”success”（例如：响应状态码为1XX、2XX和3XX）。这个根据实际情况其实是可要可不要的   </li><li>message<br>当状态值为”fail”和”error”时有效，用于显示错误信息。参照国际化（il8n）标准，它可以包含信息号或者编码，可以只包含其中一个，或者同时包含并用分隔符隔开  </li><li>data<br>包含响应的div。当状态值为”fail”或”error”时，data仅包含错误原因或异常名称、或者null也是可以的  </li></ul><hr><p>参考：</p><ul><li><a href="http://www.ruanyifeng.com/blog/2011/09/restful.html">http://www.ruanyifeng.com/blog/2011/09/restful.html</a></li><li><a href="https://zhuanlan.zhihu.com/p/91240556">https://zhuanlan.zhihu.com/p/91240556</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>RESTful</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>爬虫-基础</title>
    <link href="/post/5c0a4593/"/>
    <url>/post/5c0a4593/</url>
    
    <content type="html"><![CDATA[<h1 id="HTML-DOM"><a href="#HTML-DOM" class="headerlink" title="HTML DOM"></a>HTML DOM</h1><p>文档对象模型  中立于平台和语言的接口<br>允许程序动态地更新文档内容，结构和样式  </p><blockquote><p>js代码和css样式可以改变 HTML，但只是改变显示样式，并没有真正改变HTML文档本身  </p></blockquote><h1 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h1><h2 id="页面渲染流程"><a href="#页面渲染流程" class="headerlink" title="页面渲染流程"></a>页面渲染流程</h2><p><img src="/%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80/20200807060538670.png"><br><img src="/%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80/20200807061040811.png"><br>因为其它工具里没有js解释器，CSS解释器，所以可以通过这两个东西来进行反爬虫  </p><h2 id="浏览器缓存"><a href="#浏览器缓存" class="headerlink" title="浏览器缓存"></a>浏览器缓存</h2><ul><li>Cookies<br>用于服务端通信，存储量小  </li><li>Local Storage<br>存储量比Cookies大一些，只能存字符串  </li><li>Session Storage<br>只存在于当前Session,关闭浏览器就丢失  </li><li>IndexedDB<br>相当于浏览器上的SQL数据库，存储空间大，API较难掌握</li></ul><h1 id="HTTP与HTTPS"><a href="#HTTP与HTTPS" class="headerlink" title="HTTP与HTTPS"></a>HTTP与HTTPS</h1><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><p>Hyper Text Transfer Protocol<br>超文本传输协议，用于从网络传输超文本数据到本地浏览器的传送协议，能保证高效而准确的传送超文本文档（通常是网页html文件）  </p><h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><p>Hyper Text Transfer Protocol over Secure Socket Layer<br>以安全为目标的HTTP通道，即是在HTTP下加入SSL层，简称为HTTPS<br>简单来说就是更安全的HTTP</p><h1 id="请求"><a href="#请求" class="headerlink" title="请求"></a>请求</h1><p>请求一般分为四个部分：请求方法，请求url，请求头，请求体</p><h2 id="请求方法"><a href="#请求方法" class="headerlink" title="请求方法"></a>请求方法</h2><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>GET</td><td>请求指定的页面信息，并返回实体主体</td></tr><tr><td>POST</td><td>向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。<BR>POST 请求可能会导致新的资源的建立和/或已有资源的修改</td></tr><tr><td>HEAD</td><td>类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头</td></tr><tr><td>PUT</td><td>从客户端向服务器传送的数据取代指定的文档的内容</td></tr><tr><td>DELETE</td><td>从客户端向服务器传送的数据取代指定的文档的内容</td></tr><tr><td>CONNECT</td><td>HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器</td></tr><tr><td>OPTIONS</td><td>允许客户端查看服务器的性能</td></tr><tr><td>TRACE</td><td>回显服务器收到的请求，主要用于测试或诊断</td></tr><tr><td>PATCH</td><td>是对 PUT 方法的补充，用来对已知资源进行局部更新</td></tr></tbody></table><p>现在碰到的绝大部分请求都会是GET和POST请求  </p><h3 id="GET与POST的区别"><a href="#GET与POST的区别" class="headerlink" title="GET与POST的区别"></a>GET与POST的区别</h3><ul><li>GET请求的参数 包含在URL中，POST并非在其中，而是会在请求体中通过表单的形式传递  </li><li>GET请求最多提交1024字节的数据，而POST则没有限制  </li></ul><h2 id="请求头"><a href="#请求头" class="headerlink" title="请求头"></a>请求头</h2><table><thead><tr><th>常用信息</th><th>描述</th></tr></thead><tbody><tr><td>Accept</td><td>请求头域，指定接受的内容类型</td></tr><tr><td>Accept-Encoding</td><td>指定接受的内容的编码格式</td></tr><tr><td>Accept-Language</td><td>指定接受的内容的语言</td></tr><tr><td>Host</td><td>指定服务器域名和TCP端口号，如果使用的是服务请求标准端口号，端口号可以省略</td></tr><tr><td>Cookie</td><td>网站为了辨识用户进行绘画跟踪而储存在用户本地的数据。主要功能是维持当前访问会话</td></tr><tr><td>Referer</td><td>用于标识请求从哪个页面发送过来，一般用于给服务器做数据统计</td></tr><tr><td>User-Agent</td><td>简称UA，标明用户使用的操作系统，浏览器信息</td></tr><tr><td>Content-Type</td><td>设置请求体的MIME类型，用于表示具体请求的媒体类型信息</td></tr><tr><td>X-Requested-With</td><td>标识Ajax请求，大部分js框架发送请求时都会设置它为XMLHttpRequest</td></tr><tr><td>Cache-Control</td><td>设置请求响应链上所有的缓存机制必须遵守的指令</td></tr><tr><td>Content-Length</td><td>设置请求体的字节长度</td></tr><tr><td>TE</td><td>设置用户代理期望接受的传输编码格式，和响应头中的Transfer-Encoding字段一样</td></tr><tr><td>DNT</td><td>请求web应用禁用用户追踪</td></tr><tr><td>Connection</td><td>设置当前连接和hop-by-hop协议请求字段列表的控制选项</td></tr><tr><td>Accept-Charset</td><td>接受的字符编码</td></tr></tbody></table><p>比较重要的信息：Cookies、Referer、User-Agent……  </p><h2 id="请求体"><a href="#请求体" class="headerlink" title="请求体"></a>请求体</h2><p>承载信息主体</p><h1 id="响应"><a href="#响应" class="headerlink" title="响应"></a>响应</h1><p>响应主要分为三个部分：响应状态码，响应头，响应体  </p><h2 id="响应状态码"><a href="#响应状态码" class="headerlink" title="响应状态码"></a>响应状态码</h2><p>标识请求是否已成功完成<br>响应分为五类：信息响应(100–199)，成功响应(200–299)，重定向(300–399)，客户端错误(400–499)和服务器错误 (500–599)<br>详细：<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status</a>  </p><h2 id="响应头"><a href="#响应头" class="headerlink" title="响应头"></a>响应头</h2><table><thead><tr><th>常用信息</th><th>描述</th></tr></thead><tbody><tr><td>Date</td><td>响应产生的时间</td></tr><tr><td>Last-Modified</td><td>文档的最后改动时间</td></tr><tr><td>Allow</td><td>服务器支持哪些请求方法</td></tr><tr><td>Content-Encoding</td><td>文档的编码（Encode）方法。只有在解码之后才可以得到Content-Type头指定的内容类型。利用gzip压缩文档能够显著地减少HTML文档的下载时间。</td></tr><tr><td>Content-Length</td><td>内容长度</td></tr><tr><td>Content-Type</td><td>表示后面的文档属于什么MIME类型</td></tr><tr><td>Server</td><td>服务器名字</td></tr><tr><td>Expires</td><td>响应过期时间，数据可以缓存在浏览器或者代理服务器中，如果再次访问，则可以从缓存中加载，降低服务器负荷</td></tr><tr><td>Set-Cookie</td><td>设置和页面关联的Cookie</td></tr></tbody></table><h2 id="响应体"><a href="#响应体" class="headerlink" title="响应体"></a>响应体</h2><p>承载信息主体</p><h1 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h1><h2 id="静态页面与动态页面"><a href="#静态页面与动态页面" class="headerlink" title="静态页面与动态页面"></a>静态页面与动态页面</h2><table><thead><tr><th></th><th>静态页面</th><th>动态页面</th></tr></thead><tbody><tr><td>内容</td><td>固定</td><td>可变</td></tr><tr><td>加载速度</td><td>快</td><td>慢</td></tr><tr><td>可维护性</td><td>差</td><td>好</td></tr><tr><td>动态页面可以解析URL中的参数变化，动态呈现不同的页面内容，更加灵活多变</td><td></td><td></td></tr></tbody></table><h2 id="无状态HTTP"><a href="#无状态HTTP" class="headerlink" title="无状态HTTP"></a>无状态HTTP</h2><p>无状态HTTP是指HTTP协议对事物处理是没有记忆能力的<br>向服务器发送请求，服务器解析请求，返回对应响应，这个过程是完全独立的，服务器不会记录前后状态的变化。这意味着如果你需要处理前面处理过的信息，则需要重传，会导致资源浪费<br>于是两个用于保持HTTP连接状态的技术出现了：<code>会话</code> 和 <code>Cookies</code></p><h3 id="会话-1"><a href="#会话-1" class="headerlink" title="会话"></a>会话</h3><p>会话对象用来存储特定用户会话所需的属性和配置信息<br>当用户在Web页面中跳转时，存储在会话对象中的变量不会消失，会在整个用户会话中一直存在下去  </p><blockquote><p>当用户请求Web页时，如果用户还没有会话，Web服务器会自动创建一个会话对象。<br>当会话过期或被抛弃后，服务器将终止会话</p></blockquote><h3 id="Cookies"><a href="#Cookies" class="headerlink" title="Cookies"></a>Cookies</h3><p>网站为了辨识用户身份、进行会话跟踪 存储在用户本地终端上的数据  </p><h4 id="会话维持"><a href="#会话维持" class="headerlink" title="会话维持"></a>会话维持</h4><p>客户端第一次请求服务器时，服务器会返回一个相应头中带有<code>Set-Cookie</code>字段的响应给客户端用于标识用户，客户端则会将<code>Cookies</code>存起来<br>在浏览器再次请求该网站，浏览器会把此前存放的<code>Cookies</code>放到请求头里一起提交给服务器<br><code>Cookies</code>携带了会话ID信息，服务器检查就知道其对应的会话了  </p><h4 id="属性结构"><a href="#属性结构" class="headerlink" title="属性结构"></a>属性结构</h4><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>Name</td><td>Cookie名称<br>一旦创建，不可更改</td></tr><tr><td>Value</td><td>Cookie值<br>如果为Unicode字符，则需要为字符编码<br>如果为二进制数据，则需要使用BASE64编码</td></tr><tr><td>Domain</td><td>可以访问该Cookie的域名</td></tr><tr><td>Max Age</td><td>Cookie失效时间，单位为秒，常与Expires一同使用<br>若值为正数，则Cookie在Max Age秒后失效<br>若值为负数，则关闭浏览器后Cookie失效</td></tr><tr><td>Path</td><td>Cookie使用路径<br>如果设置为/path/，则只有路径为/path/的页面才可以访问此Cookie<br>不设置则域名下所有页面均可访问此Cookie</td></tr><tr><td>Size 字段</td><td>Cookie 大小</td></tr><tr><td>HTTP 字段</td><td>Cookie的httponly属性<br>若此属性为true,则只有HTTP头中会带有此Cookie信息，而不能通过document.cookie来访问此Cookie</td></tr><tr><td>Secure</td><td>此Cookie是否只使用安全协议传输</td></tr></tbody></table><h4 id="会话Cookie与持久Cookie"><a href="#会话Cookie与持久Cookie" class="headerlink" title="会话Cookie与持久Cookie"></a>会话Cookie与持久Cookie</h4><p>会话Cookie 指那些被存在浏览器内存中的Cookie，关闭浏览器后该Cookie会失效<br>持久Cookie 指那些保存在客户端硬盘中的Cookie，下次使用浏览器还能用  </p><p>很多时候，Cookie都会被设置为持久Cookie，而且设置一个相当长的失效时间，这样做可以节约登录的资源消耗  </p><h1 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h1><p>服务商的服务器是为普通用户服务的，服务商并不想为爬虫的程序浪费资源，因此会想办法反爬虫<br>在你提交请求的时候，服务器会记录你的IP。当同一个IP在一段时间内访问频率远高于一个正常人操作的频率，那么想都不用想，这就是爬虫程序，他会将你的IP设置在黑名单里，不再接受你的请求<br>使用代理来伪装IP，让服务器以为你是来自不同的地方的用户，本机IP不超出阀值，就不会被封禁</p><h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p>proxy server 代理服务器，功能是替代用户去获取网络信息，工作性质像是一个物流中转站<br>设置了代理以后，请求和响应都通过代理进行，服务器识别到的请求的IP是代理的IP<br>当代理足够多，将爬虫客户端高频率的请求分摊到多个代理服务器分别请求，形成很多看似合理的低频率访问，服务器就无法通过观察IP访问频率直接封禁IP来达到反爬虫的目的<br>需要注意的是 一个代理和客户端一样 会有访问频率过高而被封的可能，所以依然要注意访问频率</p><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><ul><li>突破IP访问限制<br>能访问到当前IP访问不了的站点  </li><li>提高访问速度<br>通常代理服务器会设置一个较大的硬盘缓冲区，当有外界的信息通过时，会将它保存到缓冲区中。当其他用户访问相同的信息，可以从缓冲区里直接取出信息，提高访问速度  </li><li>隐藏真实IP<br>保护自己或者，避免被封  </li></ul><h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><h3 id="按照协议区分"><a href="#按照协议区分" class="headerlink" title="按照协议区分"></a>按照协议区分</h3><table><thead><tr><th>代理类型</th><th>信息</th><th>协议默认端口</th></tr></thead><tbody><tr><td>FTP代理服务器</td><td>用户访问FTP服务，一般有上传、下载、缓存功能</td><td>21或2121</td></tr><tr><td>HTTP代理服务器</td><td>用于访问网页，一般有内容过滤和缓存功能</td><td>80或8080或3128</td></tr><tr><td>SSL/TLS代理</td><td>用于访问加密网站，一般有SSL或TLS加密功能</td><td>443</td></tr><tr><td>RTSP 代理</td><td>Real流媒体服务器，一般有缓存功能</td><td>554</td></tr><tr><td>Telnet 代理</td><td>用于telnet远程控制（黑客入侵时常用于隐藏身份）</td><td>23</td></tr><tr><td>POP3/SMTP 代理</td><td>POP3/SMTP收发右键，一般有缓存功能</td><td>110、25</td></tr><tr><td>SOCKS 代理</td><td>只是单纯传递数据包，不关心协议和用法，速度较快，一般有缓存功能</td><td>1080</td></tr></tbody></table><blockquote><p>SOCKS代理分类  </p></blockquote><blockquote><table><thead><tr><th></th><th>SOCKS4</th><th>SOCKS5</th></tr></thead><tbody><tr><td>协议支持</td><td>TCP</td><td>TCP/UDP</td></tr><tr><td>身份验证/域名解析</td><td>×</td><td>√</td></tr></tbody></table></blockquote><h3 id="按照匿名程度区分"><a href="#按照匿名程度区分" class="headerlink" title="按照匿名程度区分"></a>按照匿名程度区分</h3><table><thead><tr><th>代理类型</th><th>服务器获取到的IP信息</th><th>数据包改动</th><th>信息</th></tr></thead><tbody><tr><td>高度匿名代理</td><td>代理服务器IP</td><td>×</td><td>原封不动的转发数据包<br></td></tr><tr><td>普通匿名代理</td><td>知道你用了代理，可以追查到真实IP</td><td>√</td><td>通常会在HTTP头带上<code>HTTP_VIA</code>和<code>HTTP_X_FRORWARDED_FOR</code></td></tr><tr><td>透明代理</td><td>真实IP</td><td>√</td><td>会告诉服务器客户端的真实IP<br>主要作用在于利用缓存提高浏览速度，过滤不安全数据包</td></tr><tr><td>间谍代理</td><td>?</td><td>?</td><td>用于记录用户传输数据，然后进行研究，达到监控的目的</td></tr></tbody></table><p>对于爬虫来说，最好是有高匿代理，普通代理对一些小网站也可以用</p><h2 id="常见代理设置"><a href="#常见代理设置" class="headerlink" title="常见代理设置"></a>常见代理设置</h2><table><thead><tr><th>代理类型</th><th>稳定性</th><th>信息</th></tr></thead><tbody><tr><td>免费代理</td><td>差</td><td>可用的不多，使用前最好筛选一下，可以进一步维护出一个代理池</td></tr><tr><td>付费代理</td><td>较好</td><td>质量比免费的好很多</td></tr><tr><td>ADSL拨号</td><td>好</td><td>拨号一次换一个IP，是一种比较有效的解决方案</td></tr></tbody></table><h1 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h1><p>AJAX = Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）<br><code>AJAX</code> 是一种使用现有标准的新方法<br>利用<code>JavaScript</code>，在页面不刷新的情况下与服务器交换数据，更新部分网页的技术<br>这种技术的使用能节约一部分服务器资源消耗，提升用户体验  </p><h2 id="基本原理-1"><a href="#基本原理-1" class="headerlink" title="基本原理"></a>基本原理</h2><p>一般来说，从发送Ajax请求到更新网页这个过程可以分为三步：发送请求，解析响应，渲染页面<br>这里用原生JavaScript作为例子  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 创建一个 XMLHttpRequest 对象</span><br><span class="hljs-keyword">var</span> xmlhttp;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">window</span>.XMLHttpRequest)<br>&#123;<br>    <span class="hljs-comment">//  IE7+, Firefox, Chrome, Opera, Safari 浏览器执行代码</span><br>    xmlhttp=<span class="hljs-keyword">new</span> XMLHttpRequest();<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>    <span class="hljs-comment">// IE6, IE5 浏览器执行代码</span><br>    xmlhttp=<span class="hljs-keyword">new</span> ActiveXObject(<span class="hljs-string">&quot;Microsoft.XMLHTTP&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">//调用 onreadystatechange 进行监听，等待服务器响应</span><br>xmlhttp.onreadystatechange=<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-comment">// 根据readyState和status判断响应状态</span><br>    <span class="hljs-keyword">if</span> (xmlhttp.readyState==<span class="hljs-number">4</span> &amp;&amp; xmlhttp.status==<span class="hljs-number">200</span>)<br>    &#123;<br>        <span class="hljs-comment">//响应回调，对服务器返回的数据进行的操作，刷新页面元素</span><br>        <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;myDiv&quot;</span>).innerHTML=xmlhttp.responseText;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//调用open()和send()向服务器发送请求</span><br>xmlhttp.open(<span class="hljs-string">&quot;GET&quot;</span>,<span class="hljs-string">&quot;ajax_info.txt&quot;</span>,<span class="hljs-literal">true</span>);<br>xmlhttp.send();<br></code></pre></td></tr></table></figure><table><thead><tr><th>XMLHttpRequest 对象</th><th>信息</th></tr></thead><tbody><tr><td>onreadystatechange</td><td>存储函数（或函数名），每当 readyState 属性改变时，就会调用该函数</td></tr><tr><td>readyState</td><td>存有 XMLHttpRequest 的状态<br>0: 请求未初始化<br>1: 服务器连接已建立<br>2: 请求已接收<br>3: 请求处理中<br>4: 请求已完成，且响应已就绪</td></tr><tr><td>status</td><td>200: “OK”<br>404: 未找到页面</td></tr></tbody></table><h2 id="Ajax分析"><a href="#Ajax分析" class="headerlink" title="Ajax分析"></a>Ajax分析</h2><h3 id="Ajax头部特点"><a href="#Ajax头部特点" class="headerlink" title="Ajax头部特点"></a>Ajax头部特点</h3><p>Ajax有特殊的请求类型<code>xhr</code><br><img src="/%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80/20200724064909295.png"><br><code>x-requested-with: XMLHttpRequest</code>就标记了此请求是一个<code>Ajax</code>请求<br>如果需要模拟<code>Ajax</code>发送请求，需要在头部添加这个参数</p><h3 id="Ajax结果"><a href="#Ajax结果" class="headerlink" title="Ajax结果"></a>Ajax结果</h3><p>返回的结果类型多数会是json/xml/text<br><img src="/%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80/20200724070129095.png"><br>其内容可能存在被加密的可能性<br>但由于在页面上显示是正确的内容，所以js中一定存在解密的逻辑  </p><h3 id="Ajax溯源"><a href="#Ajax溯源" class="headerlink" title="Ajax溯源"></a>Ajax溯源</h3><p><img src="/%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80/20200724083416698.png"><br>可以根据<code>GET</code>方法的参数来进行全局查找<br>可以打<code>XHR断点</code>，根据url来寻找  </p><h4 id="Ajax样式"><a href="#Ajax样式" class="headerlink" title="Ajax样式"></a>Ajax样式</h4><p>流星</p><ul><li>AngularJS  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 简单的 GET 请求，可以改为 POST</span><br>$http(&#123;<br>    method: <span class="hljs-string">&#x27;GET&#x27;</span>,<br>    url: <span class="hljs-string">&#x27;/someUrl&#x27;</span><br>&#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">successCallback</span>(<span class="hljs-params">response</span>) </span>&#123;<br>        <span class="hljs-comment">// 请求成功执行代码</span><br>    &#125;, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">errorCallback</span>(<span class="hljs-params">response</span>) </span>&#123;<br>        <span class="hljs-comment">// 请求失败执行代码</span><br>&#125;);<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>爬虫</tag>
      
      <tag>代理</tag>
      
      <tag>HTTP/HTTPS</tag>
      
      <tag>Ajax</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>win10-优化</title>
    <link href="/post/dc386b6d/"/>
    <url>/post/dc386b6d/</url>
    
    <content type="html"><![CDATA[<p>装机以后的一些操作  </p><h2 id="Bios基本优化"><a href="#Bios基本优化" class="headerlink" title="Bios基本优化"></a>Bios基本优化</h2><p>打开Bios，将<code>GAME BOOST</code>和<code>A-XMP</code>开启  </p><h2 id="将我的文档内容路径修改"><a href="#将我的文档内容路径修改" class="headerlink" title="将我的文档内容路径修改"></a>将我的文档内容路径修改</h2><p>电脑用得越久，我的文档里的内容就会越来越多，越来越大<br><img src="/win10-%E4%BC%98%E5%8C%96/20200720024704628.png"><br><img src="/win10-%E4%BC%98%E5%8C%96/20200720024811707.png"><br>我的文档 文件夹下有挺多内容的，建议全部都改到其它盘的同一个地方，并且路径名只用英文  </p><h2 id="windows显示效果性能优化"><a href="#windows显示效果性能优化" class="headerlink" title="windows显示效果性能优化"></a>windows显示效果性能优化</h2><p><img src="/win10-%E4%BC%98%E5%8C%96/20200720030302780.png"><br>能优化的项目有不少，要是最求极致性能，可以直接点追加性能<br>我一般都会自定义  </p><h2 id="N卡基本优化"><a href="#N卡基本优化" class="headerlink" title="N卡基本优化"></a>N卡基本优化</h2><p>打开N卡控制面板<br><img src="/win10-%E4%BC%98%E5%8C%96/20200720024414502.png"><br><img src="/win10-%E4%BC%98%E5%8C%96/20200720025425287.png">  </p><h2 id="找回Windows照片查看器来使用"><a href="#找回Windows照片查看器来使用" class="headerlink" title="找回Windows照片查看器来使用"></a>找回Windows照片查看器来使用</h2><p>Windows10 默认使用照片来打开图片，这东西很慢<br>此处用旧版的图片查看器来代替现在的照片应用  </p><p>创建一个txt文件，写入以下内容  </p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs ada">Windows Registry Editor Version <span class="hljs-number">5.00</span><br>; Change Extension<span class="hljs-symbol">&#x27;s</span> File <span class="hljs-keyword">Type</span><br>[HKEY_CURRENT_USER\Software\Classes\.jpg]<br>@=<span class="hljs-string">&quot;PhotoViewer.FileAssoc.Tiff&quot;</span><br>; Change Extension<span class="hljs-symbol">&#x27;s</span> File <span class="hljs-keyword">Type</span><br>[HKEY_CURRENT_USER\Software\Classes\.jpeg]<br>@=<span class="hljs-string">&quot;PhotoViewer.FileAssoc.Tiff&quot;</span><br>; Change Extension<span class="hljs-symbol">&#x27;s</span> File <span class="hljs-keyword">Type</span><br>[HKEY_CURRENT_USER\Software\Classes\.gif]<br>@=<span class="hljs-string">&quot;PhotoViewer.FileAssoc.Tiff&quot;</span><br>; Change Extension<span class="hljs-symbol">&#x27;s</span> File <span class="hljs-keyword">Type</span><br>[HKEY_CURRENT_USER\Software\Classes\.png]<br>@=<span class="hljs-string">&quot;PhotoViewer.FileAssoc.Tiff&quot;</span><br>; Change Extension<span class="hljs-symbol">&#x27;s</span> File <span class="hljs-keyword">Type</span><br>[HKEY_CURRENT_USER\Software\Classes\.bmp]<br>@=<span class="hljs-string">&quot;PhotoViewer.FileAssoc.Tiff&quot;</span><br>; Change Extension<span class="hljs-symbol">&#x27;s</span> File <span class="hljs-keyword">Type</span><br>[HKEY_CURRENT_USER\Software\Classes\.tiff]<br>@=<span class="hljs-string">&quot;PhotoViewer.FileAssoc.Tiff&quot;</span><br>; Change Extension<span class="hljs-symbol">&#x27;s</span> File <span class="hljs-keyword">Type</span><br>[HKEY_CURRENT_USER\Software\Classes\.ico]<br>@=<span class="hljs-string">&quot;PhotoViewer.FileAssoc.Tiff&quot;</span><br></code></pre></td></tr></table></figure><p>将文本文件扩展名改为<code>.reg</code>  </p><p>双击打开，确认修改注册表<br>修改图片打开方式<br><img src="/win10-%E4%BC%98%E5%8C%96/a.gif">  </p>]]></content>
    
    
    
    <tags>
      
      <tag>win10</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>tesserocr-OCR</title>
    <link href="/post/40d470b0/"/>
    <url>/post/40d470b0/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><code>tesserocr</code>是 Python 的一个 OCR 识别库<br>其本身其实是对<code>tesseract</code>做的一层<code>python API</code>封装  </p><h1 id="文档信息"><a href="#文档信息" class="headerlink" title="文档信息"></a>文档信息</h1><table><thead><tr><th>内容</th><th>地址</th></tr></thead><tbody><tr><td>tesserocr GitHub</td><td><a href="https://github.com/sirfz/tesserocr">https://github.com/sirfz/tesserocr</a></td></tr><tr><td>tesserocr PyPi</td><td><a href="https://pypi.org/project/tesserocr/">https://pypi.org/project/tesserocr/</a></td></tr><tr><td>tesseract 下载地址</td><td><a href="https://digi.bib.uni-mannheim.de/tesseract/">https://digi.bib.uni-mannheim.de/tesseract/</a></td></tr><tr><td>tesseract 语言包</td><td><a href="https://github.com/tesseract-ocr/tessdata">https://github.com/tesseract-ocr/tessdata</a></td></tr><tr><td>tesseract 文档</td><td><a href="https://github.com/tesseract-ocr/tesseract/wiki/Documentation">https://github.com/tesseract-ocr/tesseract/wiki/Documentation</a></td></tr></tbody></table><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h2 id="安装tesseract"><a href="#安装tesseract" class="headerlink" title="安装tesseract"></a>安装tesseract</h2><p>首先先下载其核心<code>tesseract</code><br><img src="/tesserocr-OCR/20200720022503493.png"><br>一般选择稳定版下载，也就是那些不带dev/beta之类的字样的版本<br>下载好了以后安装上去，安装的时候，有附带语言包的选项<br>要是有梯，直接勾上就能顺便把想安装的语言包安装上  </p><h3 id="手动安装tesseract语言包"><a href="#手动安装tesseract语言包" class="headerlink" title="手动安装tesseract语言包"></a>手动安装tesseract语言包</h3><p>官方Github：<a href="https://tesseract-ocr.github.io/tessdoc/Data-Files">https://tesseract-ocr.github.io/tessdoc/Data-Files</a><br>官方github里有得下载<br><img src="/tesserocr-OCR/20200728043316303.png"><br>下载好以后，放在tesserocr安装目录这个路径下即可<br><img src="/tesserocr-OCR/20200728043539557.png">  </p><h3 id="添加tesseract到环境变量中"><a href="#添加tesseract到环境变量中" class="headerlink" title="添加tesseract到环境变量中"></a>添加tesseract到环境变量中</h3><h2 id="tesserocr安装"><a href="#tesserocr安装" class="headerlink" title="tesserocr安装"></a>tesserocr安装</h2><p><code>pip install tesserocr pillow</code><br>可以先尝试着直接用pip来安装<br>若是失败的话，可以去下载对应Python版本的whl来进行安装<br>whl下载地址：<br><a href="https://github.com/simonflueckiger/tesserocr-windows_build/releases">https://github.com/simonflueckiger/tesserocr-windows_build/releases</a><br><img src="/tesserocr-OCR/20200728044645155.png"></p><h2 id="测试是否安装成功"><a href="#测试是否安装成功" class="headerlink" title="测试是否安装成功"></a>测试是否安装成功</h2><p><code>import tesserocr from PIL import Image img = Image.open(r&#39;example/0_Basic_usage_of_the_library/tesserocr/pic/0_hello_world.png&#39;) chars = tesserocr.image_to_text(img) print(chars)</code><br>这里的图片路径需要换成你自己的  </p><h3 id="可能发生的错误"><a href="#可能发生的错误" class="headerlink" title="可能发生的错误"></a>可能发生的错误</h3><p><code>RuntimeError: Failed to init API, possibly an invalid tessdata path:......</code><br><img src="/tesserocr-OCR/20200728063611671.png"><br>将<code>tesseract</code>安装目录下的<code>tessdata</code>复制到其指定的地点即可  </p>]]></content>
    
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>爬虫</tag>
      
      <tag>OCR</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python-aiohttp-异步web服务-爬虫</title>
    <link href="/post/8d1b1c05/"/>
    <url>/post/8d1b1c05/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><code>requests</code>是一个阻塞式HTTP请求库，发出一个请求后，程序会一直等待服务器响应，得到响应后，程序才会进行下一步处理。这种等待会大大降低爬取效率<br><code>aiohttp</code>是一个提供异步web服务的库，能让你的程序可以在等待的过程中做一切其他的事情，提高效率  </p><h1 id="文档信息"><a href="#文档信息" class="headerlink" title="文档信息"></a>文档信息</h1><p>官方文档：<a href="https://docs.aiohttp.org/en/stable/">https://docs.aiohttp.org/en/stable/</a><br>github：<a href="https://github.com/aio-libs/aiohttp">https://github.com/aio-libs/aiohttp</a>  </p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">pip <span class="hljs-keyword">install</span> aiohttp<br></code></pre></td></tr></table></figure><p>另外，官方推荐安装 字符编码检测库 cchardet，加速DNS解析库aiodns  </p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">pip <span class="hljs-keyword">install</span> cchardet aiodns<br></code></pre></td></tr></table></figure><h1 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-comment"># 首先，你要引入 aiohttp</span><br><span class="hljs-keyword">import</span> aiohttp<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Hello Aiohttp&#x27;</span>)<br><br><span class="hljs-comment"># 创建一个名为 session 的 ClientSession 对象  </span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> aiohttp.ClientSession() <span class="hljs-keyword">as</span> session:<br>    <span class="hljs-comment"># ClientSession 对象发起请求，获取结果保存为 resp</span><br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> session.get(<span class="hljs-string">&#x27;http://httpbin.org/get&#x27;</span>) <span class="hljs-keyword">as</span> resp:<br>        <span class="hljs-built_in">print</span>(resp.status)  <span class="hljs-comment"># 响应状态码</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-keyword">await</span> resp.text())  <span class="hljs-comment"># 响应内容</span><br></code></pre></td></tr></table></figure><p>这段代码创建了一个<code>session</code>以用作访问，但最好不要每一次访问都创建<code>session</code>，如果可以的话同一个网站用同一个session来进行访问  </p><p>实际上除了<code>get()</code>还有一些其它的方法  </p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs lasso">session.post(<span class="hljs-string">&#x27;http://httpbin.org/post&#x27;</span>, <span class="hljs-built_in">data</span>=b<span class="hljs-string">&#x27;data&#x27;</span>)<br>session.put(<span class="hljs-string">&#x27;http://httpbin.org/put&#x27;</span>, <span class="hljs-built_in">data</span>=b<span class="hljs-string">&#x27;data&#x27;</span>)<br>session.delete(<span class="hljs-string">&#x27;http://httpbin.org/delete&#x27;</span>)<br><span class="hljs-params">...</span><span class="hljs-params">...</span><br></code></pre></td></tr></table></figure><h2 id="带参数的get请求"><a href="#带参数的get请求" class="headerlink" title="带参数的get请求"></a>带参数的get请求</h2><p>传入<code>params</code>参数即可  </p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">params</span> = &#123;<span class="hljs-string">&#x27;key1&#x27;</span>: <span class="hljs-string">&#x27;value1&#x27;</span>, <span class="hljs-string">&#x27;key2&#x27;</span>: <span class="hljs-string">&#x27;value2&#x27;</span>&#125;<br><span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> session.<span class="hljs-keyword">get</span>(<span class="hljs-string">&#x27;http://httpbin.org/get&#x27;</span>,<br>                       <span class="hljs-keyword">params</span>=<span class="hljs-keyword">params</span>) <span class="hljs-keyword">as</span> resp:<br>    print(resp.url)<br></code></pre></td></tr></table></figure><h2 id="关于url转换"><a href="#关于url转换" class="headerlink" title="关于url转换"></a>关于url转换</h2><p><code>aiohttp</code>默认会在发送请求之前会在内部执行URL规范化<br>比如将url中的中文转为其它编码<br>如果不希望进行这个过程，可以传入<code>encoded=True</code>禁用  </p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">await session.<span class="hljs-builtin-name">get</span>(<br>    URL(<span class="hljs-string">&#x27;http://example.com/%30&#x27;</span>, <span class="hljs-attribute">encoded</span>=<span class="hljs-literal">True</span>))<br></code></pre></td></tr></table></figure><p>需要注意的是，如果你<code>get方法</code>中传入了<code>params</code>参数，那么这个禁用会无效  </p><h2 id="二进制响应"><a href="#二进制响应" class="headerlink" title="二进制响应"></a>二进制响应</h2><p>如果响应是二进制文件，那么需要用<code>read()</code>来获取  </p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">await resp.<span class="hljs-built_in">read</span>()<br></code></pre></td></tr></table></figure><h2 id="Json请求"><a href="#Json请求" class="headerlink" title="Json请求"></a>Json请求</h2><p><code>session</code>的任何方法都可以传入<code>json</code>参数  </p><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs qml"><span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> aiohttp.ClientSession() <span class="hljs-keyword">as</span> <span class="hljs-attribute">session</span>:<br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> session.post(<span class="hljs-built_in">url</span>, json=&#123;<span class="hljs-string">&#x27;test&#x27;</span>: <span class="hljs-string">&#x27;object&#x27;</span>&#125;)<br></code></pre></td></tr></table></figure><p><code>session</code>会使用<code>python</code>自带的<code>json</code>模块来进行序列化<br>你也可以使用比它更快的<code>ujson</code>模块来进行这个过程  </p><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs qml"><span class="hljs-keyword">import</span> ujson<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> aiohttp.ClientSession(<br>        json_serialize=ujson.dumps) <span class="hljs-keyword">as</span> <span class="hljs-attribute">session</span>:<br>    <span class="hljs-keyword">await</span> session.post(<span class="hljs-built_in">url</span>, json=&#123;<span class="hljs-string">&#x27;test&#x27;</span>: <span class="hljs-string">&#x27;object&#x27;</span>&#125;)<br></code></pre></td></tr></table></figure><h2 id="Json响应"><a href="#Json响应" class="headerlink" title="Json响应"></a>Json响应</h2><p><code>resp.json()</code>可以直接解析<code>json</code>  </p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> session.<span class="hljs-keyword">get</span>(<span class="hljs-string">&#x27;https://api.github.com/events&#x27;</span>) <span class="hljs-keyword">as</span> resp:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-keyword">await</span> resp.json())<br></code></pre></td></tr></table></figure><h2 id="响应内容流"><a href="#响应内容流" class="headerlink" title="响应内容流"></a>响应内容流</h2><p><code>read()</code>，<code>json()</code>、<code>text()</code>方法非常方便，但应该要谨慎使用。这些方法会将整个响应加载到内存中。要是响应很大，就会造成问题  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">with</span> <span class="hljs-keyword">open</span>(filename, <span class="hljs-string">&#x27;wb&#x27;</span>) <span class="hljs-keyword">as</span> fd:<br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        <span class="hljs-keyword">chunk</span> = await resp.content.read(chunk_size)<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">chunk</span>:<br>            break<br>        fd.write(<span class="hljs-keyword">chunk</span>)<br></code></pre></td></tr></table></figure><p>你可以一些一些的去处理响应  </p><h2 id="post请求"><a href="#post请求" class="headerlink" title="post请求"></a>post请求</h2><p>传入表单参数即可，编码会自动完成  </p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">payload = &#123;<span class="hljs-string">&#x27;key1&#x27;</span>: <span class="hljs-string">&#x27;value1&#x27;</span>, <span class="hljs-string">&#x27;key2&#x27;</span>: <span class="hljs-string">&#x27;value2&#x27;</span>&#125;<br><span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> session.post(<span class="hljs-string">&#x27;http://httpbin.org/post&#x27;</span>,<br>                        data=payload) <span class="hljs-keyword">as</span> resp:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-keyword">await</span> resp.text())<br></code></pre></td></tr></table></figure><p>如果只希望传递字符，可以用<code>data</code>参数</p><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs qml"><span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> session.post(<span class="hljs-built_in">url</span>, data=<span class="hljs-string">&#x27;Тест&#x27;</span>) <span class="hljs-keyword">as</span> <span class="hljs-attribute">resp</span>:<br>    ...<br></code></pre></td></tr></table></figure><h2 id="上传文件"><a href="#上传文件" class="headerlink" title="上传文件"></a>上传文件</h2><p>一点点载入，一点点上传  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">file_sender</span>(<span class="hljs-params">file_name=<span class="hljs-literal">None</span></span>):</span><br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> aiofiles.<span class="hljs-built_in">open</span>(file_name, <span class="hljs-string">&#x27;rb&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>        chunk = <span class="hljs-keyword">await</span> f.read(<span class="hljs-number">64</span>*<span class="hljs-number">1024</span>)<br>        <span class="hljs-keyword">while</span> chunk:<br>            <span class="hljs-keyword">yield</span> chunk<br>            chunk = <span class="hljs-keyword">await</span> f.read(<span class="hljs-number">64</span>*<span class="hljs-number">1024</span>)<br><br><span class="hljs-comment"># Then you can use file_sender as a data provider:</span><br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> session.post(<span class="hljs-string">&#x27;http://httpbin.org/post&#x27;</span>,<br>                        data=file_sender(file_name=<span class="hljs-string">&#x27;huge_file&#x27;</span>)) <span class="hljs-keyword">as</span> resp:<br>    print(<span class="hljs-keyword">await</span> resp.text())<br></code></pre></td></tr></table></figure><h2 id="WebSockets"><a href="#WebSockets" class="headerlink" title="WebSockets"></a>WebSockets</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> session.ws_connect(<span class="hljs-string">&#x27;http://example.org/ws&#x27;</span>) <span class="hljs-keyword">as</span> ws:<br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">for</span> msg <span class="hljs-keyword">in</span> ws:<br>        <span class="hljs-keyword">if</span> msg.<span class="hljs-built_in">type</span> == aiohttp.WSMsgType.TEXT:<br>            <span class="hljs-keyword">if</span> msg.data == <span class="hljs-string">&#x27;close cmd&#x27;</span>:<br>                <span class="hljs-keyword">await</span> ws.close()<br>                <span class="hljs-keyword">break</span><br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">await</span> ws.send_str(msg.data + <span class="hljs-string">&#x27;/answer&#x27;</span>)<br>        <span class="hljs-keyword">elif</span> msg.<span class="hljs-built_in">type</span> == aiohttp.WSMsgType.ERROR:<br>            <span class="hljs-keyword">break</span><br></code></pre></td></tr></table></figure><p>You must use the only websocket task for both reading (e.g. await ws.receive() or async for msg in ws:) and writing but may have multiple writer tasks which can only send data asynchronously (by await ws.send_str(‘data’) for example).</p><h2 id="超时"><a href="#超时" class="headerlink" title="超时"></a>超时</h2><p>超时设置存储在<code>ClientTimeout</code>对象中<br>默认情况下，这个超时的时间是5分钟<br>给seesion设置超时  </p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">timeout = aiohttp.<span class="hljs-constructor">ClientTimeout(<span class="hljs-params">total</span>=60)</span><br>async <span class="hljs-keyword">with</span> aiohttp.<span class="hljs-constructor">ClientSession(<span class="hljs-params">timeout</span>=<span class="hljs-params">timeout</span>)</span> <span class="hljs-keyword">as</span> session:<br>    ...<br></code></pre></td></tr></table></figure><p>给这次get请求设置超时  </p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs applescript">async <span class="hljs-keyword">with</span> session.<span class="hljs-keyword">get</span>(url, <span class="hljs-keyword">timeout</span>=<span class="hljs-keyword">timeout</span>) <span class="hljs-keyword">as</span> resp:<br>    ...<br></code></pre></td></tr></table></figure><p><code>ClientTimeout</code>接收多个参数作为超时标准  </p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">aiohttp.ClientTimeout(<span class="hljs-attribute">total</span>=5*60, <span class="hljs-attribute">connect</span>=None,<br>                      <span class="hljs-attribute">sock_connect</span>=None, <span class="hljs-attribute">sock_read</span>=None)<br></code></pre></td></tr></table></figure><ul><li>total<br>总时长  </li><li>connect<br>建立新连接时间 或 在连接池中等待的时间  </li><li>sock_connect<br>A timeout for connecting to a peer for a new connection, not given from a pool  </li><li>sock_read<br>从对等方读取新数据部分之间的最大允许超时时间  </li></ul><h2 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h2><p>你可以在<code>session.get()</code>中设置你的proxy：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> session.get(url, proxy=your_proxy_url) <span class="hljs-keyword">as</span> response:<br>    <span class="hljs-keyword">return</span> BeautifulSoup(<span class="hljs-keyword">await</span> response.content, <span class="hljs-string">&#x27;html.parser&#x27;</span>)<br></code></pre></td></tr></table></figure><p>如果你的IP需要认证，可以这样设置：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">proxy = <span class="hljs-string">&#x27;http://your_user:your_password@your_proxy_url:your_proxy_port&#x27;</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> session.get(url, proxy=proxy) <span class="hljs-keyword">as</span> response:<br>    <span class="hljs-keyword">return</span> BeautifulSoup(<span class="hljs-keyword">await</span> response.content, <span class="hljs-string">&#x27;html.parser&#x27;</span>)<br></code></pre></td></tr></table></figure><p>或者是这样设置：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">proxy = <span class="hljs-string">&#x27;http://your_proxy_url:your_proxy_port&#x27;</span><br>proxy_auth = aiohttp.BasicAuth(<span class="hljs-string">&#x27;your_user&#x27;</span>, <span class="hljs-string">&#x27;your_password&#x27;</span>)<br><span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> session.get(url, proxy=proxy, proxy_auth=proxy_auth) <span class="hljs-keyword">as</span> response:<br>    <span class="hljs-keyword">return</span> BeautifulSoup(<span class="hljs-keyword">await</span> response.content, <span class="hljs-string">&#x27;html.parser&#x27;</span>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>爬虫</tag>
      
      <tag>aiohttp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>无意义记录</title>
    <link href="/post/f8ae26c5/"/>
    <url>/post/f8ae26c5/</url>
    
    <content type="html"><![CDATA[<h1 id="黑客-Hacker"><a href="#黑客-Hacker" class="headerlink" title="黑客 Hacker"></a>黑客 Hacker</h1><p>黑客（Hacker）是指对设计、编程和计算机科学方面具高度理解的人  </p><h1 id="溃客-Cracker"><a href="#溃客-Cracker" class="headerlink" title="溃客 Cracker"></a>溃客 Cracker</h1><p>溃客（Cracker）才是专指对计算机系统及网络进行恶意破坏的人  </p><h1 id="脚本小子-script-kiddie"><a href="#脚本小子-script-kiddie" class="headerlink" title="脚本小子 script kiddie"></a>脚本小子 script kiddie</h1><p>是一个贬义词，用来描述以“黑客”自居并沾沾自喜的初学者。<br>脚本小子不像真正的黑客那样发现系统漏洞，他们通常使用别人开发的程序来恶意破坏他人系统<br>通常的刻板印象为一位没有专科经验的少年，破坏无辜网站企图使得他的朋友感到惊讶，因而称之为脚本小子  </p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Fiddler-抓包</title>
    <link href="/post/86bce51a/"/>
    <url>/post/86bce51a/</url>
    
    <content type="html"><![CDATA[<h1 id="官网"><a href="#官网" class="headerlink" title="官网"></a>官网</h1><p><a href="https://www.telerik.com/fiddler">https://www.telerik.com/fiddler</a><br><img src="/Fiddler-%E6%8A%93%E5%8C%85/20200713090624596.png"><br>官网下载，然后安装即可  </p><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p><img src="/Fiddler-%E6%8A%93%E5%8C%85/20200712101230463.png"><br>其工作过程就像一个中间人</p><ul><li>浏览器发送给服务器的请求会被<code>Fiddler</code>拦截下来，可以进行请求内容的修改，改完以后再继续发送给服务器  </li><li>服务器返回给浏览器的响应会被<code>Fiddler</code>拦截下来，可以进行请求内容的修改，改完以后再继续返回给浏览器  </li></ul><h1 id="配置流程"><a href="#配置流程" class="headerlink" title="配置流程"></a>配置流程</h1><h2 id="开-关"><a href="#开-关" class="headerlink" title="开/关"></a>开/关</h2><p>一般情况下，打开抓取就会开始抓取<br><img src="/Fiddler-%E6%8A%93%E5%8C%85/20200713091309453.png"></p><h2 id="浏览器配置"><a href="#浏览器配置" class="headerlink" title="浏览器配置"></a>浏览器配置</h2><blockquote><p>这个情况并不一定会发生</p></blockquote><p>有些时候，浏览器发请求，<code>Fiddler</code>会没反应<br>在这种情况下，你需要为浏览器配置<code>Fiddler</code>为代理  </p><blockquote><p><code>Fiddler</code> 默认代理ip: 127.0.0.1  端口:8888<br>（你可以在设置那里查看，随着版本更新，也许会改变）</p></blockquote><h2 id="SSL解析"><a href="#SSL解析" class="headerlink" title="SSL解析"></a>SSL解析</h2><p>经过上述步骤后，会发现有很多的443错误<br><img src="/Fiddler-%E6%8A%93%E5%8C%85/20200713092416800.png"><br><img src="/Fiddler-%E6%8A%93%E5%8C%85/20200713092543274.png"><br><img src="/Fiddler-%E6%8A%93%E5%8C%85/20200713103203826.png"><br>勾选，会弹出一些安全性的警告，同意以后，即可解析HTTPS包  </p><h3 id="获取证书文件"><a href="#获取证书文件" class="headerlink" title="获取证书文件"></a>获取证书文件</h3><p>在你成功设置以后，可以在浏览器访问<code>localhost:Fiddler端口号</code><br><img src="/Fiddler-%E6%8A%93%E5%8C%85/20200712114356658.png"><br>你可以在这里下载到<code>Fiddler</code>的证书文件  </p><h1 id="抓包"><a href="#抓包" class="headerlink" title="抓包"></a>抓包</h1><h2 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h2><p>用Fiddler抓包能抓到连接过程中所有的包，包括建立TCP连接之类的<br><img src="/Fiddler-%E6%8A%93%E5%8C%85/20200713093429418.png"><br>在中间界面选一个包的信息，在右边会显示对应的请求和响应的相关信息  </p><h3 id="过滤"><a href="#过滤" class="headerlink" title="过滤"></a>过滤</h3><p>只处理特定的包<br><img src="/Fiddler-%E6%8A%93%E5%8C%85/20200713102714872.png"><br>这里规定只处理url包含bilibili的包  </p><h3 id="移除"><a href="#移除" class="headerlink" title="移除"></a>移除</h3><p>那些无关紧要的包就丢掉好了<br><img src="/Fiddler-%E6%8A%93%E5%8C%85/20200713104232160.png"><br>有很多种移除，根据情况选择就是</p><h3 id="自动编码"><a href="#自动编码" class="headerlink" title="自动编码"></a>自动编码</h3><p><img src="/Fiddler-%E6%8A%93%E5%8C%85/20200713110920538.png"><br>如果不编码的话，结果可能会是一些乱码  </p><h3 id="断点"><a href="#断点" class="headerlink" title="断点"></a>断点</h3><p>这东西藏在最下面的角落里<br><img src="/Fiddler-%E6%8A%93%E5%8C%85/20200713112151266.png">  </p><table><thead><tr><th>图标</th><th>情况说明</th></tr></thead><tbody><tr><td><img src="/Fiddler-%E6%8A%93%E5%8C%85/20200713112345931.png"></td><td>发送请求时打断</td></tr><tr><td><img src="/Fiddler-%E6%8A%93%E5%8C%85/20200713112443154.png"></td><td>收到响应时打断</td></tr><tr><td><img src="/Fiddler-%E6%8A%93%E5%8C%85/20200713112520590.png"></td><td>不打断</td></tr></tbody></table><h2 id="抓手机app数据包"><a href="#抓手机app数据包" class="headerlink" title="抓手机app数据包"></a>抓手机app数据包</h2><ol><li><p>手机连上wifi<br>让手机连上wifi，保持和电脑处于同一网络下  </p></li><li><p>设置wifi代理项<br><img src="/Fiddler-%E6%8A%93%E5%8C%85/wifi_set.gif">  </p></li><li><p>查看电脑ip地址<br><img src="/Fiddler-%E6%8A%93%E5%8C%85/20200712115949681.png">  </p></li><li><p>Fillder允许远程设备连接<br><img src="/Fiddler-%E6%8A%93%E5%8C%85/20200713092416800.png"><br><img src="/Fiddler-%E6%8A%93%E5%8C%85/20200713093511176.png"></p></li><li><p>下载证书文件<br>大多数下载好了以后还需要去点信任证书才能启用<br>手机浏览器访问 电脑ip:Fiddler端口号下载证书<br><img src="/Fiddler-%E6%8A%93%E5%8C%85/20200713064053107.png"></p><blockquote><p>注意是需要下载下来<br>许多的浏览器都会自己管理证书。如果直接点击，可能只是让手机浏览器信任证书。<br>现在是需要让我手机app信任<code>Fiddler</code>而不是只是让手机浏览器信任。</p></blockquote></li><li><p>安装证书<br><img src="/Fiddler-%E6%8A%93%E5%8C%85/cer_install.gif"><br>证书叫啥名字其实都可以</p><blockquote><p>需要注意的是，有些操作系统需要在证书安全那里点信任<br>在一些高版本的安卓系统里，用户证书不能被信任，需要Root+开发者模式来解决</p></blockquote></li><li><p>验证是否成功抓包<br>这个很简单，在手机上打开一个app进行一些需要访问网络的操作即可<br>抓出来的包与在PC上抓的也大致相同<br>这里通过bilibili app 包来验证  </p><ol><li>清理面板，把过滤器打开<br><img src="/Fiddler-%E6%8A%93%E5%8C%85/20200713105813435.png"></li><li>打开Bilibili app，做一些操作<br>这里我做搜索操作<br><img src="/Fiddler-%E6%8A%93%E5%8C%85/20200713110559660.png"></li><li>确定抓到的包<br><img src="/Fiddler-%E6%8A%93%E5%8C%85/20200713111223122.png"><br>查看包里的内容，看看是否是所需，这里看到内容和app内一致，说明验证成功</li></ol></li></ol><h2 id="中间人修改"><a href="#中间人修改" class="headerlink" title="中间人修改"></a>中间人修改</h2><p>通过修改服务器返回的响应，使得数据变得不同</p><ol><li><p>原始目标包抓取<br><img src="/Fiddler-%E6%8A%93%E5%8C%85/20200714120413692.png"><br><img src="/Fiddler-%E6%8A%93%E5%8C%85/20200714120439773.png">  </p></li><li><p>修改过滤器，精准抓包<br><img src="/Fiddler-%E6%8A%93%E5%8C%85/20200714120538028.png"><br>在上面的抓包中，已经知道了更详细的的url，更改的话能避免显示无意义包  </p></li><li><p>设置响应断点，在响应时打断<br><img src="/Fiddler-%E6%8A%93%E5%8C%85/20200713112806185.png">  </p></li><li><p>手机重新发送请求，响应抓到包，进行修改后复制下来<br>手工修改需要一些时间，一般而言，app会进行三次左右的请求尝试并等待一段时间。要是超时会显示加载失败，手工操作来进行修改的话，需要一定手速<br>为了手工实现快速更改内容，这里将包修改后复制下来<br><img src="/Fiddler-%E6%8A%93%E5%8C%85/change_hot_text.gif"><br>由于手工修改缓慢，app发送的三个请求都被拦截，相当于app没有收到响应。于是没有显示任何内容在app上<br><img src="/Fiddler-%E6%8A%93%E5%8C%85/20200714121605950.png"><br>在下次访问时，会继续发送请求。这为修改提供了便利  </p></li><li><p>重新发送请求，并快速修改包的内容<br><img src="/Fiddler-%E6%8A%93%E5%8C%85/change_and_send.gif"><br>一顿操作过后，热搜就有了我的名字，虽然这只是在骗自己<br><img src="/Fiddler-%E6%8A%93%E5%8C%85/20200714125355969.png"></p><blockquote><p>若是失败，可以清理app缓存数据（甚至所有数据）来避免app不发送请求而通过缓存加载</p></blockquote></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>抓包</tag>
      
      <tag>Fiddler</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Javascript-基础-函数记录-技巧记录-特性记录</title>
    <link href="/post/b666810f/"/>
    <url>/post/b666810f/</url>
    
    <content type="html"><![CDATA[<h1 id="Javascript基础"><a href="#Javascript基础" class="headerlink" title="Javascript基础"></a>Javascript基础</h1><p>弱类型，函数式编程语言<br><code>JavaScript</code>（简称“JS”） 是一种具有函数优先的轻量级,弱类型，解释型或即时编译型的高级编程语言<br>虽然它是作为开发Web页面的脚本语言而出名的，但是它也被用到了很多非浏览器环境中<br><code>JavaScript</code> 基于原型编程、多范式的动态脚本语言，并且支持面向对象、命令式和声明式（如函数式编程）风格  </p><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><ul><li>前端 React,Vue, Angular</li><li>后端 Node.js</li><li>桌面端 Electron</li><li>物联网 Arduino</li><li>数据库 MongoDO</li><li>移动端 React Native</li></ul><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="Object-对象"><a href="#Object-对象" class="headerlink" title="Object 对象"></a>Object 对象</h3><p>以Key-Value键值对的形式存在的集合<br>Key是String类型，Value可以是任意类型<br>存在深浅拷贝问题</p><h3 id="Array-数组"><a href="#Array-数组" class="headerlink" title="Array 数组"></a>Array 数组</h3><p>实际上也是对象<br>有序排列的集合，值可以是任意类型<br>存在深浅拷贝问题  </p><h4 id="常用语法"><a href="#常用语法" class="headerlink" title="常用语法"></a>常用语法</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs awk">var cars = new Array(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>); <span class="hljs-regexp">//</span> 声明<br>var cars = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]; <span class="hljs-regexp">//</span> 声明<br>cars[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;  <span class="hljs-regexp">//</span> 更改<br>cars.length; <span class="hljs-regexp">//</span> 获取长度<br>cars.push(<span class="hljs-number">4</span>); <span class="hljs-regexp">//</span> 末尾添加<br>cars.splice(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);  <span class="hljs-regexp">//</span> 插入/删除，参数为：插入索引，是否是删除元素（<span class="hljs-number">1</span>为删除，<span class="hljs-number">0</span>为插入）, 插入的元素<br>cars.map(d=&gt;d);  <span class="hljs-regexp">//</span> 遍历并返回新的数组<br>cars.forEach(d=&gt;&#123;一些操作&#125;); <span class="hljs-regexp">//</span> 遍历做操作<br></code></pre></td></tr></table></figure><h3 id="String-字符串"><a href="#String-字符串" class="headerlink" title="String 字符串"></a>String 字符串</h3><p>单双引号都可以  </p><h3 id="Number-数字"><a href="#Number-数字" class="headerlink" title="Number 数字"></a>Number 数字</h3><p>可以是整数也可以是小数  </p><h3 id="Boolean-布尔值"><a href="#Boolean-布尔值" class="headerlink" title="Boolean 布尔值"></a>Boolean 布尔值</h3><p>true/false  </p><h3 id="Map-映射"><a href="#Map-映射" class="headerlink" title="Map 映射"></a>Map 映射</h3><p>以Key-Value键值对的形式存在的集合<br>Key可以是任意类型  </p><h3 id="Set-集合"><a href="#Set-集合" class="headerlink" title="Set 集合"></a>Set 集合</h3><p>相当于不重复的数组  </p><h3 id="null-undefined"><a href="#null-undefined" class="headerlink" title="null/undefined"></a>null/undefined</h3><p>null表示值为空<br>undefined表示未定义，多用于比较不存在的属性或值<br>建议赋值时永远用null而不要用undefined  </p><h2 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h2><ul><li>while  </li><li>for  </li><li>Array  <ul><li>map  </li><li>forEach  </li></ul></li><li>if else  </li></ul><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h3><p>函数声明（带函数名）  </p><ul><li><p>function func_name(params){statement}<br>浏览器会首先将这种函数声明加载进来，因此不用管这个函数定义在哪个位置，都能够调用  </p></li><li><p>const func_name = function(params){statement}<br>若是定义为一个变量，那么要在定义声明以后才能调用函数，否则会报错  </p></li><li><p>(function(param){statement}())<br>匿名函数 (不带函数名)，可以作为一种不错的混淆方式  </p></li></ul><h3 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h3><h4 id="变量定义"><a href="#变量定义" class="headerlink" title="变量定义"></a>变量定义</h4><p>var, const, let定义的变量是有作用域的  </p><ul><li>var 定义的变量在各自的函数内部起作用  </li><li>const, let 定义的变量为块级作用域  </li></ul><h4 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h4><p>js引擎会扫描函数体内的所有语句，并将所有变量声明提升到函数顶部<br>你可以理解为，无论在你在哪里定义，都其实和在第一行那里定义一样  </p><h4 id="全局作用域"><a href="#全局作用域" class="headerlink" title="全局作用域"></a>全局作用域</h4><p>不指定var, const, let 声明变量的时候，变量会被绑定到全局变量window上  </p><h4 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h4><p>let,const将作用在for ,while 等循环语句中，外界不能访问<br>能提升封装程度</p><h3 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h3><p>接受另一个函数作为参数的函数<br>常见用法：回调函数(Callback)，数组操作(filter, sort, map, forEach)</p><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>函数的返回值为函数<br>所有参数和变量都保存在返回函数中<br>当调用返回函数时才执行所有运算逻辑<br>用途: 匿名自执行函数, 封装, 结果缓存</p><h2 id="常用特殊对象"><a href="#常用特殊对象" class="headerlink" title="常用特殊对象"></a>常用特殊对象</h2><h3 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h3><p>  JSON.stringify 序列化<br>  JSON.parse 反序列化  </p><h3 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h3><p>   JS时间操作对象<br>   new Date(dateString)</p><h1 id="Javascript进阶"><a href="#Javascript进阶" class="headerlink" title="Javascript进阶"></a>Javascript进阶</h1><h2 id="事件循环-Event-Loop"><a href="#事件循环-Event-Loop" class="headerlink" title="事件循环  Event Loop"></a>事件循环  Event Loop</h2><h3 id="线程与进程"><a href="#线程与进程" class="headerlink" title="线程与进程"></a>线程与进程</h3><ul><li>进程是cpu资源分配的最小单位（系统会给它分配内存）</li><li>不同的进程之间是可以同学的，如管道、FIFO(命名管道)、消息队列 </li><li>一个进程里有单个或多个线程</li><li>浏览器是多进程的，因为系统给它的进程分配了资源（cpu、内存）（打开Chrome会有一个主进程，每打开一个Tab页就有一个独立的进程）  </li></ul><h3 id="浏览器的渲染进程是多线程的"><a href="#浏览器的渲染进程是多线程的" class="headerlink" title="浏览器的渲染进程是多线程的"></a>浏览器的渲染进程是多线程的</h3><ul><li>GUI渲染线程  </li><li>JS引擎线程  </li><li>事件触发线程  </li><li>定时触发器线程  </li><li>异步HTTP请求线程  </li></ul><h3 id="事件循环机制"><a href="#事件循环机制" class="headerlink" title="事件循环机制"></a>事件循环机制</h3><p>实际上是描述了一些函数处理顺序和过程<br>参考：<a href="https://www.bilibili.com/video/bv1kf4y1U7Ln">https://www.bilibili.com/video/bv1kf4y1U7Ln</a>  </p><h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><h4 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h4><p>现在有1个类A,我想要创建一个类B,这个类是以A为原型的,并且能进行扩展。我们称B的原型为A  </p><h4 id="原型关系"><a href="#原型关系" class="headerlink" title="原型关系"></a>原型关系</h4><p><img src="/Javascript-%E5%9F%BA%E7%A1%80-%E5%87%BD%E6%95%B0%E8%AE%B0%E5%BD%95-%E6%8A%80%E5%B7%A7%E8%AE%B0%E5%BD%95-%E7%89%B9%E6%80%A7%E8%AE%B0%E5%BD%951/20200807110353813.png">  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">A</span>(<span class="hljs-params"></span>) </span>&#123;&#125;<br>A.prototype.name = <span class="hljs-string">&#x27;a&#x27;</span>;<br><span class="hljs-keyword">var</span> a = <span class="hljs-keyword">new</span> A();<br><span class="hljs-built_in">console</span>.log(a.name)<br></code></pre></td></tr></table></figure><ul><li><p>.prototype<br>返回原型对象的引用  </p></li><li><p>__proto__  (实际上是[[prototype]]，不过浏览器里一般都简写)<br>这个属性保存着原型对象的属性  </p><blockquote><p>Object是所有对象的“老祖宗”，所有的__proto__最终都会指向Object，Object本身并没有__proto__属性  </p></blockquote>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">a.__proto__ = A.prototype;<br></code></pre></td></tr></table></figure></li><li><p>constructor<br>A原型的属性，指向A  </p></li></ul><p>参考：<a href="https://www.bilibili.com/video/BV117411v76o">https://www.bilibili.com/video/BV117411v76o</a>  </p><h4 id="原型链-1"><a href="#原型链-1" class="headerlink" title="原型链"></a>原型链</h4><p>参考：<a href="https://www.bilibili.com/video/BV1N7411k7D2">https://www.bilibili.com/video/BV1N7411k7D2</a></p><h2 id="异步编程"><a href="#异步编程" class="headerlink" title="异步编程"></a>异步编程</h2><h3 id="promise"><a href="#promise" class="headerlink" title="promise"></a>promise</h3><p>参考：<a href="https://www.bilibili.com/video/BV15J411G7FG?from=search&amp;seid=7940074723107809573">https://www.bilibili.com/video/BV15J411G7FG?from=search&amp;seid=7940074723107809573</a></p><h3 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h3><p>客户端与不同源服务端的通信  </p><ul><li>CORS<br>跨域资源共享，解决跨域请求的成熟方案  </li><li>JSONP<br>基于<code>&lt;script&gt;</code>标签，具有可跨域特性<br>只能用于GET请求</li><li>iframe<br>通过<code>&lt;iframe&gt;</code>标签在同一个页面暂时不同源的页面<br>通过<code>PostMessage</code>进行页面间的通信  </li><li>反向代理<br>通过反向代理让客户端与服务端保持同步，较为安全  </li></ul><h3 id="Webpack-打包"><a href="#Webpack-打包" class="headerlink" title="Webpack 打包"></a>Webpack 打包</h3><p>目的：将不同类型的源文件编译打包成静态文件</p><ul><li>前端技术纷繁复杂，缺乏统一管理</li><li>大型项目需要模块化  </li><li>对于JSX,TS之类的新技术，需要编译以后才能使用<br>编译器，插件，优化</li></ul><h1 id="函数记录"><a href="#函数记录" class="headerlink" title="函数记录"></a>函数记录</h1><h2 id="setInterval"><a href="#setInterval" class="headerlink" title="setInterval"></a>setInterval</h2><p>方法可按照指定的周期（以毫秒计）来调用函数或计算表达式<br>方法会不停地调用函数，直到 clearInterval() 被调用或窗口被关闭  </p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">setInterval</span>(code, millisec[,<span class="hljs-string">&quot;lang&quot;</span>])<br></code></pre></td></tr></table></figure><ul><li>code     必需。要调用的函数或要执行的代码串</li><li>millisec     必须。周期性执行或调用 code 之间的时间间隔，以毫秒计</li></ul><h2 id="debugger"><a href="#debugger" class="headerlink" title="debugger"></a>debugger</h2><p>语句用于停止执行 JavaScript，并调用 (如果可用) 调试函数<br>反复调用此函数可以达到反调试的目的</p><h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">debugger</span>;<br></code></pre></td></tr></table></figure><h2 id="charCodeAt"><a href="#charCodeAt" class="headerlink" title="charCodeAt()"></a>charCodeAt()</h2><p>charCodeAt() 方法可返回指定位置的字符的 Unicode 编码  这个返回值是 0 - 65535 之间的整数  </p><p>方法 charCodeAt() 与 charAt() 方法执行的操作相似，只不过前者返回的是位于指定位置的字符的编码，而后者返回的是字符子串  </p><h3 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">stringObject.charCodeAt(index)<br></code></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>index</td><td>必需。表示字符串中某个位置的数字，即字符在字符串中的下标。</td></tr></tbody></table><h2 id="exec"><a href="#exec" class="headerlink" title="exec"></a>exec</h2><p>exec() 方法用于检索字符串中的正则表达式的匹配<br>如果字符串中有匹配的值返回该匹配值，否则返回 null  </p><h3 id="语法-3"><a href="#语法-3" class="headerlink" title="语法"></a>语法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">RegExpObject.exec(string)<br></code></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>string</td><td>必需。找寻目标</td></tr></tbody></table><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> str=<span class="hljs-string">&quot;Hello world!&quot;</span>;<br><span class="hljs-comment">//查找&quot;Hello&quot;</span><br><span class="hljs-keyword">var</span> patt=<span class="hljs-regexp">/Hello/g</span>;<br><span class="hljs-keyword">var</span> result=patt.exec(str);<br><span class="hljs-built_in">document</span>.write(<span class="hljs-string">&quot;返回值: &quot;</span> +  result); <br><span class="hljs-comment">//查找 &quot;RUNOOB&quot;</span><br>patt=<span class="hljs-regexp">/RUNOOB/g</span>;<br>result=patt.exec(str);<br><span class="hljs-built_in">document</span>.write(<span class="hljs-string">&quot;&lt;br&gt;返回值: &quot;</span> +  result);<br></code></pre></td></tr></table></figure><h2 id="parseInt"><a href="#parseInt" class="headerlink" title="parseInt"></a>parseInt</h2><p>可解析一个字符串，并返回一个整数  </p><h3 id="语法-4"><a href="#语法-4" class="headerlink" title="语法"></a>语法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">parseInt</span>(string, radix)<br></code></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>string</td><td>必需。要被解析的字符串</td></tr><tr><td>radix</td><td>可选。表示要解析的数字的基数。该值介于 2 ~ 36 之间<br>如果省略该参数或其值为 0，则数字将以 10 为基础来解析。如果它以 “0x” 或 “0X” 开头，将以 16 为基数<br>如果该参数小于 2 或者大于 36，则 parseInt() 将返回 NaN</td></tr></tbody></table><ul><li>只有字符串中的第一个数字会被返回  </li><li>注释：开头和结尾的空格是允许的  </li></ul><h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">parseInt</span>(<span class="hljs-string">&quot;10&quot;</span>);//返回 <span class="hljs-number">10</span><br><span class="hljs-attribute">parseInt</span>(<span class="hljs-string">&quot;19&quot;</span>,<span class="hljs-number">10</span>);//返回 <span class="hljs-number">19</span> (<span class="hljs-number">10</span>+<span class="hljs-number">9</span>)<br><span class="hljs-attribute">parseInt</span>(<span class="hljs-string">&quot;11&quot;</span>,<span class="hljs-number">2</span>);//返回 <span class="hljs-number">3</span> (<span class="hljs-number">2</span>+<span class="hljs-number">1</span>)<br><span class="hljs-attribute">parseInt</span>(<span class="hljs-string">&quot;17&quot;</span>,<span class="hljs-number">8</span>);//返回 <span class="hljs-number">15</span> (<span class="hljs-number">8</span>+<span class="hljs-number">7</span>)<br><span class="hljs-attribute">parseInt</span>(<span class="hljs-string">&quot;1f&quot;</span>,<span class="hljs-number">16</span>);//返回 <span class="hljs-number">31</span> (<span class="hljs-number">16</span>+<span class="hljs-number">15</span>)<br><span class="hljs-attribute">parseInt</span>(<span class="hljs-string">&quot;010&quot;</span>);//未定：返回 <span class="hljs-number">10</span> 或 <span class="hljs-number">8</span><br></code></pre></td></tr></table></figure><h2 id="eval"><a href="#eval" class="headerlink" title="eval"></a>eval</h2><p>eval() 函数可计算某个字符串，并执行其中的的 JavaScript 代码。</p><h3 id="语法-5"><a href="#语法-5" class="headerlink" title="语法"></a>语法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">eval</span>(string)<br></code></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>string</td><td>必需。要计算的字符串，其中含有要计算的 JavaScript 表达式或要执行的语句。</td></tr></tbody></table><h3 id="用例"><a href="#用例" class="headerlink" title="用例"></a>用例</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&gt;&gt;&gt;<span class="hljs-built_in">eval</span>(<span class="hljs-string">&quot;2+2&quot;</span>)<br><span class="hljs-number">4</span><br>&gt;&gt;&gt;<span class="hljs-built_in">eval</span>(<span class="hljs-string">&quot;debugger&quot;</span>)<br>进入调试模式<br></code></pre></td></tr></table></figure><h2 id="defineProperty-amp-defineProperties"><a href="#defineProperty-amp-defineProperties" class="headerlink" title="defineProperty &amp; defineProperties"></a>defineProperty &amp; defineProperties</h2><p><code>Object.defineProperties</code>或者<code>Object.defineProperty</code>方法，它可以直接在一个对象上修改原有属性或者定义新的属性  </p><h3 id="语法-6"><a href="#语法-6" class="headerlink" title="语法"></a>语法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Object</span>.defineProperty(obj, prop, descriptor)<br><span class="hljs-built_in">Object</span>.defineProperties(obj, props)<br></code></pre></td></tr></table></figure><table><thead><tr><th>defineProperty 参数</th><th>信息</th></tr></thead><tbody><tr><td>obj</td><td>将要被添加属性或修改属性的对象</td></tr><tr><td>prop</td><td>目标对象需要定义或修改的属性的名称</td></tr><tr><td>descriptor</td><td>将被定义或修改的属性的描述符</td></tr></tbody></table><table><thead><tr><th>defineProperties 参数</th><th>信息</th></tr></thead><tbody><tr><td>obj</td><td>将要被添加属性或修改属性的对象</td></tr><tr><td>props</td><td>该对象的一个或多个键值对定义了将要为对象添加或修改的属性的具体配置</td></tr></tbody></table><h3 id="用例-1"><a href="#用例-1" class="headerlink" title="用例"></a>用例</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>();<br><span class="hljs-built_in">Object</span>.defineProperties(obj, &#123;<br>    name: &#123;<br>        value: <span class="hljs-string">&#x27;JS Hook&#x27;</span>,<br>        configurable: <span class="hljs-literal">false</span>,<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>只要对象生成之后，我们就可以Hook。</p><p>比如下边的Hook，会在每次设置对象参数的时候debugger</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>();<br><span class="hljs-built_in">Object</span>.defineProperty(obj, <span class="hljs-string">&#x27;name&#x27;</span>, &#123;<br>    set:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">x</span>)</span>&#123;<span class="hljs-keyword">debugger</span>;<span class="hljs-keyword">return</span> x;&#125;<span class="hljs-comment">//被赋值后断下来</span><br>&#125;)<br>obj.a<br></code></pre></td></tr></table></figure><p>然后让代码开始运行，就会看到cookie被打印在控制台了。<br>如果要查看cookie在哪里被定义，可以写入debugger。<br>如果要查看特定的cookie，可以在里边使用indexOf指定参数名字</p><hr><p>参考：</p><ul><li><a href="https://www.jianshu.com/p/667a20d008cf">https://www.jianshu.com/p/667a20d008cf</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Javascript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Javascript-Hook-基础</title>
    <link href="/post/da48434/"/>
    <url>/post/da48434/</url>
    
    <content type="html"><![CDATA[<h1 id="Hook原理"><a href="#Hook原理" class="headerlink" title="Hook原理"></a>Hook原理</h1><p>假设我们现在有这样一个JS代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params">aa,bb</span>)</span>&#123;<br>cc = aa + bb;<br>        <span class="hljs-keyword">return</span>  cc;<br>&#125;<br>test(<span class="hljs-number">100</span>,<span class="hljs-number">200</span>);<br></code></pre></td></tr></table></figure><p>我们在console中可以修改这个函数，比还有其它的方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> _setInterval=<span class="hljs-built_in">setInterval</span>;<br><span class="hljs-built_in">setInterval</span>=<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a,b</span>)</span>&#123;<br><span class="hljs-keyword">if</span>(a.toString().indexOf(<span class="hljs-string">&quot;debugger&quot;</span>)!=-<span class="hljs-number">1</span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br>_setInterval(a,b);<br>&#125;<br>~~~如让它打印各个参数的输出结果，这就是一个JS Hook<br>~~~javascript<br><span class="hljs-keyword">var</span> _test=test;<br>test=<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">aa,bb</span>)</span>&#123;<br><span class="hljs-built_in">console</span>.log(aa);<br><span class="hljs-built_in">console</span>.log(bb);<br><span class="hljs-keyword">var</span> result=_test(aa,bb);<br><span class="hljs-built_in">console</span>(result);<br></code></pre></td></tr></table></figure><p>这个函数的注入时机是在函数调用之后，页面加载完毕才注入。但实际上可以在调用地方下断点，在它运行的时候注入JS Hook，在函数被调用之前就进行修改，这也是可以的。</p><p>JS Hook看起来是很简单的，不过我们能够用它来实现很强大的功能，比如修改一些系统函数，如debugger，Function，eval等，这些都是和反调试相关的。</p><p>我们日常拿到的许多数据都是JSON，所以也可以HookJSON.stringfy进行一些操作，这样一来我们就可以在Hook后直接从堆栈中找到调用函数了。</p><p>读者应该已经发现，无论如何Hook，我们总是要把自己的代码注入到网页的环境里边，这个注入的时机选择很重要。<br>可以选择下断点的方式注入，但是有一种更为优雅的方法，那就是编写Chrome拓展插件，插件可以在网页运行之前就对系统函数进行Hook，一些网页的反调试就可以直接步过了</p><h1 id="Hook简单案例"><a href="#Hook简单案例" class="headerlink" title="Hook简单案例"></a>Hook简单案例</h1><p>JS Hook是比较容易实现的，但是对网站的破坏性却比较大<br>所以有些网站会有JS Hook的检测，最常见的就是比对关键函数前后的JS文本，如果不一致就进入循环debugger  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params">x,y</span>)</span>&#123;z=x+y;<span class="hljs-keyword">return</span> z;&#125;<br><span class="hljs-built_in">setInterval</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;test+<span class="hljs-string">&quot;&quot;</span>==<span class="hljs-string">&quot;function test(x,y)&#123;z=x+y;return z;&#125;&quot;</span> ? <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;未修改&quot;</span>) :<span class="hljs-built_in">setInterval</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<span class="hljs-built_in">eval</span>(<span class="hljs-string">&quot;debugger&quot;</span>)&#125;,<span class="hljs-number">1000</span>);&#125;,<span class="hljs-number">1000</span>);<br>test(<span class="hljs-number">100</span>,<span class="hljs-number">200</span>);<br><span class="hljs-comment">// 这里得到的结果会是 300</span><br></code></pre></td></tr></table></figure><ul><li><a href="#">Post not found: js-函数记录-技巧记录-特性记录 setInterval</a></li><li><a href="#">Post not found: js-函数记录-技巧记录-特性记录 eval</a></li></ul><p>将函数与””相加会使得函数调用toString方法，返回函数自身的字符串类型代码，在通过预设的校验代码就能知道函数是否被修改过。</p><p>想要过掉这种Hook检测，可以修改函数返回的字符串，就能使得检验通过</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params">x,y</span>)</span>&#123;z=x+y;<span class="hljs-keyword">return</span> z;&#125;<br><span class="hljs-comment">// 注入</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params">x,y</span>)</span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello world&quot;</span>;&#125;<br><span class="hljs-comment">// 修改toString使得转字符串与原来的结果相同，避免被反调试</span><br>test.toString=<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;function test(x,y)&#123;z=x+y;return z;&#125;&quot;</span>;&#125;;<br><span class="hljs-built_in">setInterval</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;test+<span class="hljs-string">&quot;&quot;</span>==<span class="hljs-string">&quot;function test(x,y)&#123;z=x+y;return z;&#125;&quot;</span> ? <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;未修改&quot;</span>) :<span class="hljs-built_in">setInterval</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<span class="hljs-built_in">eval</span>(<span class="hljs-string">&quot;debugger&quot;</span>)&#125;,<span class="hljs-number">1000</span>);&#125;,<span class="hljs-number">1000</span>);<br>test(<span class="hljs-number">100</span>,<span class="hljs-number">200</span>);<br><span class="hljs-comment">// 这里得到的结果会是 Hello world</span><br></code></pre></td></tr></table></figure><p>当然，还有其它的方法可以解决</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> _setInterval=<span class="hljs-built_in">setInterval</span>;<br><span class="hljs-built_in">setInterval</span>=<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a,b</span>)</span>&#123;<br><span class="hljs-keyword">if</span>(a.toString().indexOf(<span class="hljs-string">&quot;debugger&quot;</span>)!=-<span class="hljs-number">1</span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br>_setInterval(a,b);<br>&#125;<br></code></pre></td></tr></table></figure><p>这样做相当于在执行setInterval函数前检查了函数是否有debugger；有就不执行setInterval函数  </p><h2 id="Hook对象属性"><a href="#Hook对象属性" class="headerlink" title="Hook对象属性"></a>Hook对象属性</h2><p>我们要想Hook对象属性，需要用到<code>Object.defineProperties</code>或者<code>Object.defineProperty</code>方法，它可以直接在一个对象上修改原有属性或者定义新的属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>();<br><span class="hljs-built_in">Object</span>.defineProperties(obj, &#123;<br>    name: &#123;<br>        value: <span class="hljs-string">&#x27;JS Hook&#x27;</span>,<br>        configurable: <span class="hljs-literal">false</span>,<br>    &#125;,<br>    age: &#123;<br>        value: <span class="hljs-number">18</span>,<br>    &#125;<br>&#125;)<br><span class="hljs-built_in">Object</span>.defineProperty(obj, <span class="hljs-string">&#x27;name&#x27;</span>, &#123;<br>    value: <span class="hljs-string">&#x27;hello&#x27;</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>obj对象定义了name属性和age属性，其中name属性定义了不能修改<br>在下面尝试去修改name属性的时候，会报错<br><img src="/Javascript-Hook-%E5%9F%BA%E7%A1%80/20200712034338306.png"></p><p>只要对象生成之后，我们就可以Hook<br>比如下边的Hook，会在每次设置对象参数的时候debugger（虽然这样做完以后，这个值就不会赋成功了）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>();<br><span class="hljs-built_in">Object</span>.defineProperty(obj, <span class="hljs-string">&#x27;name&#x27;</span>, &#123;<br>    set:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">x</span>)</span>&#123;<span class="hljs-keyword">debugger</span>;<span class="hljs-keyword">return</span> x;&#125;<span class="hljs-comment">//被赋值后断下来</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>对于内置对象属性的Hook，需要在文档加载之前Hook，这时候就需要用到Chrome拓展插件了。<br>比如document.cookie中的各种cookies，<br>要想知道cookies是从哪里生成的，使用Chrome拓展是很方便的，如果要使用断点调试可能比较麻烦一点，我们可以在JS文件头部下断点，在console里边输入如下代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Object</span>.defineProperty(<span class="hljs-built_in">document</span>,<span class="hljs-string">&quot;cookie&quot;</span>,&#123;<span class="hljs-attr">set</span>:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">x</span>)</span>&#123;<span class="hljs-built_in">console</span>.log(x);<span class="hljs-keyword">return</span> x;&#125;&#125;)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>javascript</tag>
      
      <tag>Hook</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DevTools-Chrome开发者工具</title>
    <link href="/post/4c8db11a/"/>
    <url>/post/4c8db11a/</url>
    
    <content type="html"><![CDATA[<blockquote><p>人人都说Chrome好用，也许我应该放弃Firefox来用用看。  </p></blockquote><h1 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a>官方文档</h1><p><a href="https://developers.google.com/web/tools/chrome-devtools/">https://developers.google.com/web/tools/chrome-devtools/</a>  </p><h1 id="开发者工具基础"><a href="#开发者工具基础" class="headerlink" title="开发者工具基础"></a>开发者工具基础</h1><h2 id="打开开发者工具"><a href="#打开开发者工具" class="headerlink" title="打开开发者工具"></a>打开开发者工具</h2><p>因为要调试前端的JS文本，和控制台交互是必不可少的，而且不少网站会在这上边做文章，比如说禁止你的F12或者右键点击等等<br>Chrome控制台打开方法总结：  </p><ul><li>F12；</li><li>CTRL+SHIFT+I；</li><li>在页面右键点击检查；</li><li>浏览器——&gt;更多工具——&gt;开发者工具；</li><li>打开一个空白页面，打开开发者工具，再切换回去要调试的页面；</li></ul><h2 id="调整开发工具位置"><a href="#调整开发工具位置" class="headerlink" title="调整开发工具位置"></a>调整开发工具位置</h2><p>最右边三个点的地方点开，可以调整工具对应浏览器的位置<br><img src="/Chrome%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7/20200708112826512.png">  </p><h2 id="面板简介"><a href="#面板简介" class="headerlink" title="面板简介"></a>面板简介</h2><table><thead><tr><th>面板</th><th>信息</th></tr></thead><tbody><tr><td>Elements元素面板</td><td>检查和调整页面，调试DOM和CSS</td></tr><tr><td>Network网络面板</td><td>调试请求，了解页面静态资源分布，网页性能检测</td></tr><tr><td>Console控制台面板</td><td>调试JavaScript，查看日志，交互式代码调试</td></tr><tr><td>Sources源代码资源面板</td><td>调试JavaScript页面源代码，进行断点调试</td></tr><tr><td>Application应用面板</td><td>查看和调试客户端存储，如Cookie、LocalStorage、SessionStorage</td></tr><tr><td>Performance性能面板</td><td>查看页面性能细节，细粒度对网页载入进行性能优化</td></tr><tr><td>Memory内存面板</td><td>JavaScript CPU分析器，内存堆分析器</td></tr><tr><td>Security安全面板</td><td>查看页面安全及证书问题</td></tr><tr><td>Audis面板</td><td>使用Google Lighthouse辅助性能分析，给出优化建议</td></tr></tbody></table><h2 id="Elements元素面板"><a href="#Elements元素面板" class="headerlink" title="Elements元素面板"></a>Elements元素面板</h2><p>一般来说，我们切换到元素面板，它的所有HTML节点都是闭合的<br>可以选中任意元素，右键点击<code>Expand recursively</code>将其下的所有节点展开。<br>在元素面板里看到的页面源代码其实并非原始代码，而是CSS、HTML、JS综合得到的一个结果。<br>如果想要获取页面源代码，有两种方式：  </p><ul><li>切换到资源Sources面板，选择左边的index文件  </li><li>右键点击查看网页源代码，或快捷键CTRL+U  </li></ul><p><img src="/Chrome%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7/20200708122431758.png"></p><h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><h3 id="隐藏页面元素"><a href="#隐藏页面元素" class="headerlink" title="隐藏页面元素"></a>隐藏页面元素</h3><p>在元素面板定位到特定元素后按下<code>H</code><br>在相同位置再次按<code>H</code>则会将隐藏的元素显示出来  </p><h3 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h3><p><code>CTRL+C</code>  <code>CTRL+V</code><br>也可以选择某个元素后按右键<br><img src="/Chrome%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7/20200708012404908.png">  </p><h3 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h3><p><code>CTRL+Z</code>  </p><h3 id="为元素添加属性"><a href="#为元素添加属性" class="headerlink" title="为元素添加属性"></a>为元素添加属性</h3><p>在元素上右键点击<code>Add attribute</code><br>比如倒计时抓包实际上就是把元素的CSS进行微型修改，我们把进入状态改成激活状态，就能达到抓包效果  </p><h3 id="搜索元素-amp-通过-xpath-css选择器-bs4-获取指定元素"><a href="#搜索元素-amp-通过-xpath-css选择器-bs4-获取指定元素" class="headerlink" title="搜索元素 &amp; 通过 xpath/css选择器/bs4 获取指定元素"></a>搜索元素 &amp; 通过 xpath/css选择器/bs4 获取指定元素</h3><p><code>CTRL+F</code><br>下方会弹出一个编写框，可以在里边填写页面元素，也可以编写CSS选择器/XPATH语法/bs4<br><img src="/Chrome%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7/20200708013737876.png">  </p><h3 id="Event-Listeners选项卡"><a href="#Event-Listeners选项卡" class="headerlink" title="Event Listeners选项卡"></a><code>Event Listeners</code>选项卡</h3><p><img src="/Chrome%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7/20200708011144067.png"><br>在一个元素的右边，我们可以看到一个<code>Event Listeners</code>选项卡<br>这里边是元素绑定的事件，但是这个事件绑定并非很准确  </p><h3 id="DOM断点"><a href="#DOM断点" class="headerlink" title="DOM断点"></a>DOM断点</h3><p>右键点击元素会看到<code>Break on</code>中包含三种断点，分别是子树修改/属性变化/节点被移除时候触发的断点<br>任意选择一个，会在Sources面板的DOM breakpoints里边多出一个断点记录<br><img src="/Chrome%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7/20200708014531683.png">  </p><h2 id="Console控制台面板"><a href="#Console控制台面板" class="headerlink" title="Console控制台面板"></a><code>Console</code>控制台面板</h2><p>你可以在可以在<code>元素面板</code>里边选中某个元素，在控制台里,<code>$0</code>当前选中的节点的引用，<code>$1</code>是对上一次我们选择的节点的引用，一直可以回溯到<code>$4</code><br>实际上就是一个js控制台。想输入代码，调用函数都可以来这里输入  </p><h3 id="有用的函数"><a href="#有用的函数" class="headerlink" title="有用的函数"></a>有用的函数</h3><h4 id="Console-table"><a href="#Console-table" class="headerlink" title="Console.table"></a>Console.table</h4><p><img src="/Chrome%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7/20200809031430212.png">  </p><h4 id="Copy"><a href="#Copy" class="headerlink" title="Copy"></a>Copy</h4><p>作为参数的内容会被弄到系统粘贴面板里，你可以在其它地方粘贴  </p><h4 id=""><a href="#" class="headerlink" title="$_"></a>$_</h4><p>返回最后一次计算的值  </p><h2 id="Sources源代码面板"><a href="#Sources源代码面板" class="headerlink" title="Sources源代码面板"></a><code>Sources</code>源代码面板</h2><h3 id="Page选项卡"><a href="#Page选项卡" class="headerlink" title="Page选项卡"></a><code>Page</code>选项卡</h3><p>放置了网站的资源html、js、css等<br><img src="/Chrome%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7/20200708071247845.png">  </p><h3 id="Overrides"><a href="#Overrides" class="headerlink" title="Overrides"></a><code>Overrides</code></h3><p>本地代理，能将一些资源保存到这里，然后再次请求网页相同资源的时候会在这里找文件来覆盖原网页<br>可用于前端编辑  </p><h3 id="Snippets选项卡"><a href="#Snippets选项卡" class="headerlink" title="Snippets选项卡"></a><code>Snippets</code>选项卡</h3><p>一个代码片段工具<br>新建一个snippet，在里边存放编辑的JS代码<br><img src="/Chrome%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7/20200708071741288.png"><br>这样就可以在<code>console</code>里边使用我们自己的JS代码，比如一些<code>Base64</code>的基本转化或者<code>CryptoJS</code>等，我们就可以直接调用里边的函数了<br>在写完以后，可以在下面点运行，打开控制台进行调试  </p><h3 id="格式化代码"><a href="#格式化代码" class="headerlink" title="格式化代码"></a>格式化代码</h3><p><img src="/Chrome%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7/20200709124357335.png"></p><h2 id="Network网络面板"><a href="#Network网络面板" class="headerlink" title="Network网络面板"></a><code>Network</code>网络面板</h2><p>网络面板主要是抓取网页数据包<br><img src="/Chrome%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7/20200708072207405.png"><br>可以在Filter中对数据包进行过滤  </p><h3 id="禁用缓存"><a href="#禁用缓存" class="headerlink" title="禁用缓存"></a>禁用缓存</h3><p><img src="/Chrome%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7/20200709123519953.png">  </p><h3 id="查找请求源"><a href="#查找请求源" class="headerlink" title="查找请求源"></a>查找请求源</h3><p><img src="/Chrome%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7/20200809022858499.png"><br>单击内容会打开到目标  </p><h3 id="查看依赖关系"><a href="#查看依赖关系" class="headerlink" title="查看依赖关系"></a>查看依赖关系</h3><p><img src="/Chrome%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7/20200809023213587.png"><br>按住键盘shift键，在包上移动会发现一些颜色变化<br>绿色表示当前包的发起者<br>红色表示当前包依赖于谁  </p><h2 id="Application应用面板"><a href="#Application应用面板" class="headerlink" title="Application应用面板"></a><code>Application</code>应用面板</h2><p>可以在其中的Storage中看待当前页面在数据库中存储了哪些数据<br>里边的Cookies等元素也是可以编辑的<br><img src="/Chrome%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7/20200708072416038.png">  </p><h2 id="Settings设置面板"><a href="#Settings设置面板" class="headerlink" title="Settings设置面板"></a><code>Settings</code>设置面板</h2><p><img src="/Chrome%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7/20200708072637490.png"><br>可以勾选其中Console里的Log XMLHttpRequests，这是一个AJAXHook，当我们发起一个请求它会直接帮我们输出出来  </p><h1 id="Chorme调试技巧"><a href="#Chorme调试技巧" class="headerlink" title="Chorme调试技巧"></a>Chorme调试技巧</h1><h2 id="断点"><a href="#断点" class="headerlink" title="断点"></a>断点</h2><p>任意点击一个堆栈信息进去们可以在<code>Sources面板</code>之中点击序号栏下断点<br>然后点击页面上的例如登录按钮让它触发事件，我们配合右边的<code>Call Stack</code>去查看我们的关键信息到底在什么地方  </p><p><img src="/Chrome%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7/20200708112240558.png"><br>在<code>Elements面板</code>找到登录按钮,记录一些元素和属性信息<br>到Sources面板里找到对应位置<br>断点类型有很多种：  </p><ul><li><p><code>XHR断点</code><br>可以复制一下XHR包的URL（全部或部分），在Sources面板中新建<code>XHR Breakpoints</code>就可以在发起网页这个XHR请求的时候断点  <img src="/Chrome%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7/20200708114603831.png"></p></li><li><p><code>Event Listener 下一个事件断点</code><br>比较常用的是<code>Mouse</code>里边的<code>click断点</code>，因为我们要抓的许多加密参数包是点击按钮后才会触发的<br><img src="/Chrome%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7/20200708114854674.png">  </p></li><li><p>无差别断点<br>直接点击相应的序号栏即可<br><img src="/Chrome%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7/20200708115834789.png">  </p></li><li><p><code>Contional Breakpoint</code> 条件断点<br>当你输入的表达式结果为真就会进行断点</p><ul><li><p>比如<code>password==&#39;123&#39;</code><br>当我们输入的密码是123的时候就会进行断点。这个通常用于有循环的情况，我们只需要查看最后一次结果，这样就可以避免一步步调试进入循环  </p></li><li><p>可以直接输入<code>console.log(password)</code><br>这样虽然不会断下来，但是会有一个输出。这相当于一个console暗桩<br>这样即便是页面一开始加载的参数我们也可以得知，而且避免了断点卡顿。这种断点通常用于滑块验证码，滑块轨迹的每一次输出我们不可能每次移动一次让它卡顿一次，使用console暗桩就可以得到一个打印输出的效果</p></li></ul></li></ul><p>这里的事件断点通常会断在一开始的HTML页面，我们可以一步步深入去了解事件加密。</p><h2 id="监听"><a href="#监听" class="headerlink" title="监听"></a>监听</h2><h3 id="监听函数"><a href="#监听函数" class="headerlink" title="监听函数"></a>监听函数</h3><p><code>monitorEvents()</code>监听某一类型的事件<br><code>monitorEvents</code>的第一个参数是要监听的对象。如果未提供第二个参数，所有事件都会返回。要指定要监听的事件，传递一个字符串或字符串数组作为第二个参数  </p><ul><li>例子：监听页面body上的点击事件：<br><code>monitorEvents(document.body, &quot;click&quot;);</code><br>  当然，获取元素的方式可以不用js原生的  </li></ul><h3 id="取消监听函数"><a href="#取消监听函数" class="headerlink" title="取消监听函数"></a>取消监听函数</h3><p><code>unmonitorEvents()</code>停止监听<br>要停止监听事件，请调用<code>unmonitorEvents()</code>方法,传递一个停止监视对象的参数  </p><ul><li>例子：停止监听body对象上的事件：<br><code>unmonitorEvents(document.body);</code>  </li></ul><h3 id="监听变量"><a href="#监听变量" class="headerlink" title="监听变量"></a>监听变量</h3><p>使用watch还可以监听变量<br>在Sources面板中有watch栏目，里边可以监听变量何时变化。<br><img src="/Chrome%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7/20200709125418645.png"><br>比如我们可以添加password加密参数，在断点的配合下一步步深入，直到password数值改变，我们就可以定位到具体的JS加密地点。</p><h1 id="小技巧-骚操作"><a href="#小技巧-骚操作" class="headerlink" title="小技巧/骚操作"></a>小技巧/骚操作</h1><h2 id="生成python爬虫代码"><a href="#生成python爬虫代码" class="headerlink" title="生成python爬虫代码"></a>生成python爬虫代码</h2><ol><li>找到目标数据包复制Curl<br><img src="/Chrome%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7/20200809022140280.png"></li><li>把Curl导入到postman<br><img src="/Chrome%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7/20200809022329199.png"><br><img src="/Chrome%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7/20200809022358410.png"></li><li>postman 导出目标代码<br><img src="/Chrome%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7/20200809022515060.png"></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Chrome</tag>
      
      <tag>DevTools</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CentOS-python</title>
    <link href="/post/233c4197/"/>
    <url>/post/233c4197/</url>
    
    <content type="html"><![CDATA[<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><ol><li><p>安装必要工具 yum-utils<br>功能是管理repository及扩展包的工具 (主要是针对repository)  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo yum install yum-utils<br></code></pre></td></tr></table></figure></li><li><p>使用yum-builddep为Python3构建环境<br>缺失的软件依赖会自动处理  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo yum-builddep python<br></code></pre></td></tr></table></figure></li><li><p>下载源码包  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -O https://www.python.org/ftp/python/3.5.0/Python-3.5.0.tgz<br></code></pre></td></tr></table></figure><p> 要啥版本下啥版本  </p></li><li><p>解压源码包并进入压文件夹</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">tar xf Python-3.5.0.tgz&gt; 3.7版本需要一个新的包libffi-devel，安装此包之后再次进行编译安装即可。<br><span class="hljs-built_in">cd</span> Python-3.5.0<br></code></pre></td></tr></table></figure></li><li><p>编译，执行，安装</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gauss">./configure  <br><span class="hljs-built_in">make</span>  <br>sudo <span class="hljs-built_in">make</span> install  <br></code></pre></td></tr></table></figure><blockquote><p>关于<code>ModuleNotFoundError: No module named &#39;_ctypes&#39;</code><br>python3.7版本需要一个新的包<code>libffi-devel</code><br>安装此包之后再次进行编译安装即可  </p></blockquote><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">yum <span class="hljs-keyword">install</span> libffi-devel -y<br></code></pre></td></tr></table></figure><blockquote><p>python3中有个内置模块叫<code>ctypes</code>，它是python3的外部函数库模块，提供了兼容C语言的数据类型，并通过它调用Linux系统下的共享库(Shared library)，此模块需要使用centos7系统中外部函数库(Foreign function library)的开发链接库(头文件和链接库)<br>由于在centos7系统中没有安装外部函数库(libffi)的开发链接库软件包，所以在安装pip的时候就报了<code>ModuleNotFoundError: No module named &#39;_ctypes&#39;</code>的错误  </p></blockquote></li><li><p>测试安装  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">python3<br></code></pre></td></tr></table></figure><p>进入python shell，并看到是目标版本，则表示成功  </p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>CentOS</tag>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python-函数记录-技巧记录-特性记录</title>
    <link href="/post/99a302d5/"/>
    <url>/post/99a302d5/</url>
    
    <content type="html"><![CDATA[<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="sorted"><a href="#sorted" class="headerlink" title="sorted"></a>sorted</h2><h3 id="函数说明"><a href="#函数说明" class="headerlink" title="函数说明"></a>函数说明</h3><p><code>sorted(iterable, key=None, reverse=False)</code></p><table><thead><tr><th>参数</th><th>参数说明</th></tr></thead><tbody><tr><td>iterable</td><td>可迭代对象</td></tr><tr><td>key</td><td>主要是用来进行比较的元素，只有一个参数，具体的函数的参数就是取自于可迭代对象中，指定可迭代对象中的一个元素来进行排序。</td></tr><tr><td>reverse</td><td>排序规则<br>reverse = True 降序<br>reverse = False 升序（默认）</td></tr></tbody></table><h3 id="用例"><a href="#用例" class="headerlink" title="用例"></a>用例</h3><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">&gt;&gt;&gt;sorted(<span class="hljs-string">[5, 2, 3, 1, 4]</span>)<br><span class="hljs-string">[1, 2, 3, 4, 5]</span>                      # 默认为升序<br></code></pre></td></tr></table></figure><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sas">&gt;&gt;&gt;<span class="hljs-meta">array</span> = [&#123;<span class="hljs-string">&quot;age&quot;</span>:20,<span class="hljs-string">&quot;name&quot;</span>:<span class="hljs-string">&quot;a&quot;</span>&#125;,&#123;<span class="hljs-string">&quot;age&quot;</span>:25,<span class="hljs-string">&quot;name&quot;</span>:<span class="hljs-string">&quot;b&quot;</span>&#125;,&#123;<span class="hljs-string">&quot;age&quot;</span>:10,<span class="hljs-string">&quot;name&quot;</span>:<span class="hljs-string">&quot;c&quot;</span>&#125;]<br>&gt;&gt;&gt;<span class="hljs-meta">array</span> = sorted(<span class="hljs-meta">array</span>,<span class="hljs-meta">key</span>=lambda <span class="hljs-meta">x</span>:<span class="hljs-meta">x</span>[<span class="hljs-string">&quot;age&quot;</span>])<br>&gt;&gt;&gt;p<span class="hljs-meta">rint(</span><span class="hljs-meta">array</span>)<br>[&#123;<span class="hljs-string">&#x27;age&#x27;</span>: 10, <span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;c&#x27;</span>&#125;, &#123;<span class="hljs-string">&#x27;age&#x27;</span>: 20, <span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;a&#x27;</span>&#125;, &#123;<span class="hljs-string">&#x27;age&#x27;</span>: 25, <span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;b&#x27;</span>&#125;]<br></code></pre></td></tr></table></figure><h2 id="zip"><a href="#zip" class="headerlink" title="zip"></a>zip</h2><h3 id="函数说明-1"><a href="#函数说明-1" class="headerlink" title="函数说明"></a>函数说明</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">zip</span>([iterable, ...])<br></code></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>参数说明</th></tr></thead><tbody><tr><td>iterable</td><td>可迭代对象</td></tr></tbody></table><p>zip() 函数用于将可迭代的对象作为参数，将对象中对应的元素打包成一个个元组，然后返回由这些元组组成的列表。</p><p>如果各个迭代器的元素个数不一致，则返回列表长度与最短的对象相同，利用 * 号操作符，可以将元组解压为列表。</p><h3 id="用例-1"><a href="#用例-1" class="headerlink" title="用例"></a>用例</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">&gt;&gt;&gt;a = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br>&gt;&gt;&gt;b = [<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]<br>&gt;&gt;&gt;c = [<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>zipped = <span class="hljs-built_in">zip</span>(a,b)     <span class="hljs-comment"># 打包为元组的列表</span><br>[(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>), (<span class="hljs-number">2</span>, <span class="hljs-number">5</span>), (<span class="hljs-number">3</span>, <span class="hljs-number">6</span>)]<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">zip</span>(a,c)              <span class="hljs-comment"># 元素个数与最短的列表一致</span><br>[(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>), (<span class="hljs-number">2</span>, <span class="hljs-number">5</span>), (<span class="hljs-number">3</span>, <span class="hljs-number">6</span>)]<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">zip</span>(*zipped)          <span class="hljs-comment"># 与 zip 相反，*zipped 可理解为解压，返回二维矩阵式</span><br>[(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>), (<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>)]<br></code></pre></td></tr></table></figure><h1 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h1><h2 id="生成式"><a href="#生成式" class="headerlink" title="生成式"></a>生成式</h2><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><blockquote><p>案例：遍历生成新数据  </p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">&gt;&gt;&gt;a = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]<br>&gt;&gt;&gt;[i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> a]<br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]<br></code></pre></td></tr></table></figure><p><span></span></p><blockquote><p>案例：遍历计算生成新数据  </p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">&gt;&gt;&gt;a = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]<br>&gt;&gt;&gt;[i+<span class="hljs-number">2</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> a]<br>[<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>]<br></code></pre></td></tr></table></figure><h3 id="带判断"><a href="#带判断" class="headerlink" title="带判断"></a>带判断</h3><p>注意：判断在执行计算之前，如果判断为False，则不进入计算流程，直接忽略    </p><blockquote><p>案例：遍历判断计算生成新数据  </p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">&gt;&gt;&gt;[i+<span class="hljs-number">2</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> a <span class="hljs-keyword">if</span> i!=<span class="hljs-number">2</span>]<br>[<span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>]<br></code></pre></td></tr></table></figure><h3 id="双生"><a href="#双生" class="headerlink" title="双生"></a>双生</h3><blockquote><p>案例：遍历两个list，计算生成新数据</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>a, b = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>], [<span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>[x+y <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> a <span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> b]<br>[<span class="hljs-string">&#x27;ac&#x27;</span>, <span class="hljs-string">&#x27;ad&#x27;</span>, <span class="hljs-string">&#x27;bc&#x27;</span>, <span class="hljs-string">&#x27;bd&#x27;</span>]<br></code></pre></td></tr></table></figure><p><span></span></p><blockquote><p>案例：遍历两个list，进行判断计算生成新数据</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>a, b = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>], [<span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;f&#x27;</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>[x+y <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> a <span class="hljs-keyword">if</span> x!=<span class="hljs-string">&#x27;b&#x27;</span> <span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> b <span class="hljs-keyword">if</span> y!=<span class="hljs-string">&#x27;e&#x27;</span>]<br>[<span class="hljs-string">&#x27;ad&#x27;</span>, <span class="hljs-string">&#x27;af&#x27;</span>, <span class="hljs-string">&#x27;cd&#x27;</span>, <span class="hljs-string">&#x27;cf&#x27;</span>]<br></code></pre></td></tr></table></figure><h2 id="更美观的print"><a href="#更美观的print" class="headerlink" title="更美观的print"></a>更美观的print</h2><h3 id="使用format"><a href="#使用format" class="headerlink" title="使用format"></a>使用format</h3><p>使用format函数能让print函数看上去更美观，同时不会出现需要转换类型的问题  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">name = <span class="hljs-string">&#x27;Rem&#x27;</span><br>country = <span class="hljs-string">&#x27;China&#x27;</span><br>print(<span class="hljs-string">&quot;Hi, I&#x27;m &#123;&#125; from &#123;&#125;. &#123;1&#125; &#123;0&#125;&quot;</span>,<span class="hljs-built_in">format</span>(name,country))<br><span class="hljs-meta">&gt;&gt;&gt; </span>Hi, I<span class="hljs-string">&#x27;m Rem from China. China Rem</span><br></code></pre></td></tr></table></figure><h2 id="更好的遍历"><a href="#更好的遍历" class="headerlink" title="更好的遍历"></a>更好的遍历</h2><h3 id="使用enumerate"><a href="#使用enumerate" class="headerlink" title="使用enumerate"></a>使用enumerate</h3><p>如果你希望遍历元素，又不希望使用变量计算索引，可以试试enumerate</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">a = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>]<br><span class="hljs-keyword">for</span> i, x <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(a):<br>    print(i, x)<br>&gt;&gt;&gt;<span class="hljs-number">0</span> a<br>&gt;&gt;&gt;<span class="hljs-number">1</span> b<br>&gt;&gt;&gt;<span class="hljs-number">2</span> c<br></code></pre></td></tr></table></figure><h3 id="使用-表达式"><a href="#使用-表达式" class="headerlink" title="使用{}表达式"></a>使用{}表达式</h3><p>python3.6以上才有的特性</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">name = <span class="hljs-string">&#x27;Rem&#x27;</span><br>country = <span class="hljs-string">&#x27;China&#x27;</span><br>age = <span class="hljs-number">18</span><br>print(<span class="hljs-string">&quot;Hi, I&#x27;m &#123;name&#125; from &#123;country&#125;. &#123;age-2&#125; years old&quot;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>Hi, I<span class="hljs-string">&#x27;m Rem from China. 16 years old</span><br></code></pre></td></tr></table></figure><h3 id="eval-与-json-loads"><a href="#eval-与-json-loads" class="headerlink" title="eval() 与 json.loads()"></a>eval() 与 json.loads()</h3><p><code>eval()</code>能计算表达式，也能将<code>str</code>转为 <code>python</code>对象<br><code>json.loads()</code>能将str转为 <code>python</code>对象<br>如果只是将写着<code>JSON</code>内容的字符串转为<code>python</code>对象，那么<code>json.loads()</code>的转换速度比<code>eval()</code>大概快十倍  </p><h1 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h1><h2 id="Python的GIL"><a href="#Python的GIL" class="headerlink" title="Python的GIL"></a>Python的GIL</h2><h3 id="GIL是什么"><a href="#GIL是什么" class="headerlink" title="GIL是什么"></a>GIL是什么</h3><p>GIL全称Global Interpreter Lock<br>GIL并不是Python的特性，它是在实现Python解析器(CPython)时所引入的一个概念。</p><blockquote><p>官方解释：<br>In CPython, the global interpreter lock, or GIL, is a mutex that prevents multiple native threads from executing Python bytecodes at once. This lock is necessary mainly because CPython’s memory management is not thread-safe. (However, since the GIL exists, other features have grown to depend on the guarantees that it enforces.)  </p></blockquote><blockquote><p>个人翻译：<br>在CPython中，GIL是一个用来防止多个线程同时请求同一机器码的互斥锁。CPython的内存管理方式是线程不安全的，所以这个锁是很有必要设置的。  </p></blockquote><h4 id="线程安全与线程不安全"><a href="#线程安全与线程不安全" class="headerlink" title="线程安全与线程不安全"></a>线程安全与线程不安全</h4><ul><li>线程安全<br>指多个线程在执行同一段代码的时候采用加锁机制,使每次的执行结果和单线程执行的结果都是一样的,不存在执行程序时出现意外结果。  </li><li>线程不安全<br>是指不提供加锁机制保护,有可能出现多个线程先后更改数据造成所得到的数据是脏数据。 </li></ul><h3 id="GIL为何存在"><a href="#GIL为何存在" class="headerlink" title="GIL为何存在"></a>GIL为何存在</h3><p>由于物理上得限制，各CPU厂商在核心频率上的比赛已经被多核所取代。<br>为了更有效的利用多核处理器的性能，就出现了多线程的编程方式，而随之带来的就是线程间数据一致性和状态同步的困难。为了有效解决多份缓存之间的数据同步时各厂商花费了不少心思，也不可避免的带来了一定的性能损失。  </p><p>Python当然也逃不开，为了利用多核，Python开始支持多线程。而解决多线程之间数据完整性和状态同步的最简单方法自然就是加锁。 于是有了GIL这把超级大锁，而当越来越多的代码库开发者接受了这种设定后，他们开始大量依赖这种特性（即默认python内部对象是thread-safe的，无需在实现时考虑额外的内存锁和同步操作）。</p><p>慢慢的这种实现方式被发现是蛋疼且低效的。但当大家试图去拆分和去除GIL的时候，发现大量库代码开发者已经重度依赖GIL而非常难以去除了。有多难？做个类比，像MySQL这样的“小项目”为了把Buffer Pool Mutex这把大锁拆分成各个小锁也花了从5.5到5.6再到5.7多个大版为期近5年的时间，并且仍在继续。MySQL这个背后有公司支持且有固定开发团队的产品走的如此艰难，那又更何况Python这样核心开发和代码贡献者高度社区化的团队呢？  </p><p>所以简单的说GIL的存在更多的是历史原因。如果推到重来，多线程的问题依然还是要面对，但是至少会比目前GIL这种方式会更优雅。</p><h3 id="GIL的影响"><a href="#GIL的影响" class="headerlink" title="GIL的影响"></a>GIL的影响</h3><p>从上文的介绍和官方的定义来看，GIL无疑就是一把全局排他锁。毫无疑问全局锁的存在会对多线程的效率有不小影响。甚至就几乎等于Python是个单线程的程序。 那么读者就会说了，全局锁只要释放的勤快效率也不会差啊。只要在进行耗时的IO操作的时候，能释放GIL，这样也还是可以提升运行效率的嘛。或者说再差也不会比单线程的效率差吧。理论上是这样，而实际上呢？Python比你想的更糟。  </p><p>Python的多线程在多核CPU上，只对于IO密集型计算产生正面效果；而当有至少有一个CPU密集型线程存在，那么多线程效率会由于GIL而大幅下降。</p><h3 id="用multiprocessing替代Thread"><a href="#用multiprocessing替代Thread" class="headerlink" title="用multiprocessing替代Thread"></a>用multiprocessing替代Thread</h3><p>multiprocessing库的出现很大程度上是为了弥补thread库因为GIL而低效的缺陷。<br>它完整的复制了一套thread所提供的接口方便迁移。唯一的不同就是它使用了多进程而不是多线程。每个进程有自己的独立的GIL，因此也不会出现进程之间的GIL争抢。  </p><p>当然multiprocessing也不是万能良药。<br>它的引入会增加程序实现时线程间数据通讯和同步的困难。就拿计数器来举例子，如果我们要多个线程累加同一个变量，对于thread来说，申明一个global变量，用thread.Lock的context包裹住三行就搞定了。而multiprocessing由于进程之间无法看到对方的数据，只能通过在主线程申明一个Queue，put再get或者用share memory的方法。这个额外的实现成本使得本来就非常痛苦的多线程程序编码，变得更加痛苦了。</p><h3 id="所以没救了么？"><a href="#所以没救了么？" class="headerlink" title="所以没救了么？"></a>所以没救了么？</h3><p>当然Python社区也在非常努力的不断改进GIL，甚至是尝试去除GIL。并在各个小版本中有了不少的进步。有兴趣的读者可以扩展阅读这个Slide 另一个改进Reworking the GIL   </p><p>将切换颗粒度从基于opcode计数改成基于时间片计数<br>避免最近一次释放GIL锁的线程再次被立即调度<br>新增线程优先级功能（高优先级线程可以迫使其他线程释放所持有的GIL锁） </p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Python GIL其实是功能和性能之间权衡后的产物，它尤其存在的合理性，也有较难改变的客观因素。</p><ul><li>因为GIL的存在，只有IO Bound场景下得多线程会得到较好的性能</li><li>如果对并行计算性能较高的程序可以考虑把核心部分也成C模块，或者索性用其他语言实现</li><li>GIL在较长一段时间内将会继续存在，但是会不断对其进行改进</li></ul><h2 id="不同目录import"><a href="#不同目录import" class="headerlink" title="不同目录import"></a>不同目录import</h2><p>import 说到底是根据路径导入<br>这个导入路径有多个，可以使用<code>sys.path</code>来查看  </p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xl"><span class="hljs-keyword">import</span> sys<br>sys.<span class="hljs-built_in">path</span><br></code></pre></td></tr></table></figure><h3 id="添加sys以处理不同级导入"><a href="#添加sys以处理不同级导入" class="headerlink" title="添加sys以处理不同级导入"></a>添加sys以处理不同级导入</h3><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs lua">import sys<br>import <span class="hljs-built_in">os</span><br>CURRENT_DIR = <span class="hljs-built_in">os</span>.<span class="hljs-built_in">path</span>.split(<span class="hljs-built_in">os</span>.<span class="hljs-built_in">path</span>.abspath(__file__))[<span class="hljs-number">0</span>]  # 当前目录<br>config_path = CURRENT_DIR.rsplit(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-number">3</span>)[<span class="hljs-number">0</span>]  # 上三级目录<br>sys.<span class="hljs-built_in">path</span>.append(config_path)<br>from <span class="hljs-built_in">config</span> import param<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;config_path=&#x27;</span>, config_path)<br><span class="hljs-built_in">print</span>(sys.<span class="hljs-built_in">path</span>)<br><span class="hljs-built_in">print</span>(param)<br></code></pre></td></tr></table></figure><h2 id="协程使用"><a href="#协程使用" class="headerlink" title="协程使用"></a>协程使用</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> asyncio<br><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_html</span>(<span class="hljs-params">url</span>):</span><br>    print(<span class="hljs-string">&quot;start get url&quot;</span>)<br>    <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">2</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;bobby&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">callback</span>(<span class="hljs-params">url, future</span>):</span><br>    print(url)<br>    print(<span class="hljs-string">&quot;send email to bobby&quot;</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    start_time = time.time()<br>    loop = asyncio.get_event_loop()<br>    <span class="hljs-comment"># 相当于开启一个future</span><br>    get_future = asyncio.ensure_future(get_html(<span class="hljs-string">&quot;http://www.imooc.com&quot;</span>))<br>    <span class="hljs-comment"># 事件循环</span><br>    loop.run_until_complete(get_future)<br>    <span class="hljs-comment"># 获取结果</span><br>    print(get_future.result())<br></code></pre></td></tr></table></figure><hr><p>参考：<br><a href="https://www.jianshu.com/p/756c505ab828">https://www.jianshu.com/p/756c505ab828</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo-在文章里显示的数学公式</title>
    <link href="/post/9a04a193/"/>
    <url>/post/9a04a193/</url>
    
    <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p><code>hexo</code>默认使用<code>hexo-renderer-marked</code>引擎去渲染网页，它会把利用<code>Markdown</code>语法写的文本去转换为相应的<code>html</code>标签。<br>在利用<code>Markdown</code>写<code>MathJax</code>公式的时候，经常会用到下划线<code>_</code>表示下标，但是下划线<code>_</code>会被<code>hexo</code>的默认引擎<code>hexo-renderer-marked</code>渲染成<code>html</code>中的<code>&lt;em&gt;</code>标签，表示斜体。<br>这样一来，我们写的<code>MathJax</code>公式就被错误渲染了，也就没办法正确显示出来。  </p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><h3 id="更换-Markdown-渲染器"><a href="#更换-Markdown-渲染器" class="headerlink" title="更换 Markdown 渲染器"></a>更换 Markdown 渲染器</h3><ol><li>卸载原渲染器  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm uninstall hexo-renderer-marked --save<br></code></pre></td></tr></table></figure></li><li>安装新渲染器  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install hexo-renderer-kramed --save<br></code></pre></td></tr></table></figure><h3 id="在编写时启用"><a href="#在编写时启用" class="headerlink" title="在编写时启用"></a>在编写时启用</h3>对于需要用到<code>MathJax</code>公式的文章，要在<code>Front-matter</code>中打开<code>MathJax</code>开关，例如：<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">Hexo-在文章里显示的数学公式</span><br><span class="hljs-attr">date:</span> <span class="hljs-number">2020-06-04 23:32:17</span><br><span class="hljs-attr">mathjax:</span> <span class="hljs-literal">true</span><br><span class="hljs-meta">---</span><br></code></pre></td></tr></table></figure>需要注意的是，如果主题里整合了这个东西，可能关键词不是<code>mathjax</code>，具体看主题的说明</li></ol><h2 id="MathJax公式语法"><a href="#MathJax公式语法" class="headerlink" title="MathJax公式语法"></a>MathJax公式语法</h2><h3 id="中文文档"><a href="#中文文档" class="headerlink" title="中文文档"></a>中文文档</h3><p><a href="https://mathjax-chinese-doc.readthedocs.io/en/latest/">https://mathjax-chinese-doc.readthedocs.io/en/latest/</a></p><h3 id="常用语法"><a href="#常用语法" class="headerlink" title="常用语法"></a>常用语法</h3><table><thead><tr><th>符号</th><th>释义</th><th>测试用例</th><th>最终效果</th></tr></thead><tbody><tr><td>^</td><td>上标</td><td>x{yz}=(1+ex){-2xy^w</td><td>$ x{yz}=(1+ex){-2xy^w} $</td></tr><tr><td>_</td><td>下标</td><td>CO_2</td><td>$CO_2$</td></tr><tr><td>\frac{分子}{分母} or 分子 \over 分母</td><td>分数</td><td>f(x,y,z)=3y2z(3+\frac{7x+5}{1+y2})</td><td>$ f(x,y,z)=3y2z(3+\frac{7x+5}{1+y2}) $</td></tr><tr><td>\sqrt[根指数，省略时为2]{被开方数}</td><td>开方</td><td>\sqrt{2}、\sqrt[3]{9}</td><td>$\sqrt{2}、\sqrt[3]{9}$</td></tr><tr><td>\ldots</td><td>与文本底线对齐的省略号</td><td>x_1x_2{\ldots}x_n</td><td>$x_1x_2{\ldots}x_n$</td></tr><tr><td>\cdots</td><td>与文本中线对齐的省略号</td><td>x_1x_2{\cdots}x_n</td><td>$x_1x_2{\cdots}x_n$</td></tr><tr><td>\int_积分下限^积分上限(被积表达式)</td><td>积分</td><td>\int_1^2n{x2}dx</td><td>$ \int_1^2n{x2}dx $</td></tr><tr><td><code>f(x)=\begin&#123;cases&#125;语句1\\语句2\\...\end&#123;cases&#125;</code></td><td>分段函数</td><td><code>f(n)=\begin&#123;cases&#125;n/2, &amp; \text&#123;如果$ x&lt;=2 $&#125;\\3n+1, &amp; \text&#123;如果$ x&gt;2 $&#125;\end&#123;cases&#125;</code></td><td>$$ f(n)=\begin{cases}n/2, &amp; \text{如果$ x&lt;=2 $}\3n+1, &amp; \text{如果$ x&gt;2 $}\end{cases}$$</td></tr></tbody></table>]]></content>
    
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>Markdown</tag>
      
      <tag>MathJax</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode日常-简单-实现pow(x, n)</title>
    <link href="/post/79ffd911/"/>
    <url>/post/79ffd911/</url>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>实现 pow(x, n) ，即计算 x 的 n 次幂函数。</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">示例 <span class="hljs-number">1</span>:<br>输入: <span class="hljs-number">2.00000</span>, <span class="hljs-number">10</span><br>输出: <span class="hljs-number">1024.00000</span><br></code></pre></td></tr></table></figure><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">示例 <span class="hljs-number">2</span>:<br>输入: <span class="hljs-number">2.10000</span>, <span class="hljs-number">3</span><br>输出: <span class="hljs-number">9.26100</span><br></code></pre></td></tr></table></figure><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile">示例 3:<br><span class="hljs-section">输入: 2.00000, -2</span><br><span class="hljs-section">输出: 0.25000</span><br><span class="hljs-section">解释: 2-2 = 1/22 = 1/4 = 0.25</span><br></code></pre></td></tr></table></figure><h2 id="自解"><a href="#自解" class="headerlink" title="自解"></a>自解</h2><p>简单递归，一次次乘，得到结果。</p><h2 id="官方解法-快速幂算法"><a href="#官方解法-快速幂算法" class="headerlink" title="官方解法-快速幂算法"></a>官方解法-快速幂算法</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>假设我们已经得到了 $$x ^ {n / 2}$$ 的结果，现在想要计算 $$x^n$$ 的结果<br>设 A 是 $$x^{n/2}$$ 的结果，我们可以分别根据 n 的奇偶来讨论 $$x ^ n$$   </p><ul><li>如果 n 是偶数，我们可以使用公式 $$(x^n)^2 = x^{2n}$$ 得到 $$x^n = A^2$$  </li><li>如果 n 是奇数，那么 $$A^2 = x^{n-1}$$    </li></ul><p>直观地说，我们需要将另一个 x 和结果相乘，所以 $$x^n = A * A * x$$ 。这种方法可以很容易地用递归实现<br>我们称这个方法为“快速幂（Fast Power）”，因为我们最多只需要 O(log(n)) 次计算就可以得到 $$ x^n $$  </p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fastpow</span>(<span class="hljs-params">self, x: <span class="hljs-built_in">float</span>, n: <span class="hljs-built_in">int</span></span>):</span><br>        <span class="hljs-keyword">if</span> n == <span class="hljs-number">1</span>: <br>            <span class="hljs-keyword">return</span> x<br>        <span class="hljs-keyword">return</span> self.fastpow(x, n/<span class="hljs-number">2</span>)**<span class="hljs-number">2</span> <span class="hljs-keyword">if</span> n%<span class="hljs-number">2</span> == <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> self.fastpow(x, (n-<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>)**<span class="hljs-number">2</span> * x<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">myPow</span>(<span class="hljs-params">self, x: <span class="hljs-built_in">float</span>, n: <span class="hljs-built_in">int</span></span>) -&gt; float:</span><br>        <span class="hljs-keyword">if</span> n &lt; <span class="hljs-number">0</span>: <br>            x = <span class="hljs-number">1</span>/x<br>            n = -n<br>        <span class="hljs-keyword">elif</span> n == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> self.fastpow(x, n)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>LeetCode</tag>
      
      <tag>简单</tag>
      
      <tag>快速幂算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode日常-简单-136. 只出现一次的数字</title>
    <link href="/post/4ce479fd/"/>
    <url>/post/4ce479fd/</url>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。不使用额外空间来实现。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile">示例 1:<br><span class="hljs-section">输入: [2,2,1]</span><br><span class="hljs-section">输出: 1</span><br></code></pre></td></tr></table></figure><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile">示例 2:<br><span class="hljs-section">输入: [4,1,2,1,2]</span><br><span class="hljs-section">输出: 4</span><br></code></pre></td></tr></table></figure><h2 id="自解"><a href="#自解" class="headerlink" title="自解"></a>自解</h2><p>这次直接自解都写不出了，不用空间完全想不到。</p><h2 id="官方解法"><a href="#官方解法" class="headerlink" title="官方解法"></a>官方解法</h2><p>对于这道题，可使用异或运算<code>⊕</code>。异或运算有以下三个性质。  </p><ol><li>任何数和<code>0</code>做异或运算，结果仍然是原来的数，即<code>a⊕0=a</code>  </li><li>任何数和其自身做异或运算，结果是<code>0</code>，即 <code>a⊕a=0</code>  </li><li>异或运算满足交换律和结合律，即<code>a⊕b⊕a</code>=<code>b⊕a⊕a</code>=<code>b⊕(a⊕a)</code>=<code>b⊕0=b</code>  </li></ol><p>假设数组中有<code>2m+1</code>个数，令<code>a1,a2...am</code>为出现两次的<code>m</code>个数，<code>an</code>为出现一次的数。<br><code>根据性质3</code>，数组中的全部元素的异或运算结果总是可以写成如下形式：  </p><center>`(a1⊕a1)⊕(a2⊕a2)⊕⋯⊕(am⊕am)⊕an`</center>根据性质 2 和性质 1，上式可化简和计算得到如下结果：<center>`0⊕0⊕⋯⊕0⊕am+1`=`an`</center>### 代码<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">singleNumber</span>(<span class="hljs-params">self, nums: List[<span class="hljs-built_in">int</span>]</span>) -&gt; int:</span><br>        <span class="hljs-keyword">return</span> reduce(<span class="hljs-keyword">lambda</span> x, y: x ^ y, nums)<br></code></pre></td></tr></table></figure><hr><p><a href="https://leetcode-cn.com/problems/single-number/solution/zhi-chu-xian-yi-ci-de-shu-zi-by-leetcode-solution/">https://leetcode-cn.com/problems/single-number/solution/zhi-chu-xian-yi-ci-de-shu-zi-by-leetcode-solution/</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>LeetCode</tag>
      
      <tag>简单</tag>
      
      <tag>位</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python-执行Javascript代码</title>
    <link href="/post/5e6a26f5/"/>
    <url>/post/5e6a26f5/</url>
    
    <content type="html"><![CDATA[<h1 id="python-javascript"><a href="#python-javascript" class="headerlink" title="python javascript"></a>python javascript</h1><h2 id="库"><a href="#库" class="headerlink" title="库"></a>库</h2><ul><li><p>PyV8<br>V8是Google开源<code>Javascript</code>引擎，被使用在Chrome中<br>PyV8是V8引擎的Python包装，可以用来调用V8引擎执行JS代码<br>年久失修，最新版本是2010年的<br>存在内存泄漏的问题  </p></li><li><p>JsPy<br>纯<code>Python</code>实现的<code>Javascript</code>解释器和翻译器<br>issues里有很多bug未修复<br>解释器 性能不高，存在BUG<br>翻译器 对于高度混淆大型<code>Javascript</code>会转换失败，转换出来的代码可读性差，性能不高  </p></li><li><p>PyMiniRacer<br>PyMiniRacer是V8引擎的Python包装，可以用来调用V8引擎执行JS代码<br>继任<code>PyExecJS</code>和<code>PyV8</code>的库  </p></li><li><p>PyExecJS<br>最开始诞生在Ruby中的库，后来被移植到了Python上<br>有多个引擎可选，一般选Node.js,因为比较快<br>执行大型js代码稍慢<br>特殊编码的输入或输出会出现报错，可以将输入输出参数使用Base64编码一下  </p></li><li><p>Selenium<br>浏览器环境<br>Selenium有一个执行js的函数，是一个Web自动化测试工具<br><code>browser.execute_script(js)</code><br>可以运用此函数进行js运行  </p></li><li><p>Pyppeteer<br>浏览器环境<br><code>Puppeteer</code>的Python版本，由第三方开发，是一个Web自动化测试框架<br>原生支持以协程的方式调用，性能比<code>Selenium</code>高<br>对于用<code>Asyncio</code> + <code>Aiohttp</code>写爬虫而言的人可以直接使用</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">await</span> page.evaluate(js, *<span class="hljs-class"><span class="hljs-keyword">data</span>)</span><br></code></pre></td></tr></table></figure></li><li><p>NodeJS<br>执行速度快</p><ul><li>RPC<br>写一个简单的RPC服务接口，然后在python调用nodeJS的RPC服务，拿到结果  </li><li>HTTP API<br>与写后端代码一样，提供一个可执行JS的HTTP API，通过调用API来执行JS获得结果  <blockquote><p>Node.js对象没有浏览器才有的window对象，如果需要使用，可以直接建立对象，也可以使用sjdom这个库<br>window.btoa在nodejs中不存在，可以使用Buffer.from(‘..’).toString(‘base64’)解决</p></blockquote></li></ul></li></ul><h1 id="python-执行-javascript"><a href="#python-执行-javascript" class="headerlink" title="python 执行 javascript"></a>python 执行 javascript</h1><h2 id="PyExecJS"><a href="#PyExecJS" class="headerlink" title="PyExecJS"></a>PyExecJS</h2><p>需要注意，这是单独的js运行，并没有浏览器参数<br>如果js中一些内容引用到了浏览器参数，很可能会报错  </p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><h4 id="安装js运行环境"><a href="#安装js运行环境" class="headerlink" title="安装js运行环境"></a>安装js运行环境</h4><p>推荐安装Node.js  </p><h4 id="配置Node-js"><a href="#配置Node-js" class="headerlink" title="配置Node.js"></a>配置Node.js</h4><h5 id="修改包路径与cache路径"><a href="#修改包路径与cache路径" class="headerlink" title="修改包路径与cache路径"></a>修改包路径与cache路径</h5><p>cmd中输入</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">npm<span class="hljs-built_in"> config </span><span class="hljs-builtin-name">set</span><span class="hljs-built_in"> prefix </span><span class="hljs-string">&quot;F:\Environment\Node_js\node_global&quot;</span><br>npm<span class="hljs-built_in"> config </span><span class="hljs-builtin-name">set</span> chche <span class="hljs-string">&quot;F:\Environment\Node_js\node_cache&quot;</span><br></code></pre></td></tr></table></figure><h4 id="安装PyExecJS"><a href="#安装PyExecJS" class="headerlink" title="安装PyExecJS"></a>安装PyExecJS</h4><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">pip <span class="hljs-keyword">install</span> pyexecjs<br></code></pre></td></tr></table></figure><h4 id="检验安装是否成功"><a href="#检验安装是否成功" class="headerlink" title="检验安装是否成功"></a>检验安装是否成功</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> execjs<br>print(<span class="hljs-string">&quot;如果装了Node.js, 会显示 Node.js&quot;</span>, execjs.get().name)<br>js_text = <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">function hello_world()&#123;</span><br><span class="hljs-string">    return &quot;Hello World&quot;;</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br>ctx = execjs.<span class="hljs-built_in">compile</span>(js_text)  <span class="hljs-comment"># 编译js代码</span><br>a = ctx.call(<span class="hljs-string">&#x27;hello_world&#x27;</span>)<br>print(a)<br></code></pre></td></tr></table></figure><p>运行代码，若是正确显示Hello World则成功</p><h3 id="gbk编码问题"><a href="#gbk编码问题" class="headerlink" title="gbk编码问题"></a>gbk编码问题</h3><p><img src="/Python-%E6%89%A7%E8%A1%8CJavascript%E4%BB%A3%E7%A0%81/20200813120730107.png"><br>其默认编码格式是跟随系统的<br>也就是说，windows下如果你不做设定，那么会是<code>gbk</code><br><code>gbk</code>碰到一些奇怪的字符就会不能编码<br>寻找构造函数，将编码默认值设定为<code>utf-8</code><br><img src="/Python-%E6%89%A7%E8%A1%8CJavascript%E4%BB%A3%E7%A0%81/20200813120845387.png"><br>这样实际上是修改了包的源码，在其他系统上跑的话需要多加留意  </p>]]></content>
    
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>Javascript</tag>
      
      <tag>爬虫</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Anaconda</title>
    <link href="/post/5c8e05d2/"/>
    <url>/post/5c8e05d2/</url>
    
    <content type="html"><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h2 id="Centos7"><a href="#Centos7" class="headerlink" title="Centos7"></a>Centos7</h2><p>由于国内去Anaconda官网下载卡到了极点<br>这里用的是国内的镜像<br><a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/">https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/</a><br>用浏览器打开，根据需要下载对应版本<br><img src="/Anaconda/20200323112051141.png">  </p><p>下载好了以后在对应的地方  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">bash 下载下来的文件的文件名.sh<br></code></pre></td></tr></table></figure><p>接下来按照提示安装  </p><ol><li><p>询问协议<br>首先会问你是否同意协议<br>回答一个yes就是  </p></li><li><p>询问安装路径<br><img src="/Anaconda/20200324123320174.png"><br>我强烈建议你不要按照它默认给的路径安装在root下<br>会出很多问题  </p></li><li><p>询问是否添加环境变量<br><img src="/Anaconda/20200324123620201.png"><br>没什么如果没有什么情况的话，直接用这个默认环境变量也行  </p><blockquote><p>需要注意的是，此处添加环境变量的话会导致<code>tigerVNC</code>出现问题，若需要使用tigerVNC,建议手动设置环境变量  </p></blockquote></li><li><p>询问是否要安装VSCode<br><img src="/Anaconda/20200324123925652.png"><br>根据需要来  </p></li></ol><h2 id="手动添加环境变量"><a href="#手动添加环境变量" class="headerlink" title="手动添加环境变量"></a>手动添加环境变量</h2><ol><li>进入环境变量文件夹  <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">cd <span class="hljs-regexp">/etc/</span>profile.d<br></code></pre></td></tr></table></figure></li><li>创建环境变量文件  <figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">sudo vim <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Anaconda</span>.</span></span>sh<br></code></pre></td></tr></table></figure></li><li>编写环境变量<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-comment"># set Anaconda environment</span><br>PATH=<span class="hljs-variable">$PATH</span><span class="hljs-symbol">:/home/manager/anaconda3/bin</span><br>export PATH<br></code></pre></td></tr></table></figure> 注意对应自己的安装路径，写完<code>:wq</code>保存退出  </li><li>打开新的控制台测试  <figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">conda</span><br></code></pre></td></tr></table></figure>看到一堆命令提示就代表成功</li></ol><h2 id="基础操作"><a href="#基础操作" class="headerlink" title="基础操作"></a>基础操作</h2><h3 id="启动GUI"><a href="#启动GUI" class="headerlink" title="启动GUI"></a>启动GUI</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">anaconda-navigator<br></code></pre></td></tr></table></figure><p>并不允许用root账户打开</p><h3 id="更新Anaconda"><a href="#更新Anaconda" class="headerlink" title="更新Anaconda"></a>更新Anaconda</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">conda update conda<br>conda update anaconda<br></code></pre></td></tr></table></figure><h3 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h3><p><span id="delete_evm"></span></p><ol><li>去除环境变量 <ol><li>在根目录下输入：sudo gedit ~/.bashrc</li><li>在.bashrc文件末尾用#号注释掉之前添加的路径(或直接删除)： <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"><span class="hljs-built_in">export</span> PATH=<span class="hljs-string">&quot;/root/anaconda2/bin:<span class="hljs-variable">$PATH</span>&quot;</span></span><br></code></pre></td></tr></table></figure></li><li>使其立即生效，执行：source ~/.bashrc</li><li>关闭终端，重新启动一个终端，不然原终端上还是绑定有anaconda。</li></ol></li><li>删除Anconda安装文件夹</li></ol><h2 id="环境管理"><a href="#环境管理" class="headerlink" title="环境管理"></a>环境管理</h2><h3 id="创建新环境"><a href="#创建新环境" class="headerlink" title="创建新环境"></a>创建新环境</h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">conda</span> create -n 新环境名称 python=<span class="hljs-number">3</span>.<span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><p>python版本号不输入的话就会弄<code>Anaconda</code>里最新的  </p><blockquote><p>如果在env文件夹里找不到python环境，可以试着在创建环境的时候指定一个python版本  </p></blockquote><h3 id="查看已有的环境"><a href="#查看已有的环境" class="headerlink" title="查看已有的环境"></a>查看已有的环境</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">conda</span> <span class="hljs-literal">info</span> -e<br></code></pre></td></tr></table></figure><h3 id="激活环境"><a href="#激活环境" class="headerlink" title="激活环境"></a>激活环境</h3><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">conda <span class="hljs-built_in">activate</span> 环境名<br></code></pre></td></tr></table></figure><h3 id="关闭环境"><a href="#关闭环境" class="headerlink" title="关闭环境"></a>关闭环境</h3><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">conda deactivate</span><br></code></pre></td></tr></table></figure><h3 id="删除环境"><a href="#删除环境" class="headerlink" title="删除环境"></a>删除环境</h3><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua">conda <span class="hljs-built_in">remove</span> -n 环境名 <span class="hljs-comment">--all</span><br></code></pre></td></tr></table></figure><h3 id="复制环境"><a href="#复制环境" class="headerlink" title="复制环境"></a>复制环境</h3><h4 id="在本机上复制既有环境"><a href="#在本机上复制既有环境" class="headerlink" title="在本机上复制既有环境"></a>在本机上复制既有环境</h4><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">conda create -n 新环境名 --<span class="hljs-keyword">clone</span> <span class="hljs-title">旧环境名</span><br></code></pre></td></tr></table></figure><h3 id="环境重命名"><a href="#环境重命名" class="headerlink" title="环境重命名"></a>环境重命名</h3><p>没有这个功能，如果需要重命名的话，利用复制和删除进行操作</p><h3 id="导出-导入环境"><a href="#导出-导入环境" class="headerlink" title="导出/导入环境"></a>导出/导入环境</h3><h4 id="导出环境"><a href="#导出环境" class="headerlink" title="导出环境"></a>导出环境</h4><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">conda <span class="hljs-keyword">env</span> export &gt; <span class="hljs-keyword">env</span>.yaml<br></code></pre></td></tr></table></figure><p>利用<code>conda env export</code> 导出的是个yaml格式的文件，该文件记录了环境名，软件源地址以及安装包列表  </p><h4 id="导入环境"><a href="#导入环境" class="headerlink" title="导入环境"></a>导入环境</h4><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">conda <span class="hljs-keyword">env</span> create -f <span class="hljs-keyword">env</span>.yaml<br></code></pre></td></tr></table></figure><p>在新的机器中可直接执行上述命令，生成的环境与复制源完全一样（包括环境名），如果想在同一台机器上复制，需要把yaml文件中的环境名修改为一个新的名字，否则会冲突  </p><blockquote><p>实际上，这东西及其不靠谱，因为要是需要的包在Anaconda官网里没有标注，直接就安装不了，报错  </p></blockquote><blockquote><p>建议还是使用老方法安装，在激活环境后通过pip安装</p></blockquote><h4 id="pip-环境转移"><a href="#pip-环境转移" class="headerlink" title="pip 环境转移"></a>pip 环境转移</h4><p>导出依赖到<code>requirements.txt</code><br><code>pip freeze &gt; requirements.txt</code><br>从<code>requirements.txt</code>导入<br><code>pip install -r requirement.txt</code></p><h4 id="pip源"><a href="#pip源" class="headerlink" title="pip源"></a>pip源</h4><ol><li><code>.pip</code>目录下创建一个<code>pip.conf</code>文件  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">mkdir ~/.pip<br><span class="hljs-built_in">cd</span> ~/.pip<br>touch pip.conf<br></code></pre></td></tr></table></figure></li><li>编辑 <code>pip.conf</code> 文件<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo vim ~/.pip/pip.conf<br></code></pre></td></tr></table></figure>填入源的信息  <figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">[<span class="hljs-keyword">global</span>] <br><span class="hljs-keyword">index</span>-url = https://pypi.tuna.tsinghua.edu.cn/simple<br>[install]<br><span class="hljs-keyword">trusted</span>-host = https://pypi.tuna.tsinghua.edu.cn  # <span class="hljs-keyword">trusted</span>-host 此参数是为了避免麻烦，否则使用的时候可能会提示不受信任<br></code></pre></td></tr></table></figure>保存修改  </li></ol><h3 id="env目录下没有Python解释器"><a href="#env目录下没有Python解释器" class="headerlink" title="env目录下没有Python解释器"></a>env目录下没有Python解释器</h3><p>如果在创建环境的时候没有指定<code>Python</code>环境版本，那么<code>anaconda/env/环境文件夹</code>下就不会有<code>Python</code>解释器<br>你可以给它装一个解释器  </p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">conda <span class="hljs-keyword">install</span> -n 环境名 python<br></code></pre></td></tr></table></figure><p>虽然这样做就有解释器了，但是这个新的解释器里面并没有以前安装的包<br>所以需要将包目录记录下来重新安装  </p>]]></content>
    
    
    
    <tags>
      
      <tag>Anaconda</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode日常-简单-面试题57. 和为s的两个数字</title>
    <link href="/post/7dbc971/"/>
    <url>/post/7dbc971/</url>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>输入一个递增排序的数组和一个数字s，在数组中查找两个数，使得它们的和正好是s。如果有多对数字的和等于s，则输出任意一对即可。</p><h3 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a>示例 1：</h3><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[2,7,11,15]</span>, target = 9<br>输出：<span class="hljs-comment">[2,7]</span> 或者 <span class="hljs-comment">[7,2]</span><br></code></pre></td></tr></table></figure><h3 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a>示例 2：</h3><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[10,26,30,31,47,60]</span>, target = 40<br>输出：<span class="hljs-comment">[10,30]</span> 或者 <span class="hljs-comment">[30,10]</span><br></code></pre></td></tr></table></figure><h4 id="限制："><a href="#限制：" class="headerlink" title="限制："></a>限制：</h4><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>&lt;= nums.length &lt;= <span class="hljs-number">10</span>^<span class="hljs-number">5</span><br><span class="hljs-symbol">1 </span>&lt;= nums[i] &lt;= <span class="hljs-number">10</span>^<span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><h2 id="自解"><a href="#自解" class="headerlink" title="自解"></a>自解</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>从后往前，先确定比较大的那个数，这样能较快的减少无用状态<br>由于只有两个数，确定了比较大的数以后，与目标相减一下就能得到结果，判断一下这个结果是否在记录中即可。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">twoSum</span>(<span class="hljs-params">self, nums: List[<span class="hljs-built_in">int</span>], target: <span class="hljs-built_in">int</span></span>) -&gt; List[int]:</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums)-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">if</span> nums[i] &gt; target:<br>                <span class="hljs-keyword">continue</span><br>            <span class="hljs-keyword">if</span> target-nums[i] <span class="hljs-keyword">in</span> nums:<br>                <span class="hljs-keyword">return</span> nums[i], target-nums[i]<br></code></pre></td></tr></table></figure><h3 id="效率"><a href="#效率" class="headerlink" title="效率"></a>效率</h3><p>执行用时：192 ms<br>内存消耗：24.9 MB</p><h2 id="大佬解法"><a href="#大佬解法" class="headerlink" title="大佬解法"></a>大佬解法</h2><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>利用 <code>HashMap</code> 可以通过遍历数组找到数字组合，时间和空间复杂度均为 <code>O(N)</code><br>注意本题的 <code>nums</code> 是 排序数组 ，因此可使用 <code>双指针法</code> 将空间复杂度降低至 <code>O(1)</code></p><h3 id="算法流程："><a href="#算法流程：" class="headerlink" title="算法流程："></a>算法流程：</h3><p>初始化： 双指针 <code>i</code>, <code>j</code>分别指向数组 <code>nums</code> 的左右两端 （俗称对撞双指针）<br>循环搜索： 当双指针相遇时跳出；<br>计算和 <code>s = nums[i] + nums[j]</code></p><ul><li>若 <code>s&gt;target</code><br>指针 <code>j</code> 向左移动，即执行 <code>j=j−1</code></li><li>若 <code>s&lt;target</code><br>指针 <code>i</code> 向右移动，即执行 <code>i=i+1</code></li><li>若 <code>s=target</code><br>立即返回数组 <code>[nums[i],nums[j]]</code></li></ul><p>返回空数组，代表无和为<code>target</code>的数字组合。</p><p>正确性证明：</p><blockquote><p>记每个状态为 <code>S(i,j)</code>，即 <code>S(i,j)=nums[i]+nums[j]</code><br>假设 <code>S(i,j)&lt;targetS(i, j)</code>，则执行 <code>i=i+1</code>，即状态切换至 <code>S(i+1,j)</code></p></blockquote><p><img src="/LeetCode%E6%97%A5%E5%B8%B8-%E7%AE%80%E5%8D%95-%E9%9D%A2%E8%AF%95%E9%A2%9857.-%E5%92%8C%E4%B8%BAs%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97/20200518022012071.png"></p><ul><li>状态 <code>S(i,j)</code> 切换至 <code>S(i+1,j)</code> ，则会消去一行元素，相当于 消去了状态集合 <code>&#123;S(i,i+1),S(i,i+2),...,S(i,j−2),S(i,j−1),S(i,j)&#125;</code><br>（由于双指针都是向中间收缩，因此这些状态之后不可能再遇到）。</li><li>由于 <code>nums</code> 是排序数组，因此这些 消去的状态 都一定满足 <code>S(i,j)&lt;target</code>，即这些状态都 不是解 。</li></ul><p>结论： 以上分析已证明 “每次指针 <code>i</code> 的移动操作，都不会导致解的丢失” ，即指针 <code>i</code> 的移动操作是 安全的；同理，对于指针 <code>j</code> 可得出同样推论；因此，此双指针法是正确的。</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">twoSum</span>(<span class="hljs-params">self, nums: List[<span class="hljs-built_in">int</span>], target: <span class="hljs-built_in">int</span></span>) -&gt; List[int]:</span><br>        i, j = <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span><br>        <span class="hljs-keyword">while</span> i &lt; j:<br>            s = nums[i] + nums[j]<br>            <span class="hljs-keyword">if</span> s &gt; target: j -= <span class="hljs-number">1</span><br>            <span class="hljs-keyword">elif</span> s &lt; target: i += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>: <span class="hljs-keyword">return</span> nums[i], nums[j]<br>        <span class="hljs-keyword">return</span> []<br></code></pre></td></tr></table></figure><h3 id="效率-1"><a href="#效率-1" class="headerlink" title="效率"></a>效率</h3><p>执行用时：148 ms<br>内存消耗：24.8 MB</p><hr><p>来源：</p><ul><li>大佬解法：<br>作者：jyd<br>链接：<a href="https://leetcode-cn.com/problems/he-wei-sde-liang-ge-shu-zi-lcof/solution/mian-shi-ti-57-he-wei-s-de-liang-ge-shu-zi-shuang-/">https://leetcode-cn.com/problems/he-wei-sde-liang-ge-shu-zi-lcof/solution/mian-shi-ti-57-he-wei-s-de-liang-ge-shu-zi-shuang-/</a></li><li>leecode题目：<br><a href="https://leetcode-cn.com/problems/he-wei-sde-liang-ge-shu-zi-lcof/">https://leetcode-cn.com/problems/he-wei-sde-liang-ge-shu-zi-lcof/</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>LeetCode</tag>
      
      <tag>简单</tag>
      
      <tag>对撞双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mysql-CentOS</title>
    <link href="/post/56628b65/"/>
    <url>/post/56628b65/</url>
    
    <content type="html"><![CDATA[<h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><ul><li>Centos7.4 腾讯云服务器</li></ul><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h2 id="一、添加yum源"><a href="#一、添加yum源" class="headerlink" title="一、添加yum源"></a>一、添加yum源</h2><ol><li><p>mysql的官网下载yum repo配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">wget https://dev.mysql.com/get/mysql57-community-release-el7-9.noarch.rpm<br></code></pre></td></tr></table></figure></li><li><p>安装repo</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">rpm -ivh mysql57-community-release-el7-9.noarch.rpm<br></code></pre></td></tr></table></figure><h2 id="二、安装"><a href="#二、安装" class="headerlink" title="二、安装"></a>二、安装</h2><h3 id="原生mysql安装"><a href="#原生mysql安装" class="headerlink" title="原生mysql安装"></a>原生mysql安装</h3></li><li><p>yum安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum install mysql-server<br></code></pre></td></tr></table></figure></li><li><p>启动mysql</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">systemctl start mysqld <br></code></pre></td></tr></table></figure></li><li><p>临时密码获取</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">grep <span class="hljs-string">&#x27;temporary password&#x27;</span> /var/<span class="hljs-built_in">log</span>/mysqld.log<br></code></pre></td></tr></table></figure></li><li><p>重启mysql</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">systemctl start mysqld<br></code></pre></td></tr></table></figure></li><li><p>临时登录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">mysql -u root -p<br></code></pre></td></tr></table></figure><p> 然后输入密码（刚刚获取的临时密码）</p></li><li><p>修改root密码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ALTER USER <span class="hljs-string">&#x27;root&#x27;</span>@<span class="hljs-string">&#x27;localhost&#x27;</span> IDENTIFIED BY <span class="hljs-string">&#x27;新的密码&#x27;</span>; <br></code></pre></td></tr></table></figure><p> 设置一个大小写字母，特殊字符，数字都有的，比较长的密码即可</p></li></ol><h3 id="Docker安装"><a href="#Docker安装" class="headerlink" title="Docker安装"></a>Docker安装</h3><p>首先你需要有<code>Docker</code>环境</p><a href="#">Post not found: CentOS-Docker</a><ol><li><p>拉取镜像  </p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> pull mysql <span class="hljs-number">5</span>.<span class="hljs-number">7</span><br></code></pre></td></tr></table></figure><p> 你可以指定版本号，也可以不指定（默认最新版）<br> 拉取完毕后看看是否有了镜像  </p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">docker images</span><br></code></pre></td></tr></table></figure></li><li><p>创建容器  </p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> run -p <span class="hljs-number">3307</span>:<span class="hljs-number">3306</span> --name mysql -e MYSQL_ROOT_PASSWORD=起始mysql-root用户密码 -d mysql:<span class="hljs-number">5</span>.<span class="hljs-number">7</span><br></code></pre></td></tr></table></figure><ul><li>–name : 容器名，此处命名为<code>mysql</code>  </li><li>-e：配置信息，此处配置了<code>mysql</code>的<code>root</code>用户登录密码  </li><li>-p端口映射：此处主机 3307端口 到 容器的3306端口  </li><li>-d：镜像名，如果没有指定版本，就不用填写版本信息  </li></ul></li><li><p>建立目录映射(不建议建立)  </p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk">duso docker run -p <span class="hljs-number">3306</span>:<span class="hljs-number">3306</span> --name mysql \<br>-v <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/docker/my</span>sql<span class="hljs-regexp">/conf:/</span>etc/mysql \<br>-v <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/docker/my</span>sql<span class="hljs-regexp">/logs:/</span>var<span class="hljs-regexp">/log/my</span>sql \<br>-v <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/docker/my</span>sql<span class="hljs-regexp">/data:/</span>var<span class="hljs-regexp">/lib/my</span>sql \<br>-e MYSQL_ROOT_PASSWORD=<span class="hljs-number">123456</span> \<br>-d mysql:<span class="hljs-number">5.7</span><br></code></pre></td></tr></table></figure><ul><li>-v：主机和容器的目录映射关系，”:”前为主机目录，之后为容器目录  </li></ul></li><li><p>查看容器是否已经正常运行  </p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mel">docker <span class="hljs-keyword">container</span> <span class="hljs-keyword">ls</span><br></code></pre></td></tr></table></figure><p> 可以看到容器ID，容器的源镜像，启动命令，创建时间，状态，端口映射信息，容器名字</p></li><li><p>连接容器，输入用户/密码,进入mysql  </p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs applescript">docker exec -<span class="hljs-keyword">it</span> mysql bash<br>mysql -u用户名 -p密码<br></code></pre></td></tr></table></figure><h2 id="配置mysql"><a href="#配置mysql" class="headerlink" title="配置mysql"></a>配置mysql</h2><h3 id="开启远程控制"><a href="#开启远程控制" class="headerlink" title="开启远程控制"></a>开启远程控制</h3></li><li><p>登录数据库  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">mysql -u root -p<br></code></pre></td></tr></table></figure></li><li><p>进去mysql数据库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">use mysql;<br></code></pre></td></tr></table></figure></li><li><p>创建用户(可选操作)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create user &#39;用户名&#39;@&#39;用户的HOST&#39; identified by &#39;密码&#39;;<br></code></pre></td></tr></table></figure><p> 如果想要任意客户端都可以访问的话，给<code>HOST</code>设置一个<code>%</code>即可，也可以输入ip<br> 如果选择创建用户的话后面的步骤就可以跳过了</p></li><li><p>查看user表中的数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select Host, User from user;<br></code></pre></td></tr></table></figure><p> 观察显示的数据<code>Host</code>代表许可ip，<code>%</code>代表任意</p></li><li><p>修改访问许可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">update user set Host&#x3D;&#39;%&#39; where User&#x3D;&#39;root&#39;;  <br></code></pre></td></tr></table></figure><p> 这里是将<code>root</code>用户修改为任意ip都可以访问</p></li><li><p>刷新权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">flush privileges;<br></code></pre></td></tr></table></figure><h3 id="Navicat连接报错2059"><a href="#Navicat连接报错2059" class="headerlink" title="Navicat连接报错2059"></a>Navicat连接报错2059</h3><p><code>Navicat</code>不支持<code>MySQL</code>新版本的默认加密方式<code>caching_sha2_password</code>导致报错  </p></li><li><p>查看<code>mysql</code>用户信息  </p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">select</span> host, <span class="hljs-keyword">user</span>, plugin <span class="hljs-keyword">from</span> mysql.<span class="hljs-keyword">user</span>;<br></code></pre></td></tr></table></figure><p> <img src="/Mysql-CentOS/20200911105251476.png"><br> 可以查看到，其加密方式为<code>caching_sha2_password</code>  </p></li><li><p>修改加密方式  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">USER</span> <span class="hljs-string">&#x27;用户名&#x27;</span>@<span class="hljs-string">&#x27;用户的Host&#x27;</span> <span class="hljs-keyword">IDENTIFIED</span> <span class="hljs-keyword">WITH</span> mysql_native_password <span class="hljs-keyword">BY</span> <span class="hljs-string">&#x27;用户的密码&#x27;</span>;<br></code></pre></td></tr></table></figure><p> <code>caching_sha2_password</code>这种加密方式<code>Navicat</code>不支持<br> 将它改为<code>Navicat</code>支持的<code>mysql_native_password</code> </p></li></ol><h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><h2 id="授权"><a href="#授权" class="headerlink" title="授权"></a>授权</h2><ul><li>用户对某个数据库内的所有表 增删改查权限<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">grant</span> <span class="hljs-keyword">select</span>, <span class="hljs-keyword">insert</span>, <span class="hljs-keyword">update</span>, <span class="hljs-keyword">delete</span> <span class="hljs-keyword">on</span> 数据库名.* <span class="hljs-keyword">to</span> 用户名@<span class="hljs-string">&#x27;用户Host&#x27;</span>  <br></code></pre></td></tr></table></figure></li></ul><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="mysql服务"><a href="#mysql服务" class="headerlink" title="mysql服务"></a>mysql服务</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">systemctl start mysqld  <span class="hljs-comment"># 启动mysql服务</span><br>systemctl stop mysqld  <span class="hljs-comment"># 关闭mysql服务</span><br>systemctl restart mysqld  <span class="hljs-comment"># 重启 mysql服务</span><br>systemctl status mysqld  <span class="hljs-comment"># 查看mysql服务运行状态</span><br>systemctl <span class="hljs-built_in">enable</span> mysqld   <span class="hljs-comment"># 开机启动mysql</span><br>systemctl <span class="hljs-built_in">disable</span> mysqld    <span class="hljs-comment"># 关闭开机启动mysql</span><br></code></pre></td></tr></table></figure><h2 id="查看mysql版本"><a href="#查看mysql版本" class="headerlink" title="查看mysql版本"></a>查看mysql版本</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select version();<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>服务器</tag>
      
      <tag>CentOS</tag>
      
      <tag>Mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>VSCode-IDE</title>
    <link href="/post/e2c5bfe8/"/>
    <url>/post/e2c5bfe8/</url>
    
    <content type="html"><![CDATA[<h1 id="Visual-Studio-Code"><a href="#Visual-Studio-Code" class="headerlink" title="Visual Studio Code"></a>Visual Studio Code</h1><p>轻量级，相当于notepad++加强版，很多东西要自己配，各种平台均可用  </p><h2 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h2><p>官方文档：<a href="https://code.visualstudio.com/docs/setup/linux">https://code.visualstudio.com/docs/setup/linux</a><br>下载地址：<a href="https://visualstudio.microsoft.com/zh-hans/">https://visualstudio.microsoft.com/zh-hans/</a></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h3><p>直接使用安装包即可  </p><h3 id="CentOS"><a href="#CentOS" class="headerlink" title="CentOS"></a>CentOS</h3><p><a href="https://code.visualstudio.com/docs/setup/linux">https://code.visualstudio.com/docs/setup/linux</a><br>已经将 稳定的64位的VSCode放在了yum里了<br>你可以用下面的代码安装秘钥和库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo rpm --import https://packages.microsoft.com/keys/microsoft.asc<br><br>sudo sh -c <span class="hljs-string">&#x27;echo -e &quot;[code]\nname=Visual Studio Code\nbaseurl=https://packages.microsoft.com/yumrepos/vscode\nenabled=1\ngpgcheck=1\ngpgkey=https://packages.microsoft.com/keys/microsoft.asc&quot; &gt; /etc/yum.repos.d/vscode.repo&#x27;</span><br></code></pre></td></tr></table></figure><ul><li>安装方法一：用<code>dnf</code>,更新cache包,安装对应的包<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo dnf check-update<br>sudo dnf install code<br></code></pre></td></tr></table></figure></li><li>安装方法二：用<code>yum</code>,更新cache包,安装对应的包<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum check-update<br>sudo yum install code<br></code></pre></td></tr></table></figure>需要注意的是，用<code>yum</code>安装的话，<code>VSCode</code>的版本可能会滞后。</li></ul><h2 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h2><table><thead><tr><th>键位</th><th>作用</th></tr></thead><tbody><tr><td><code>Ctrl</code> <code>/</code></td><td>注释代码</td></tr><tr><td><code>Ctrl</code> <code>[</code></td><td>代码行向左缩进</td></tr><tr><td><code>Ctrl</code> <code>]</code></td><td>代码行向左缩进</td></tr><tr><td><code>Shift</code> <code>Alt</code> <code>F</code></td><td>代码格式化</td></tr><tr><td><code>Shift</code> <code>F12</code></td><td>找到所有的引用</td></tr><tr><td><code>F11</code></td><td>全屏显示(再次按则恢复)</td></tr><tr><td><code>Ctrl</code> <code>S</code></td><td>保存</td></tr><tr><td><code>F1</code></td><td>打开VSCode命令面板</td></tr></tbody></table><h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><h3 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h3><p><img src="/VSCode/20200429062729159.png"><br>安装插件简单三步：点插件，输入插件名称，点击安装  </p><h3 id="常用插件"><a href="#常用插件" class="headerlink" title="常用插件"></a>常用插件</h3><table><thead><tr><th>插件名</th><th>作用</th></tr></thead><tbody><tr><td>Chinese (Simplified) Language Pack for Visual Studio Code</td><td>界面汉化</td></tr><tr><td>Beautify</td><td>美化javascript, JSON, CSS, Sass，和HTML代码</td></tr><tr><td>GitLens — Git supercharged</td><td>增强git在Visual Studio中的功能</td></tr><tr><td>vscode-icons</td><td>在Visual Studio文件浏览中加入图标，方便识别</td></tr><tr><td>Python</td><td>python运行环境插件</td></tr><tr><td>Import Cost</td><td>可以计算import的消耗</td></tr><tr><td>RegExp Preview and Editor</td><td>正则表达式可视化处理工具</td></tr></tbody></table>]]></content>
    
    
    
    <tags>
      
      <tag>VSCode</tag>
      
      <tag>IDE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Scrapy-基础-Spider内不同级别parse传递参数</title>
    <link href="/post/8eafb108/"/>
    <url>/post/8eafb108/</url>
    
    <content type="html"><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>并不是每一个网站都将你想要的所有信息放在最内层页面的<br>可能需要在不同层级的请求中获取不同的参数，共同组成最后的<code>item</code>。<br>如果不懂得在不同层级的<code>parse</code>中传递参数，那么最后的item会缺失一些信息。</p><h1 id="处理"><a href="#处理" class="headerlink" title="处理"></a>处理</h1><p><code>Spider</code>的<code>Request</code>请求经过处理后，最终会返回一个<code>Response</code>，被回调函数<code>callback</code>处理  </p><p>如果想要传递数据，有两种处理方式：  </p><ul><li>在<code>Request</code>中添加<code>meta</code>参数（官方不推荐）  </li><li>使用<code>Request</code>的<code>cb_kwargs</code>属性  </li></ul><h2 id="使用meta参数"><a href="#使用meta参数" class="headerlink" title="使用meta参数"></a>使用meta参数</h2><p>我们可以在<code>Request</code>中添加<code>meta</code>参数，记录需要传递的信息<br><code>meta</code>参数所附带的信息最终会被<code>Response</code>返回<br><code>meta</code>参数可传递 简单类型参数 或 对象类型参数  </p><blockquote><p>案例：使用<code>Request</code>的<code>meta</code>参数传递数据  </p></blockquote><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">parse</span><span class="hljs-params">(<span class="hljs-keyword">self</span>, response)</span></span><span class="hljs-symbol">:</span><br>    item = MyItem()<br>    item[<span class="hljs-string">&#x27;id&#x27;</span>] = response.xpath(<span class="hljs-string">&#x27;//h1/text()&#x27;</span>).extract()[<span class="hljs-number">0</span>]<br>    <br>    <span class="hljs-keyword">for</span> item_url <span class="hljs-keyword">in</span> <span class="hljs-symbol">item_urls:</span><br>        <span class="hljs-comment"># meta 参数传递</span><br>        <span class="hljs-keyword">yield</span> Request(url=item_url, callback=<span class="hljs-keyword">self</span>.parse_deeper, meta=&#123;<span class="hljs-string">&#x27;item&#x27;</span>: item&#125;)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">parse_deeper</span><span class="hljs-params">(<span class="hljs-keyword">self</span>, response)</span></span><span class="hljs-symbol">:</span><br>    <span class="hljs-comment"># 获取meta记录</span><br>    item = response.meta[<span class="hljs-string">&#x27;item&#x27;</span>]<br>    item[<span class="hljs-string">&#x27;name&#x27;</span>] = response.xpath(<span class="hljs-string">&#x27;//p/text()&#x27;</span>).extract()[<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">yield</span> item<br></code></pre></td></tr></table></figure><h2 id="使用Request的cb-kwargs属性"><a href="#使用Request的cb-kwargs属性" class="headerlink" title="使用Request的cb_kwargs属性"></a>使用<code>Request</code>的<code>cb_kwargs</code>属性</h2><p>将需要传递的内容用<code>Request</code>的<code>cb_kwargs</code>属性保存<br>待到下级解析的时候，从参数中获取即可  </p><blockquote><p>案例：使用<code>Request</code>的<code>cb_kwargs</code>属性传递数据  </p></blockquote><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">parse</span><span class="hljs-params">(<span class="hljs-keyword">self</span>, response)</span></span><span class="hljs-symbol">:</span><br>    request = scrapy.Request(<span class="hljs-string">&#x27;http://www.example.com/index.html&#x27;</span>,<br>                             callback=<span class="hljs-keyword">self</span>.parse_page2,<br>                             cb_kwargs=dict(main_url=response.url))<br>    <span class="hljs-comment"># cb_kwargs增加参数传递</span><br>    request.cb_kwargs[<span class="hljs-string">&#x27;foo&#x27;</span>] = <span class="hljs-string">&#x27;bar&#x27;</span><br>    <span class="hljs-keyword">yield</span> request<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">parse_page2</span><span class="hljs-params">(<span class="hljs-keyword">self</span>, response, main_url, foo)</span></span>:  <span class="hljs-comment"># 从函数参数中拿到结果</span><br>    <span class="hljs-keyword">yield</span> dict(<br>        main_url=main_url,<br>        other_url=response.url,<br>        foo=foo,<br>    )<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>爬虫</tag>
      
      <tag>Scrapy</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis-Python</title>
    <link href="/post/3b797c47/"/>
    <url>/post/3b797c47/</url>
    
    <content type="html"><![CDATA[<h1 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h1><h2 id="redis-py"><a href="#redis-py" class="headerlink" title="redis-py"></a>redis-py</h2><p><code>redis</code>包为<code>python</code>连接 <code>Redis</code>键值数据库 提供了接口。</p><h2 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h2><p>github地址：<a href="https://github.com/andymccurdy/redis-py/">https://github.com/andymccurdy/redis-py/</a><br>一些中文函数参考：<a href="https://www.runoob.com/w3cnote/python-redis-intro.html">https://www.runoob.com/w3cnote/python-redis-intro.html</a></p><h2 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h2><p>Python2.7 或 Python3.5+</p><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pip install redis<br></code></pre></td></tr></table></figure><h2 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&gt;&gt;&gt; import redis<br>&gt;&gt;&gt; r = redis.Redis(<span class="hljs-attribute">host</span>=<span class="hljs-string">&#x27;localhost&#x27;</span>, <span class="hljs-attribute">port</span>=6379, <span class="hljs-attribute">db</span>=0)<br>&gt;&gt;&gt; r.<span class="hljs-builtin-name">set</span>(<span class="hljs-string">&#x27;foo&#x27;</span>, <span class="hljs-string">&#x27;bar&#x27;</span>)<br><span class="hljs-literal">True</span><br>&gt;&gt;&gt; r.<span class="hljs-builtin-name">get</span>(<span class="hljs-string">&#x27;foo&#x27;</span>)<br>b<span class="hljs-string">&#x27;bar&#x27;</span><br></code></pre></td></tr></table></figure><p>对<code>python3.x</code>版本，默认情况下，所有的响应都会返回<code>btyes</code>类型数据<br>如果觉得所有的响应都应该被解码，可以在<code>Redis.__init__</code>填入参数<code>decode_responses=True</code>。如此一来，所有的返回都会被解码。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">r = redis.Redis(<span class="hljs-attribute">host</span>=<span class="hljs-string">&#x27;localhost&#x27;</span>, <span class="hljs-attribute">port</span>=6379, <span class="hljs-attribute">db</span>=0, <span class="hljs-attribute">decode_responses</span>=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure><h1 id="更多细节"><a href="#更多细节" class="headerlink" title="更多细节"></a>更多细节</h1><h2 id="连接池"><a href="#连接池" class="headerlink" title="连接池"></a>连接池</h2><p>在后台，<code>redis-py</code>使用一个连接池去管理 连接到Redis服务的连接<br>默认情况下，你创建的每一个Redis实例都会拥有一个自己的连接池<br>你也可以使用 已创建的连接池实例 来进行连接</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">pool = redis.ConnectionPool(host=<span class="hljs-string">&#x27;localhost&#x27;</span>, port=<span class="hljs-number">6379</span>, db=<span class="hljs-number">0</span>)<br>r = redis.Redis(connection_pool=pool)<br></code></pre></td></tr></table></figure><h2 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h2><p><code>ConnectionPools</code>管理一组连接实例<br><code>redis-py</code>提供两种类型的连接</p><ul><li>基于<code>TCP</code>端口的连接，默认</li><li>基于<code>Unix socket</code>文件的连接，需要redis服务器开启</li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&gt;&gt;&gt; r = redis.Redis(<span class="hljs-attribute">unix_socket_path</span>=<span class="hljs-string">&#x27;/tmp/redis.sock&#x27;</span>)<br>&gt;&gt;&gt;<span class="hljs-built_in"> pool </span>= redis.ConnectionPool(<span class="hljs-attribute">connection_class</span>=YourConnectionClass, <span class="hljs-attribute">your_arg</span>=<span class="hljs-string">&#x27;...&#x27;</span>, <span class="hljs-built_in">..</span>.)<br></code></pre></td></tr></table></figure><h2 id="定时连接检查"><a href="#定时连接检查" class="headerlink" title="定时连接检查"></a>定时连接检查</h2><p>当出现了网络问题，会抛出<code>ConnectionError</code>错误<br><code>redis-py</code>提供能定期检查连接的功能<br>你可以传递<code>health_check_interval</code>参数给<code>Redis</code>或者 <code>ConnectionPool</code>类<br><code>health_check_interval</code>参数的值必须是<code>int</code>类型</p><ul><li>0<br>默认值，关闭连接检查</li><li>一个正数整数n<br>连接检查功能启用，每过n秒检查一次连接</li></ul><h2 id="解析器类"><a href="#解析器类" class="headerlink" title="解析器类"></a>解析器类</h2><p>解析器类被用于处理从<code>Redis服务器</code>返回来的响应<br><code>redis-py</code>提供了两种解析器类型:  </p><ul><li>PythonParser  </li><li>HiredisParser  </li></ul><p>默认情况下，<code>redis-py</code>会先尝试使用<code>HiredisParser</code>，要是发现并没有安装，那么会使用<code>PythonParser</code><br>强烈建议你使用<code>HiredisParser</code>。它的解析效率比另外的那个<strong>快十倍以上</strong>。这个速度差距在进行多<code>key</code>查询的时候会更加明显。</p><blockquote><p>Hiredis是由<code>Redis</code>官方团队基于C语言编写的解析库。</p></blockquote><h3 id="Hiredis安装"><a href="#Hiredis安装" class="headerlink" title="Hiredis安装"></a>Hiredis安装</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">pip <span class="hljs-keyword">install</span> hiredis<br></code></pre></td></tr></table></figure><h2 id="响应回调"><a href="#响应回调" class="headerlink" title="响应回调"></a>响应回调</h2><p><code>client</code>类用一组回调 来将<code>Redis</code>响应转换为合适的python类型<br>这些回调定义在<code>Redis</code>客户端里一个叫<code>RESPONSE_CALLBACKS</code>的字典中</p><p>你可以通过<code>set_response_callback</code>方法添加自定义回调<br>这个方法接收两个参数：命令名 和 对应的回调类<br>这种修改方式仅对于被添加的的实例有效，如果你想定义一个全局的回调类，你应该修改<code>RESPONSE_CALLBACKS</code>类字典  </p><p>回调类接受至少一个参数：响应内容，关键字参数作为命令调用时的参数</p><h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><p><code>Redis</code>实例是线程安全的<br>但是，由于<code>Redis``SELECT</code>命令能选择当前所要使用的<code>database</code>。每次选择<code>database</code>过后。当前选择的<code>database</code>会被保留下来，直到选择另一个<code>database</code>或者关闭连接<br>因此，<code>redis-py</code>没有在客户端实现实现<code>SELECT</code>命令。因为它可能会导致数据库的切换。</p><p>如果你在同一个程序中使用多个<code>Redis``databases</code>，你应该为每一个数据库创建一个单独的实例（或连接池）</p><h2 id="Pipelines"><a href="#Pipelines" class="headerlink" title="Pipelines"></a>Pipelines</h2><p><code>Pipelines</code>是<code>Redis</code>类的一个子类，支持缓存多个命令，然后作为单个请求发送。通过减少TCP请求次数来达到提供性能的目的。<br><code>Pipelines</code>简单使用例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>r = redis.Redis(...)<br><span class="hljs-meta">&gt;&gt;&gt; </span>r.<span class="hljs-built_in">set</span>(<span class="hljs-string">&#x27;bing&#x27;</span>, <span class="hljs-string">&#x27;baz&#x27;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># Use the pipeline() method to create a pipeline instance</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>pipe = r.pipeline()<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># The following SET commands are buffered</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>pipe.<span class="hljs-built_in">set</span>(<span class="hljs-string">&#x27;foo&#x27;</span>, <span class="hljs-string">&#x27;bar&#x27;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>pipe.get(<span class="hljs-string">&#x27;bing&#x27;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># the EXECUTE call sends all buffered commands to the server, returning</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># a list of responses, one for each command.</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>pipe.execute()<br>[<span class="hljs-literal">True</span>, <span class="hljs-string">b&#x27;baz&#x27;</span>]<br></code></pre></td></tr></table></figure><p><code>Pipelines</code>的实现采用流式<code>API</code>，故而你可以采用以下链式调用的方式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>pipe.<span class="hljs-built_in">set</span>(<span class="hljs-string">&#x27;foo&#x27;</span>, <span class="hljs-string">&#x27;bar&#x27;</span>).sadd(<span class="hljs-string">&#x27;faz&#x27;</span>, <span class="hljs-string">&#x27;baz&#x27;</span>).incr(<span class="hljs-string">&#x27;auto_number&#x27;</span>).execute()<br>[<span class="hljs-literal">True</span>, <span class="hljs-literal">True</span>, <span class="hljs-number">6</span>]<br></code></pre></td></tr></table></figure><p><code>Pipelines</code>默认以原子性(事务)的形式执行所有缓存的命令,你也可以禁用这一行为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>pipe = r.pipeline(transaction=<span class="hljs-literal">False</span>)<br></code></pre></td></tr></table></figure><p><code>WATCH</code>命令提供了在事务之前检测一个或多个<code>key</code>值的变化。一旦在事务执行之前，某个值发生了变化，那么事务将被取消然后抛出<code>WatchError</code> 异常。<br>利用<code>watch</code>我们可以实现<code>client-side incr</code>命令：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">with</span> r.pipeline() <span class="hljs-keyword">as</span> pipe:<br><span class="hljs-meta">... </span>    <span class="hljs-keyword">while</span> <span class="hljs-number">1</span>:<br><span class="hljs-meta">... </span>        <span class="hljs-keyword">try</span>:<br><span class="hljs-meta">... </span>            <span class="hljs-comment"># put a WATCH on the key that holds our sequence value</span><br><span class="hljs-meta">... </span>            pipe.watch(<span class="hljs-string">&#x27;OUR-SEQUENCE-KEY&#x27;</span>)<br><span class="hljs-meta">... </span>            <span class="hljs-comment"># after WATCHing, the pipeline is put into immediate execution</span><br><span class="hljs-meta">... </span>            <span class="hljs-comment"># mode until we tell it to start buffering commands again.</span><br><span class="hljs-meta">... </span>            <span class="hljs-comment"># this allows us to get the current value of our sequence</span><br><span class="hljs-meta">... </span>            current_value = pipe.get(<span class="hljs-string">&#x27;OUR-SEQUENCE-KEY&#x27;</span>)<br><span class="hljs-meta">... </span>            next_value = <span class="hljs-built_in">int</span>(current_value) + <span class="hljs-number">1</span><br><span class="hljs-meta">... </span>            <span class="hljs-comment"># now we can put the pipeline back into buffered mode with MULTI</span><br><span class="hljs-meta">... </span>            pipe.multi()<br><span class="hljs-meta">... </span>            pipe.<span class="hljs-built_in">set</span>(<span class="hljs-string">&#x27;OUR-SEQUENCE-KEY&#x27;</span>, next_value)<br><span class="hljs-meta">... </span>            <span class="hljs-comment"># and finally, execute the pipeline (the set command)</span><br><span class="hljs-meta">... </span>            pipe.execute()<br><span class="hljs-meta">... </span>            <span class="hljs-comment"># if a WatchError wasn&#x27;t raised during execution, everything</span><br><span class="hljs-meta">... </span>            <span class="hljs-comment"># we just did happened atomically.</span><br><span class="hljs-meta">... </span>            <span class="hljs-keyword">break</span><br><span class="hljs-meta">... </span>       <span class="hljs-keyword">except</span> WatchError:<br><span class="hljs-meta">... </span>            <span class="hljs-comment"># another client must have changed &#x27;OUR-SEQUENCE-KEY&#x27; between</span><br><span class="hljs-meta">... </span>            <span class="hljs-comment"># the time we started WATCHing it and the pipeline&#x27;s execution.</span><br><span class="hljs-meta">... </span>            <span class="hljs-comment"># our best bet is to just retry.</span><br><span class="hljs-meta">... </span>            <span class="hljs-keyword">continue</span><br></code></pre></td></tr></table></figure><p>有一个非常方便的方法<code>transaction</code>方法来简化这一操作：它包含<code>handling and retrying watch errors</code>的样板代码。第一参数为<code>callable</code>(这个<code>callable</code>只能接受一个<code>Pipeline</code>参数),及多个需要被<code>WATCH</code>的<code>keys</code></p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta">&gt;&gt;&gt;</span> <span class="python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">client_side_incr</span>(<span class="hljs-params">pipe</span>):</span></span><br><span class="hljs-meta">...</span> <span class="python">    current_value = pipe.get(<span class="hljs-string">&#x27;OUR-SEQUENCE-KEY&#x27;</span>)</span><br><span class="hljs-meta">...</span> <span class="python">    next_value = <span class="hljs-built_in">int</span>(current_value) + <span class="hljs-number">1</span></span><br><span class="hljs-meta">...</span> <span class="python">    pipe.multi()</span><br><span class="hljs-meta">...</span> <span class="python">    pipe.<span class="hljs-built_in">set</span>(<span class="hljs-string">&#x27;OUR-SEQUENCE-KEY&#x27;</span>, next_value)</span><br><span class="hljs-meta">&gt;&gt;&gt;</span><br><span class="hljs-meta">&gt;&gt;&gt;</span> <span class="python">r.transaction(client_side_incr, <span class="hljs-string">&#x27;OUR-SEQUENCE-KEY&#x27;</span>)</span><br>[True]<br></code></pre></td></tr></table></figure><hr><h1 id="暂未翻译剩余部分比较多"><a href="#暂未翻译剩余部分比较多" class="headerlink" title="暂未翻译剩余部分比较多"></a>暂未翻译剩余部分比较多</h1><p>详见github文档</p>]]></content>
    
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Scrapy-Request回调函数未调用</title>
    <link href="/post/5b35a369/"/>
    <url>/post/5b35a369/</url>
    
    <content type="html"><![CDATA[<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 在Spider.parse()中</span><br>scrapy.Request(url, headers=self.header, callback=self.parse_detail)<br></code></pre></td></tr></table></figure><p>调试的时候，发现回调函数<code>parse_detail</code>没有被调用<br>出现这个问题的原因是，<code>url</code>被<code>Spider Middleware</code>中间件过滤掉了<br>默认中间件会过滤掉那些不在<code>allowed_domains</code>列表中的请求<code>request</code>  </p><p>两种方法能够使 requests 不被过滤: </p><ol><li>在 allowed_domains 中加入 url </li><li>在 scrapy.Request() 函数中将参数 dont_filter=True 设置为 True</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>爬虫</tag>
      
      <tag>Scrapy</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo-博客文章内部跳转</title>
    <link href="/post/8e73e9cb/"/>
    <url>/post/8e73e9cb/</url>
    
    <content type="html"><![CDATA[<figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs django"><span class="hljs-template-tag">&#123;% <span class="hljs-name">post_link</span> 文章文件名（不要后缀） 文章标题（可选） %&#125;</span><br></code></pre></td></tr></table></figure><p>如文章文件名为Hello-World.md：</p><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs django"><span class="hljs-template-tag">&#123;% <span class="hljs-name">post_link</span> Hello-World %&#125;</span><br><span class="hljs-template-tag">&#123;% <span class="hljs-name">post_link</span> Hello-World 你好世界 %&#125;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>Markdown</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Scrapy-Reids-爬虫</title>
    <link href="/post/21d8017d/"/>
    <url>/post/21d8017d/</url>
    
    <content type="html"><![CDATA[<h1 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h1><p><code>Scrapy</code>本身并不支持分布式。要做分布式爬虫，就需要借助<code>Scrapy-Redis</code>组件。<br>这个组件利用了Redis可以分布式的功能，使得<code>Scrapy</code>能够进行分布式爬取，提高爬虫效率。</p><blockquote><p><strong>分布式爬虫的优点</strong>：<br>　可以充分利用多台机器的IP，带宽，CPU等资源<br><strong>分布式爬虫的问题</strong>：<br>　如何保证不会出现重复爬取。<br>　如何正确的将数据整合到一起。</p></blockquote><h1 id="运行流程"><a href="#运行流程" class="headerlink" title="运行流程"></a>运行流程</h1><p><img src="/Scrapy-Reids-%E7%88%AC%E8%99%AB/1.png"></p><ol><li><code>Engine</code>从<code>Spider</code>中得到第一个<code>Requests</code>进行爬取</li><li><code>ENGIN</code>将<code>Request</code>放入<code>SCHEDULER</code>调度器，并且获取下个<code>Request</code></li><li>为保证不会进行重复爬取，<code>SCHEDULER</code>调度器<code>Requests</code>发送去<code>Redis</code></li><li>若<code>Redis</code>中无爬虫记录，返回<code>Requests</code>到<code>SCHEDULER</code>调度器</li><li><code>SCHEDULER</code>将<code>Requests</code>返回给<code>ENGINE</code>（因为ENGING进行任务调度）</li><li><code>ENGINE</code>发送<code>Requests</code>到<code>Downoader</code>，通过<code>Downloader Middlewares</code> 进行处理（这一步进行Http请求，返回<code>response</code>）</li><li>通过<code>Downloader Middleware</code>进行资源下载(就是html信息)，如果下载完成，通过<code>Dowloader</code>生成一个<code>Resonse</code>并且发送给ENGINE</li><li><code>ENGINE</code> 从<code>DOWNLOADER</code>接收 <code>Resonse</code>,并将<code>Resonse</code>发送给<code>Spider</code>进行处理。<code>Spider</code>通过<code>Spider Middleware</code>进行处理<code>Response</code></li><li><code>Spider</code>处理<code>Response</code> 并且返回<code>items</code>和新的<code>Requests</code>给<code>ENGINE</code>,这部分处理通过<code>Spilder Middleware</code>进行处理</li><li><code>ENGINE</code> 从<code>Spider</code>接收 <code>items</code>,并将<code>items</code>发送给<code>Item Pipeline</code>进行处理</li><li><code>Item Pipeline</code>将<code>items</code>发送给<code>redis</code>保存下来</li></ol><h2 id="一般部署"><a href="#一般部署" class="headerlink" title="一般部署"></a>一般部署</h2><p><img src="/Scrapy-Reids-%E7%88%AC%E8%99%AB/20200417102349957.png"></p><blockquote><p>Redis服务器：<br>　内存要大，只用作记录爬取下来的数据和URL去重<br>爬虫服务器：<br>　执行爬虫代码，进行爬取，获取数据发送给Redis服务器</p></blockquote><h1 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h1><p>github地址:<a href="https://github.com/rmax/scrapy-redis">https://github.com/rmax/scrapy-redis</a><br>文档及其简单，只给了基础设置和一个例子项目。</p><h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pip install scrapy-redis<br></code></pre></td></tr></table></figure><h2 id="setting"><a href="#setting" class="headerlink" title="setting"></a>setting</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Enables scheduling storing requests queue in redis.</span><br>SCHEDULER = <span class="hljs-string">&quot;scrapy_redis.scheduler.Scheduler&quot;</span><br><br><span class="hljs-comment"># Ensure all spiders share same duplicates filter through redis.</span><br>DUPEFILTER_CLASS = <span class="hljs-string">&quot;scrapy_redis.dupefilter.RFPDupeFilter&quot;</span><br><br><span class="hljs-comment"># Default requests serializer is pickle, but it can be changed to any module</span><br><span class="hljs-comment"># with loads and dumps functions. Note that pickle is not compatible between</span><br><span class="hljs-comment"># python versions.</span><br><span class="hljs-comment"># Caveat: In python 3.x, the serializer must return strings keys and support</span><br><span class="hljs-comment"># bytes as values. Because of this reason the json or msgpack module will not</span><br><span class="hljs-comment"># work by default. In python 2.x there is no such issue and you can use</span><br><span class="hljs-comment"># &#x27;json&#x27; or &#x27;msgpack&#x27; as serializers.</span><br><span class="hljs-comment">#SCHEDULER_SERIALIZER = &quot;scrapy_redis.picklecompat&quot;</span><br><br><span class="hljs-comment"># Don&#x27;t cleanup redis queues, allows to pause/resume crawls.</span><br><span class="hljs-comment">#SCHEDULER_PERSIST = True</span><br><br><span class="hljs-comment"># Schedule requests using a priority queue. (default)</span><br><span class="hljs-comment">#SCHEDULER_QUEUE_CLASS = &#x27;scrapy_redis.queue.PriorityQueue&#x27;</span><br><br><span class="hljs-comment"># Alternative queues.</span><br><span class="hljs-comment">#SCHEDULER_QUEUE_CLASS = &#x27;scrapy_redis.queue.FifoQueue&#x27;</span><br><span class="hljs-comment">#SCHEDULER_QUEUE_CLASS = &#x27;scrapy_redis.queue.LifoQueue&#x27;</span><br><br><span class="hljs-comment"># Max idle time to prevent the spider from being closed when distributed crawling.</span><br><span class="hljs-comment"># This only works if queue class is SpiderQueue or SpiderStack,</span><br><span class="hljs-comment"># and may also block the same time when your spider start at the first time (because the queue is empty).</span><br><span class="hljs-comment">#SCHEDULER_IDLE_BEFORE_CLOSE = 10</span><br><br><span class="hljs-comment"># Store scraped item in redis for post-processing.</span><br>ITEM_PIPELINES = &#123;<br>    <span class="hljs-string">&#x27;scrapy_redis.pipelines.RedisPipeline&#x27;</span>: <span class="hljs-number">300</span><br>&#125;<br><br><span class="hljs-comment"># The item pipeline serializes and stores the items in this redis key.</span><br><span class="hljs-comment">#REDIS_ITEMS_KEY = &#x27;%(spider)s:items&#x27;</span><br><br><span class="hljs-comment"># The items serializer is by default ScrapyJSONEncoder. You can use any</span><br><span class="hljs-comment"># importable path to a callable object.</span><br><span class="hljs-comment">#REDIS_ITEMS_SERIALIZER = &#x27;json.dumps&#x27;</span><br><br><span class="hljs-comment"># Specify the host and port to use when connecting to Redis (optional).</span><br><span class="hljs-comment">#REDIS_HOST = &#x27;localhost&#x27;</span><br><span class="hljs-comment">#REDIS_PORT = 6379</span><br><br><span class="hljs-comment"># Specify the full Redis URL for connecting (optional).</span><br><span class="hljs-comment"># If set, this takes precedence over the REDIS_HOST and REDIS_PORT settings.</span><br><span class="hljs-comment">#REDIS_URL = &#x27;redis://user:pass@hostname:9001&#x27;</span><br><br><span class="hljs-comment"># Custom redis client parameters (i.e.: socket timeout, etc.)</span><br><span class="hljs-comment">#REDIS_PARAMS  = &#123;&#125;</span><br><span class="hljs-comment"># Use custom redis client class.</span><br><span class="hljs-comment">#REDIS_PARAMS[&#x27;redis_cls&#x27;] = &#x27;myproject.RedisClient&#x27;</span><br><br><span class="hljs-comment"># If True, it uses redis&#x27; ``SPOP`` operation. You have to use the ``SADD``</span><br><span class="hljs-comment"># command to add URLs to the redis queue. This could be useful if you</span><br><span class="hljs-comment"># want to avoid duplicates in your start urls list and the order of</span><br><span class="hljs-comment"># processing does not matter.</span><br><span class="hljs-comment">#REDIS_START_URLS_AS_SET = False</span><br><br><span class="hljs-comment"># Default start urls key for RedisSpider and RedisCrawlSpider.</span><br><span class="hljs-comment">#REDIS_START_URLS_KEY = &#x27;%(name)s:start_urls&#x27;</span><br><br><span class="hljs-comment"># Use other encoding than utf-8 for redis.</span><br><span class="hljs-comment">#REDIS_ENCODING = &#x27;latin1&#x27;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>爬虫</tag>
      
      <tag>Scrapy</tag>
      
      <tag>Scrapy-Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis</title>
    <link href="/post/bae4ff13/"/>
    <url>/post/bae4ff13/</url>
    
    <content type="html"><![CDATA[<h1 id="Redis文档"><a href="#Redis文档" class="headerlink" title="Redis文档"></a>Redis文档</h1><p>官方网站：<a href="https://redis.io/">https://redis.io/</a></p><h1 id="Redis简介"><a href="#Redis简介" class="headerlink" title="Redis简介"></a>Redis简介</h1><h2 id="什么是Redis"><a href="#什么是Redis" class="headerlink" title="什么是Redis"></a>什么是Redis</h2><p>Redis是一个开源的使用ANSI C语言编写、<strong>遵守BSD协议</strong>、支持网络、可基于内存亦可持久化的日志型、<strong>Key-Value数据库</strong>，并提供多种语言的API。</p><h3 id="什么是BSD开源协议"><a href="#什么是BSD开源协议" class="headerlink" title="什么是BSD开源协议"></a>什么是BSD开源协议</h3><p>一个给予使用者很大自由的协议。基本上使用者可以”为所欲为”,可以自由的使用，修改源代码，也可以将修改后的代码作为开源或者专有软件再发布。</p><h3 id="NoSQL"><a href="#NoSQL" class="headerlink" title="NoSQL"></a>NoSQL</h3><p>NoSQL，泛指非关系型的数据库<br>传统的关系数据库在应付web2.0网站，特别是超大规模和高并发的SNS类型的web2.0纯动态网站已经显得力不从心，暴露了很多难以克服的问题:</p><ul><li>高并发读写</li><li>海量数据的高效存储访问需求</li><li>高可扩展性和和高可用性需求</li></ul><p>NoSQL数据库的产生就是为了解决大规模数据集合多重数据种类带来的挑战，尤其是大数据应用难题。 </p><h4 id="NoSQL类别"><a href="#NoSQL类别" class="headerlink" title="NoSQL类别"></a>NoSQL类别</h4><table><thead><tr><th>NoSQL类别</th><th>相关产品</th><th>典型应用</th><th>数据类型</th><th>优势</th><th>劣势</th></tr></thead><tbody><tr><td>Key-Value存储数据库</td><td>Tokyo Cabinet/Tyrant, Redis, Voldemort</td><td>内容缓存，处理大量数据的高访负载</td><td>键值对</td><td>快速查询</td><td>存储的数据缺少结构化</td></tr><tr><td>列存储数据库</td><td>Cassandra, HBase, Riak</td><td>分布式的文件系统</td><td>以列簇式存储，将同意列数据存在一起</td><td>查询速度快，可扩展性强，更容易进行分布式扩展</td><td>功能相对局限</td></tr><tr><td>文档型数据库</td><td>CouchDB, MongoDB</td><td>Web应用</td><td>一系列键值对（与Key-Value类似，Value是结构化的）</td><td>数据结构要求不严</td><td>查询性能不高，缺乏统一的查询语法</td></tr><tr><td>图形数据库</td><td>Neo4j, InfoGrid, Infinite Graph</td><td>社交网络</td><td>图结构</td><td>利用图结构相关算法</td><td>需要对整个图做计算才能得出结果，不容易做分布式的集群方案</td></tr></tbody></table><h2 id="Redis特点"><a href="#Redis特点" class="headerlink" title="Redis特点"></a>Redis特点</h2><ul><li>性能极高<br>Redis能读的速度是110000次/s,写的速度是81000次/s 。</li><li>丰富的数据类型<br>Redis支持的类型 String, List, Hash, Set 及 Ordered Set 数据类型操作。</li><li>原子<br>Redis的所有操作都是原子性的，意思就是要么成功执行要么失败完全不执行。单个操作是原子性的。多个操作也支持事务，即原子性，通过MULTI和EXEC指令包起来。</li><li>丰富的特性<br>Redis还支持 publish/subscribe, 通知, key 过期等等特性。</li><li>高速读写<br>使用自己实现的分离器，代码量很短，没有lock(MySQL),因此效率高。</li></ul><p>Redis是一个简单的，高效的，分布式的，基于内存的缓存工具。<br>架设好服务器后，通过网络连接（类似数据库），提供Key－Value式缓存服务。<br>简单，是Redis突出的特色。<br>简单可以保证核心功能的稳定和优异。 </p><h2 id="Redis总结"><a href="#Redis总结" class="headerlink" title="Redis总结"></a>Redis总结</h2><p>redis单个key 存入512M大小<br>redis支持多种类型的数据结构(string,list,hash.set.zset)<br>redis 是单线程   原子性<br>redis可以持久化  因为使用了 RDB和AOF机制<br>redis支持集群   而且redis 支持库(0-15) 16个库<br>redis 还可以做消息队列  比如聊天室  IM </p><p>企业级开发中: 可以用作数据库、缓存(热点数据（经常会被查询，但是不经常被修改或者删除的数据)和消息中间件等大部分功能。</p><h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><ol><li>丰富的数据结构  </li><li>高速读写<br>redis使用自己实现的分离器，代码量很短，没有使用lock（MySQL），因此效率非常高。</li></ol><h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><ol><li>持久化<br>Redis直接将数据存储到内存中，要将数据保存到磁盘上，Redis可以使用两种方式实现持久化过程。定时快照（snapshot）：每隔一段时间将整个数据库写到磁盘上，每次均是写全部数据，代价非常高。第二种方式基于语句追加（aof）：只追踪变化的数据，但是追加的log可能过大，同时所有的操作均重新执行一遍，回复速度慢。 </li><li>耗内存<br>占用内存过高。 </li></ol><h1 id="Redis安装"><a href="#Redis安装" class="headerlink" title="Redis安装"></a>Redis安装</h1><h2 id="一般安装"><a href="#一般安装" class="headerlink" title="一般安装"></a>一般安装</h2><h3 id="安装gcc语言编译环境"><a href="#安装gcc语言编译环境" class="headerlink" title="安装gcc语言编译环境"></a>安装gcc语言编译环境</h3><p>Redis是C语言开发，下载的源码需要编译，编译依赖gcc环境</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum -y install gcc automake autoconf libtool make <br></code></pre></td></tr></table></figure><h3 id="安装Redis"><a href="#安装Redis" class="headerlink" title="安装Redis"></a>安装Redis</h3><ol><li>下载源码<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">wget http://download.redis.io/releases/redis-5.0.8.tar.gz<br></code></pre></td></tr></table></figure> 建议官网获取下载地址</li><li>解压<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">tar zxvf redis-5.0.8.tar.gz<br></code></pre></td></tr></table></figure></li><li>进入解压出来的目录<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> redis-5.0.8<br></code></pre></td></tr></table></figure> 注意版本导致的文件夹名称不同</li><li>编译<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">make<br></code></pre></td></tr></table></figure> 看到它说<code>It&#39;s a good idea to run &#39;make test&#39; ;) </code>就代表成了</li><li>安装到指定目录<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">make PREFIX=/usr/<span class="hljs-built_in">local</span>/redis install<br></code></pre></td></tr></table></figure> 这里安装到了<code>/usr/local/redis</code></li></ol><h2 id="Docker安装"><a href="#Docker安装" class="headerlink" title="Docker安装"></a>Docker安装</h2><ol><li><p>拉取镜像  </p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">docker pull redis</span><br></code></pre></td></tr></table></figure></li><li><p>查看是否拉取成功  </p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">docker images</span><br></code></pre></td></tr></table></figure></li><li><p>创建设置文件夹</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">mkdir -p etc<span class="hljs-regexp">/docker/</span>redis/conf<br>mkdir -p etc<span class="hljs-regexp">/docker/</span>redis/data<br></code></pre></td></tr></table></figure><p> 一个用于映射设置，一个用于映射数据  </p></li><li><p>创建配置文件</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">vim etc<span class="hljs-regexp">/docker/</span>redis<span class="hljs-regexp">/conf/</span>redis.conf<br></code></pre></td></tr></table></figure><p> 写入redis配置并保存，<a href="http://download.redis.io/redis-stable/redis.conf">官方默认配置文件</a><br> 下载完以后可以自行修改配置  </p></li><li><p>运行容器  </p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">docker run -itd --name redis -p <span class="hljs-number">6378</span>:<span class="hljs-number">6379</span>  -v <span class="hljs-regexp">/etc/</span>docker<span class="hljs-regexp">/redis/</span>conf<span class="hljs-regexp">/redis.conf:/</span>etc<span class="hljs-regexp">/redis/</span>redis.conf  -v <span class="hljs-regexp">/etc/</span>docker<span class="hljs-regexp">/redis/</span>data:/data  redis  --requirepass <span class="hljs-number">65535</span> --appendonly yes  <br></code></pre></td></tr></table></figure><ul><li>–name redis<br>容器名设置为redis  </li><li>-p 6378:6379<br>映射容器服务的 6379 端口到宿主机的 6378 端口。外部可以直接通过宿主机ip:6378 访问到 Redis 的服务  </li><li>-v /docker/redis/redis.conf:/etc/redis/redis.conf<br>映射配置文件  </li><li>-v /docker/redis/data:/data<br>映射数据目录</li><li>–requirepass 65535<br>设置访问密码为65535</li><li>–appendonly yes<br>开启数据持久化</li></ul></li><li><p>访问控制台  </p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">docker exec -<span class="hljs-keyword">it</span> redis redis-cli<br></code></pre></td></tr></table></figure><p> 如果设置了账户密码  </p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">docker exec -<span class="hljs-keyword">it</span> redis redis-cli -<span class="hljs-keyword">a</span> your_password<br></code></pre></td></tr></table></figure><p>根据自己设置的信息来更改命令</p></li></ol><h1 id="Redis基础"><a href="#Redis基础" class="headerlink" title="Redis基础"></a>Redis基础</h1><h2 id="Redis基本操作"><a href="#Redis基本操作" class="headerlink" title="Redis基本操作"></a>Redis基本操作</h2><h3 id="启动Redis服务端"><a href="#启动Redis服务端" class="headerlink" title="启动Redis服务端"></a>启动Redis服务端</h3><ol><li>来到安装目录<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /usr/<span class="hljs-built_in">local</span>/redis<br></code></pre></td></tr></table></figure></li><li>启动Redis服务<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /usr/<span class="hljs-built_in">local</span>/redis <br>./bin/redis-server<br></code></pre></td></tr></table></figure><img src="/Redis/20200413104109125.png"><br>看到这个蛋糕，就说明你启动成功了</li></ol><h3 id="关闭服务端"><a href="#关闭服务端" class="headerlink" title="关闭服务端"></a>关闭服务端</h3><ul><li>杀进程方式<br>会造成数据丢失<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs perl">ps -ef | <span class="hljs-keyword">grep</span> -i redis  <span class="hljs-comment"># 查询redis进程</span><br><span class="hljs-keyword">kill</span> -<span class="hljs-number">9</span> PID <span class="hljs-comment"># 通过进程id杀进程</span><br></code></pre></td></tr></table></figure></li><li>正常关闭方式<br>客户端执行<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-built_in">shutdown</span><br></code></pre></td></tr></table></figure><h3 id="启动客户端"><a href="#启动客户端" class="headerlink" title="启动客户端"></a>启动客户端</h3></li></ul><ol><li>来到安装目录<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /usr/<span class="hljs-built_in">local</span>/redis<br></code></pre></td></tr></table></figure></li><li>启动Redis客户端<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./bin/redis-cli<br></code></pre></td></tr></table></figure>命令参考：<code>redis-cli –h IP地址 –p 端口 -a 密码</code> </li></ol><h3 id="退出客户端"><a href="#退出客户端" class="headerlink" title="退出客户端"></a>退出客户端</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">键盘上按 Ctrl+C<br></code></pre></td></tr></table></figure><h3 id="远程连接"><a href="#远程连接" class="headerlink" title="远程连接"></a>远程连接</h3><blockquote><p>必须设置密码, 注意防火墙的问题</p></blockquote><p>RedisDesktopManager(收费)：<a href="https://github.com/uglide/RedisDesktopManager">https://github.com/uglide/RedisDesktopManager</a><br>AnotherRedisDesktopManager(免费)：<br><a href="https://github.com/qishibo/AnotherRedisDesktopManager/">https://github.com/qishibo/AnotherRedisDesktopManager/</a></p><h2 id="Redis配置"><a href="#Redis配置" class="headerlink" title="Redis配置"></a>Redis配置</h2><p>Redis定义了很多默认配置<br>但一般我们都会通过手动配置完成<br>Redis的配置文件位于根目录下，文件名为<code>reids.conf</code></p><h3 id="配置文件复制"><a href="#配置文件复制" class="headerlink" title="配置文件复制"></a>配置文件复制</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cp redis-5.0.8/redis.conf /usr/<span class="hljs-built_in">local</span>/redis/<br></code></pre></td></tr></table></figure><p>将配置文件从解压目录，复制到安装目录下</p><h3 id="redis-conf-配置文件详解"><a href="#redis-conf-配置文件详解" class="headerlink" title="redis.conf 配置文件详解"></a>redis.conf 配置文件详解</h3><ul><li><p><strong>绑定的主机地址</strong></p>  <figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">bind</span> <span class="hljs-number">127.0.0.1</span><br></code></pre></td></tr></table></figure><blockquote><p>想要什么ip能连上来，那就绑定好了</p></blockquote></li><li><p><strong>是否为守护进程</strong></p>  <figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">daemonize</span> <span class="hljs-literal">no</span><br></code></pre></td></tr></table></figure><blockquote><p>Redis默认不是以守护进程的方式运行，可以通过该配置项修改，使用yes启用守护进程<br>守护进程：在后台运行并且不受任何终端控制的进程。<br>你用终端打开一个进程，终端被你关了。<br>　如进程为<code>非守护进程</code>，进程会被清除。<br>　如进程为<code>守护进程</code>，则在你关闭终端后，会继续运行。</p></blockquote></li><li><p>指定pidfile路径</p>  <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">pidfile <span class="hljs-regexp">/var/</span>run/redis.pid<br></code></pre></td></tr></table></figure><blockquote><p>当Redis以守护进程方式运行时，Redis默认会把pid写入/var/run/redis.pid文件</p></blockquote></li><li><p><strong>指定Redis监听端口</strong></p>  <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">port</span> <span class="hljs-number">6379</span><br></code></pre></td></tr></table></figure><blockquote><p>默认端口为6379<br>为什么选用6379作为默认端口，因为6379在手机按键上MERZ对应的号码，而MERZ取自意大利歌女Alessia Merz的名字</p></blockquote></li><li><p>当客户端闲置多长时间后关闭连接</p>  <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">timeout</span> <span class="hljs-number">300</span><br></code></pre></td></tr></table></figure><blockquote><p>如果指定为0，表示关闭该功能</p></blockquote></li><li><p>指定日志记录级别</p>  <figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">loglevel verbose</span><br></code></pre></td></tr></table></figure><blockquote><p>Redis总共支持四个级别：debug、verbose、notice、warning，默认为verbose</p></blockquote></li><li><p>日志记录方式，默认为标准输出</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">logfile <span class="hljs-built_in">stdout</span><br></code></pre></td></tr></table></figure><blockquote><p>如果配置Redis为守护进程方式运行，而这里又配置为日志记录方式为标准输出，则日志将会发送给/dev/null</p></blockquote></li><li><p>设置数据库的数量，默认数据库为0</p>  <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">databases</span> <span class="hljs-number">16</span><br></code></pre></td></tr></table></figure><blockquote><p>可以使用<code>SELECT &lt;dbid&gt;</code>命令在连接上指定数据库id<br>id是从0开始的</p></blockquote></li><li><p><strong>指定在多长时间内，有多少次更新操作，就将数据同步到数据文件</strong></p>  <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">save</span> <span class="hljs-number">900</span> <span class="hljs-number">1</span>  # <span class="hljs-number">900</span>秒（<span class="hljs-number">15</span>分钟）内有<span class="hljs-number">1</span>个更改<br><span class="hljs-attribute">save</span> <span class="hljs-number">300</span> <span class="hljs-number">10</span>  # <span class="hljs-number">300</span>秒（<span class="hljs-number">5</span>分钟）内有<span class="hljs-number">10</span>个更改<br><span class="hljs-attribute">save</span> <span class="hljs-number">60</span> <span class="hljs-number">10000</span>  # <span class="hljs-number">60</span>秒内有<span class="hljs-number">10000</span>个更改<br></code></pre></td></tr></table></figure><blockquote><p>可以多个条件配合<br><code>save &lt;seconds&gt; &lt;changes&gt;</code><br>由于东西都存在内存里，断电数据全没，需要定时保存<br>Redis默认配置文件中设置了三个条件</p></blockquote></li><li><p>指定存储至本地数据库时是否压缩数据</p>  <figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">rdbcompression</span> <span class="hljs-literal">yes</span><br></code></pre></td></tr></table></figure><blockquote><p>默认为yes，Redis采用LZF压缩，如果为了节省CPU时间，可以关闭该选项，但会导致数据库文件变的巨大</p></blockquote></li><li><p><strong>指定本地数据库文件名</strong></p>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">dbfilename</span> <span class="hljs-selector-tag">dump</span><span class="hljs-selector-class">.rdb</span><br></code></pre></td></tr></table></figure><blockquote><p>默认值为dump.rdb<br>在你关闭Redis的时候，数据会被存到这个文件里</p></blockquote></li><li><p>指定本地数据库存放目录</p>  <figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dos"><span class="hljs-built_in">dir</span> ./<br></code></pre></td></tr></table></figure><blockquote><p>默认是当前目录</p></blockquote></li><li><p>设置当本机为slav服务时，设置master服务的IP地址及端口，在Redis启动时，它会自动从master进行数据同步</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">slaveof <span class="hljs-tag">&lt;<span class="hljs-name">masterip</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">masterport</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>当master服务设置了密码保护时，slav服务连接master的密码</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">masterauth <span class="hljs-tag">&lt;<span class="hljs-name">master-password</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p><strong>设置Redis连接密码</strong></p>  <figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">requirepass foobared</span><br></code></pre></td></tr></table></figure><blockquote><p>如果配置了连接密码，客户端在连接Redis时需要通过<code>AUTH &lt;password&gt;</code>命令提供密码，默认关闭(无密码)</p></blockquote></li><li><p>设置同一时间最大客户端连接数</p>  <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">maxclients</span> <span class="hljs-number">128</span><br></code></pre></td></tr></table></figure><blockquote><p>默认无限制，Redis可以同时打开的客户端连接数为Redis进程可以打开的最大文件描述符数<br>如果设置 maxclients 0，表示不作限制。<br>当客户端连接数到达限制时，Redis会关闭新的连接并向客户端返回max number of clients reached错误信息</p></blockquote></li><li><p>指定Redis最大内存限制</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">maxmemory <span class="hljs-tag">&lt;<span class="hljs-name">bytes</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>Redis在启动时会把数据加载到内存中，达到最大内存后，Redis会先尝试清除已到期或即将到期的Key，当此方法处理 后，仍然到达最大内存设置，将无法再进行写入操作，但仍然可以进行读取操作。Redis新的vm机制，会把Key存放内存，Value会存放在swap区</p></blockquote></li><li><p>是否在每次更新操作后进行日志记录</p>  <figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">appendonly</span> <span class="hljs-literal">no</span><br></code></pre></td></tr></table></figure><blockquote><p>Redis在默认情况下是异步的把数据写入磁盘，如果不开启，可能会在断电时导致一段时间内的数据丢失。因为 redis本身同步数据文件是按上面save条件来同步的，所以有的数据会在一段时间内只存在于内存中。默认为no</p></blockquote></li><li><p>指定更新日志文件名</p>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">appendfilename</span> <span class="hljs-selector-tag">appendonly</span><span class="hljs-selector-class">.aof</span><br></code></pre></td></tr></table></figure><blockquote><p>默认为appendonly.aof</p></blockquote></li><li><p>指定更新日志条件</p>  <figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">appendfsync everysec</span><br></code></pre></td></tr></table></figure><blockquote><p>共有3个可选值：<br>  no：表示等操作系统进行数据缓存同步到磁盘（快）<br>  always：表示每次更新操作后手动调用fsync()将数据写到磁盘（慢，安全）<br>  everysec：表示每秒同步一次（折中，默认值）</p></blockquote></li><li><p>指定是否启用虚拟内存机制</p>  <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">vm-enabled</span> <span class="hljs-literal">no</span><br></code></pre></td></tr></table></figure><blockquote><p>默认值为no，简单的介绍一下，VM机制将数据分页存放，由Redis将访问量较少的页即冷数据swap到磁盘上，访问多的页面由磁盘自动换出到内存中</p></blockquote></li><li><p>虚拟内存文件路径</p>  <figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle">vm-swap-<span class="hljs-keyword">file</span> <span class="hljs-regexp">/tmp/</span>redis.swap<br></code></pre></td></tr></table></figure><blockquote><p>默认值为/tmp/redis.swap，不可多个Redis实例共享</p></blockquote></li><li><p>将所有大于vm-max-memory的数据存入虚拟内存</p>  <figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mel">vm-<span class="hljs-keyword">max</span>-<span class="hljs-keyword">memory</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><blockquote><p>无论vm-max-memory设置多小,所有索引数据都是内存存储的(Redis的索引数据 就是keys),也就是说,当vm-max-memory设置为0的时候,其实是所有value都存在于磁盘。默认值为0</p></blockquote></li><li><p>Redis swap文件分成了很多的page，一个对象可以保存在多个page上面，但一个page上不能被多个对象共享，vm-page-size是要根据存储的 数据大小来设定的，作者建议如果存储很多小对象，page大小最好设置为32或者64bytes；如果存储很大大对象，则可以使用更大的page，如果不 确定，就使用默认值</p>  <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">vm</span>-page-size <span class="hljs-number">32</span><br></code></pre></td></tr></table></figure></li><li><p>设置swap文件中的page数量</p>  <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">vm</span>-pages <span class="hljs-number">134217728</span><br></code></pre></td></tr></table></figure><blockquote><p>由于页表（一种表示页面空闲或使用的bitmap）是在放在内存中的，，在磁盘上每8个pages将消耗1byte的内存。</p></blockquote></li><li><p>设置访问swap文件的线程数</p>  <figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">vm</span>-<span class="hljs-built_in">max</span>-threads <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><blockquote><p>最好不要超过机器的核数,如果设置为0,那么所有对swap文件的操作都是串行的，可能会造成比较长时间的延迟。默认值为4</p></blockquote></li><li><p>设置在向客户端应答时，是否把较小的包合并为一个包发送，默认为开启</p>  <figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">glueoutputbuf</span> <span class="hljs-literal">yes</span><br></code></pre></td></tr></table></figure></li><li><p>指定在超过一定的数量或者最大的元素超过某一临界值时，采用一种特殊的哈希算法</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">hash</span>-<span class="hljs-built_in">max</span>-zipmap-entries <span class="hljs-number">64</span><br><span class="hljs-built_in">hash</span>-<span class="hljs-built_in">max</span>-zipmap-value <span class="hljs-number">512</span><br></code></pre></td></tr></table></figure></li><li><p>指定是否激活重置哈希</p>  <figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">activerehashing</span> <span class="hljs-literal">yes</span><br></code></pre></td></tr></table></figure><blockquote><p>默认为开启（后面在介绍Redis的哈希算法时具体介绍）</p></blockquote></li><li><p>指定包含其它的配置文件</p>  <figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">include</span> /<span class="hljs-type">path</span>/<span class="hljs-keyword">to</span>/<span class="hljs-keyword">local</span>.conf<br></code></pre></td></tr></table></figure><blockquote><p>可以在同一主机上多个Redis实例之间使用同一份配置文件，而同时各个实例又拥有自己的特定配置文件</p></blockquote></li></ul><h3 id="最基本自定义配置文件"><a href="#最基本自定义配置文件" class="headerlink" title="最基本自定义配置文件"></a>最基本自定义配置文件</h3><ol><li><p>进入对应的安装目录 /usr/local/redis</p></li><li><p>启动守护进程</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">daemonize</span> <span class="hljs-literal">no</span> <span class="hljs-string">-&gt;</span> <span class="hljs-string">daemonize</span> <span class="hljs-literal">yes</span><br></code></pre></td></tr></table></figure></li><li><p>允许本机以外的主机访问</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">bind</span> <span class="hljs-number">127</span>.<span class="hljs-number">0</span>.<span class="hljs-number">01</span> -&gt; # bind <span class="hljs-number">127</span>.<span class="hljs-number">0</span>.<span class="hljs-number">01</span> <br></code></pre></td></tr></table></figure><p> 若是要特定的ip才能访问，也可以设置。</p></li><li><p>设置密码</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">requirepass</span> 设置密码 设置数据库密码<br></code></pre></td></tr></table></figure><blockquote><p>Redis速度很快，在一台好的服务器里，一个外部用户能进行150000次/秒 的密码尝试，这意味着你需要设置好密码来防止暴力破解。</p></blockquote></li><li><p>用自己的配置文件启动<br>Redis根目录下</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">.<span class="hljs-regexp">/bin/</span>redis-server ./redis.conf<br></code></pre></td></tr></table></figure><p>注意配置文件路径的问题，这里设置的是当前路径下的reids.conf配置文件</p></li></ol><h2 id="Redis内存维护策略"><a href="#Redis内存维护策略" class="headerlink" title="Redis内存维护策略"></a>Redis内存维护策略</h2><p>redis作为优秀的中间缓存件，时常会存储大量的数据，即使采取了集群部署来动态扩容，也应该即使的整理内存，维持系统性能。</p><h3 id="在redis中有两种解决方案，"><a href="#在redis中有两种解决方案，" class="headerlink" title="在redis中有两种解决方案，"></a>在redis中有两种解决方案，</h3><h4 id="数据设置超时时间"><a href="#数据设置超时时间" class="headerlink" title="数据设置超时时间"></a>数据设置超时时间</h4><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vbnet">expire <span class="hljs-keyword">key</span> time(以秒为单位)  <span class="hljs-meta"># 最常用方式</span><br>setex(<span class="hljs-built_in">String</span> <span class="hljs-keyword">key</span>, int seconds, <span class="hljs-built_in">String</span> value)  <span class="hljs-meta"># 字符串独有方式</span><br></code></pre></td></tr></table></figure><ul><li>除了字符串有自己独有设置过期时间的方式外，其他方法都需要依靠expire方法来设置过期时间</li><li>如果没有设置时间，那么换成永不过期</li><li>如果设置了过期时间，只有又想让缓存永不过期，使用persist key</li></ul><h4 id="采用LRU算法动态将不用的数据删除"><a href="#采用LRU算法动态将不用的数据删除" class="headerlink" title="采用LRU算法动态将不用的数据删除"></a>采用LRU算法动态将不用的数据删除</h4><blockquote><p>LRU是Least Recently Used的缩写，即最近最少使用，是一种常用的页面置换算法，选择最近最久未使用的页面予以淘汰。</p></blockquote><ol><li><strong>volatile-lru</strong>：设定超时时间的数据中,删除最不常使用的数据.</li><li><strong>allkeys-lru</strong>：查询所有的key中最近最不常使用的数据进行删除，这是应用最广泛的策略.</li><li>volatile-random：在已经设定了超时的数据中随机删除.</li><li>allkeys-random：查询所有的key,之后随机删除.</li><li>volatile-ttl：查询全部设定超时时间的数据,之后排序,将马上将要过期的数据进行删除操作.</li><li>noeviction：如果设置为该属性,则不会进行删除操作,如果内存溢出则报错返回.<ul><li>volatile-lfu：从所有配置了过期时间的键中驱逐使用频率最少的键</li><li>allkeys-lfu：从所有键中驱逐使用频率最少的键</li></ul></li></ol><h2 id="Redis命令"><a href="#Redis命令" class="headerlink" title="Redis命令"></a>Redis命令</h2><p>Redis命令 用于在 Redis 上执行操作</p><blockquote><p>Redis支持数据类型：String（字符串），hash（哈希），list(列表)，set(集合)，zset(sortedset)(有序集合)……</p></blockquote><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><h4 id="key管理"><a href="#key管理" class="headerlink" title="key管理"></a>key管理</h4><h5 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h5><ul><li><code>del &lt;key_name&gt;</code><br>删除<code>key</code></li></ul><h5 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h5><ul><li><code>rename &lt;key_name&gt; &lt;new_key_name&gt;</code><br>重命名<code>key</code>为<code>new_key</code></li><li><code>MOVE &lt;key_name&gt; &lt;db&gt;</code><br>将当前数据库的key移动到给定的数据库db中</li></ul><h5 id="查询相关"><a href="#查询相关" class="headerlink" title="查询相关"></a>查询相关</h5><ul><li><code>keys *</code><br>返回所有满足条件的<code>key</code><br>可以模糊匹配，比如<code>keys aaa*</code> 代表abc开头的所有<code>key</code><br>通配符:<br>　<code>*</code>：代表所有<br>　<code>?</code>: 代表一个字符</li><li><code>exists &lt;key_name&gt;</code><br>是否存在指定<code>key</code>，存在返回1，不存在返回0</li><li><code>type &lt;key_name&gt;</code><br>返回key对应的值存储的数据类型</li></ul><h5 id="过期时间相关"><a href="#过期时间相关" class="headerlink" title="过期时间相关"></a>过期时间相关</h5><ul><li><code>expire &lt;key_name&gt; &lt;second&gt;</code><br>设置某个key的过期时间，时间单位为 秒</li><li><code>PEXPIRE &lt;key_name&gt; &lt;millisecond&gt;</code><br>设置某个key的过期时间，时间单位为 毫秒</li><li><code>ttl &lt;key_name&gt;</code><br>查看剩余时间，返回key剩余生存时间，时间单位为 秒<br>当<code>key</code>不存在，返回-2<br>当<code>key</code>存在，但没有设置过期时间时，返回-1</li><li><code>pttl &lt;key_name&gt;</code><br>查看剩余时间，返回<code>key</code>剩余生存时间，时间单位为 毫秒</li><li><code>persist &lt;key_name&gt;</code><br>取消过期时间</li></ul><h1 id="key命名规范"><a href="#key命名规范" class="headerlink" title="key命名规范"></a>key命名规范</h1><p>单个<code>key</code>只允许存入512M</p><ul><li>一般用<code>:</code>来分隔信息<br>例如 <code>学校:班级:学号</code>  </li><li>不要太长，不要太短<br>太长消耗内存，也降低查找效率，太短可读性会降低  </li><li>同一个项目中，key要有统一的命名模式</li><li>建议全部大写<br>注意是会区分大小写的</li></ul><blockquote><p>参考：</p></blockquote><ol><li>第一段放置项目名或缩写</li><li>第二段把表名转换为key前缀</li><li>第三段放置用于区分区<code>key</code>的字段, 对应<code>mysql</code>中的主键的列名</li><li>第四段放置主键值</li></ol><h1 id="Redis数据类型"><a href="#Redis数据类型" class="headerlink" title="Redis数据类型"></a>Redis数据类型</h1><h2 id="String类型"><a href="#String类型" class="headerlink" title="String类型"></a>String类型</h2><h3 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h3><p>String类型是最基本的数据类型，一个键最大能存512MB<br>String数据结构是简单的key-value类型，value值不仅可以是String，也可以是数字，是包含很多种类型的特殊类型<br>String类型是二进制安全的，可以包含任何数据</p><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p>保存字符串<br>保存图片<br>统计数量（点赞数，浏览数之类）</p><blockquote><p>其自增自减指令具有原子操作的特性，而且redis性能很好</p></blockquote><h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><h4 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h4><ul><li><code>set &lt;key_name&gt; &lt;value&gt;</code><br>设置值。同一key多次赋值会覆盖，无视类型</li><li><code>mget &lt;key_name1&gt; &lt;value1&gt; &lt;key_name2&gt;.....</code><br>一次性设置多个值</li><li><code>setnx &lt;key_name&gt; &lt;value&gt;</code><br>设置值。分布式锁的方案之一<br>　如果<code>key</code>不存在，则设值并返回1<br>　如果<code>key</code>存在，则不设值并返回0</li><li><code>setnx &lt;key_name&gt; &lt;life_time&gt; &lt;value&gt;</code><br>设置值。并设置过期时间，单位秒</li></ul><h4 id="取值"><a href="#取值" class="headerlink" title="取值"></a>取值</h4><ul><li><code>get &lt;key_name&gt;</code><br>获取指定<code>key</code>的值<br>　若不存在，返回<code>nil</code>。<br>　若key的值不是字符串类型，返回一个错误</li><li><code>mget &lt;key_name1&gt; &lt;key_name2&gt; &lt;key_name3&gt;.....</code><br>获取多个<code>key</code>的值</li><li><code>getrange &lt;key_name&gt; &lt;start&gt; &lt;end&gt;</code><br>获取存储在指定<code>key</code>中的字符串的子串。<br>字符截取范围有<code>start</code>和<code>end</code>两个偏移量决定（包括其本身）<br>相当于数组下标切片</li><li><code>getbit &lt;key_name&gt; offset</code><br>获取存储在指定<code>key</code>中的字符串的指定偏移量上的bit</li><li><code>getset &lt;key_name&gt; &lt;value&gt;</code><br>设定<code>key</code>的值，并返回<code>key</code>的旧值<br>当<code>key</code>不存在时，返回<code>nil</code></li><li><code>strlen &lt;key_name&gt;</code><br>获取<code>key</code>所存储的字符串值的长度</li></ul><h4 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h4><ul><li><code>del &lt;key_name&gt;</code><br>删除<code>key</code></li></ul><h4 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h4><ul><li><code>append &lt;key_name&gt; &lt;value&gt;</code><br>将value追加到指定key的末尾<br>若不存在，则为之赋值</li></ul><h4 id="自增-自减"><a href="#自增-自减" class="headerlink" title="自增/自减"></a>自增/自减</h4><p>使用自增或自减，键值必须为数字类型，否则报错</p><ul><li><code>incr &lt;key_name&gt;</code><br>将<code>key</code>中存储的数字值加1<br>若<code>key</code>不存在，那么<code>key</code>的值初始化为0，然后再执行incr操作</li><li><code>decr &lt;key_name&gt;</code><br>将<code>key</code>中存储的数字值减1</li><li><code>incrby &lt;key_name&gt; &lt;int_step&gt;</code><br>将<code>key</code>中存储的数字值加<code>int_step</code></li><li><code>decrby &lt;key_name&gt; &lt;int_step&gt;</code><br>将<code>key</code>中存储的数字值减<code>int_step</code></li></ul><h2 id="Hash类型"><a href="#Hash类型" class="headerlink" title="Hash类型"></a>Hash类型</h2><p><code>Hash</code>类型的键值存放的是<code>field</code>（域）和<code>value</code>（值）的映射表</p><blockquote><p>没错，套娃的感觉</p></blockquote><p>Hash特别适合用于存储对象的信息<br>相比于将对象类型存储在String类型中，存储在Hash类型中能节约更多的内存空间<br>每个Hash能存储2^32-1键值对</p><h3 id="场景-1"><a href="#场景-1" class="headerlink" title="场景"></a>场景</h3><p>存储一个对象<br>Hash是最接近关系型数据库结构的数据类型。</p><blockquote><p>为什么不用String存储一个对象？<br>存储对象最重要是通过id找到对象。</p><ul><li>若是在key中增加id的信息</li><li>当对象的字段变多，因为存储/传递<code>key</code>中的id所消耗的资源会变多。</li><li>若是在key的值单纯为拼接了很多信息的String</li><li>每次更改，查询都需要进行 序列化或反序列化（指字符串转为对象 或 对象转为字符串），浪费资源。</li><li>查询时一返回就返回整个字符串，浪费资源。</li><li>修改时会将整个字符串锁住，无法访问信息，浪费资源。</li></ul></blockquote><h3 id="Hash命令"><a href="#Hash命令" class="headerlink" title="Hash命令"></a>Hash命令</h3><h4 id="赋值-1"><a href="#赋值-1" class="headerlink" title="赋值"></a>赋值</h4><ul><li><code>hset &lt;key_name&gt; &lt;field&gt; &lt;value&gt;</code><br>指定key,存放<code>field</code>-<code>value</code></li><li><code>hmset &lt;key_name&gt; &lt;field_1&gt; &lt;value_1&gt; &lt;field_2&gt; &lt;value_2&gt;......</code><br>同时设置多个<code>field</code>-<code>value</code></li><li><code>hsetnx &lt;key_name&gt; &lt;field&gt; &lt;value&gt;</code><br>只在字段<code>field</code>不存在时，设置<code>Hash</code>字段的值</li></ul><h4 id="取值-1"><a href="#取值-1" class="headerlink" title="取值"></a>取值</h4><ul><li><code>hget &lt;key_name&gt; &lt;field&gt;</code><br>获取存储在<code>Hash</code>中的指，并根据<code>Field</code>得到<code>value</code></li><li><code>hmget &lt;key_name&gt; &lt;field_1&gt; &lt;field_2&gt; &lt;field_3&gt;.......</code><br>获取存储在<code>Hash</code>中的指，并根据多个<code>Field</code>得到多个<code>value</code></li><li><code>hgetall &lt;key_name&gt;</code><br>返回<code>Hash</code>中所有的字段</li><li><code>hlen &lt;key_name&gt;</code><br>返回<code>Hash</code>中字段的数量</li><li><code>hexists &lt;key_name&gt; &lt;field&gt;</code><br>查看<code>Hash</code>中的指定<code>Field</code>是否存在</li></ul><h4 id="删除-2"><a href="#删除-2" class="headerlink" title="删除"></a>删除</h4><ul><li><code>del &lt;key_name&gt;</code><br>删除<code>key</code></li><li><code>hdel &lt;key_name&gt; &lt;field_1&gt; &lt;field_2&gt;......</code><br>删除<code>key</code>中的一些field</li></ul><h4 id="自增、自减"><a href="#自增、自减" class="headerlink" title="自增、自减"></a>自增、自减</h4><ul><li><code>hincrby &lt;key_name&gt; &lt;field&gt; &lt;int_step&gt;</code><br>为对应<code>key</code>的对应<code>field</code>字段加上<code>int</code>类型增量<code>int_step</code></li><li><code>hincrbyfloat &lt;key_name&gt; &lt;field&gt; &lt;float_step&gt;</code><br>为对应<code>key</code>的对应<code>field</code>字段加上<code>float</code>类型增量<code>float_step</code></li></ul><h2 id="List类型"><a href="#List类型" class="headerlink" title="List类型"></a>List类型</h2><p>链表结构集合。<br>既可以作为队列，也可以作为栈</p><h3 id="场景-2"><a href="#场景-2" class="headerlink" title="场景"></a>场景</h3><p>数据量大的数据删减<br>任务队列</p><h3 id="List命令"><a href="#List命令" class="headerlink" title="List命令"></a>List命令</h3><h4 id="赋值-2"><a href="#赋值-2" class="headerlink" title="赋值"></a>赋值</h4><ul><li><code>lpush &lt;key_name&gt; &lt;value_1&gt; &lt;value_2&gt;......</code><br>将一个或多个值插入到列表左侧</li><li><code>rpush &lt;key_name&gt; &lt;value_1&gt; &lt;value_2&gt;......</code><br>将一个或多个值插入到列表右侧</li><li><code>lpushx &lt;key_name&gt; &lt;value&gt;</code><br>将一个或多个值插入到列表左侧，若列表不存在，操作无效。</li><li><code>rpushx &lt;key_name&gt; &lt;value&gt;</code><br>将一个或多个值插入到列表右侧，若列表不存在，操作无效。</li></ul><h4 id="取值-2"><a href="#取值-2" class="headerlink" title="取值"></a>取值</h4><ul><li><code>llen &lt;key_name&gt;</code><br>获取列表长度</li><li><code>lindex &lt;key_name&gt; &lt;index&gt;</code><br>通过索引获取列表中的指定元素</li><li><code>lrange &lt;key_name&gt; &lt;start&gt; &lt;end&gt;</code><br>通过索引范围获取列表中的元素</li></ul><h4 id="删除-3"><a href="#删除-3" class="headerlink" title="删除"></a>删除</h4><ul><li><code>del &lt;key_name&gt;</code><br>删除<code>key</code></li><li><code>lpop &lt;key_name&gt;</code><br>删除并返回列表左侧第一个元素</li><li><code>rpop &lt;key_name&gt;</code><br>删除并返回列表右侧第一个元素</li><li><code>blpop &lt;key_name&gt; &lt;timeout&gt;</code><br>删除并返回列表左侧第一个元素，若当前<code>List</code>中没有元素，那么会阻塞列表，直到等待超时 或 发现可弹出元素为之<blockquote><p>若timeout不设置，那么会永久等待</p></blockquote></li><li><code>brpop &lt;key_name&gt; &lt;timeout&gt;</code><br>删除并返回列表右侧第一个元素，若当前<code>List</code>中没有元素，那么会阻塞列表，直到等待超时 或 发现可弹出元素为之<br>若<code>timeout</code>不设置，那么会永久等待</li><li><code>ltrim &lt;key_name&gt; &lt;int_start&gt; &lt;int_stop&gt;</code><br>让列表只保留<code>int_start</code>与<code>int_stop</code>区间内的元素，区间外的元素删除</li></ul><h4 id="修改-1"><a href="#修改-1" class="headerlink" title="修改"></a>修改</h4><ul><li><code>lset &lt;key_name&gt; &lt;index&gt; &lt;value&gt;</code><br>通过索引设置<code>List</code>元素的值</li><li><code>linsert &lt;key_name&gt; before|after &lt;element&gt; &lt;value&gt;</code><br>在指定key对应的列表元素的 前或后 插入一个值<br><code>element</code>为值，并非序号</li><li><code>rpoplpush &lt;key_name_1&gt; &lt;key_name_2&gt;</code><br>将<code>key_name_1</code>对应列表最右侧元素弹出,并添加到<code>key_name_2</code>对应列表最左侧<br>可以指定相同的<code>key</code>，形成列表循环</li><li><code>brpoplpush &lt;key_name_1&gt; &lt;key_name_2&gt; timeout</code><br>从<code>key_name_1</code>对应列表最右侧弹出一个值，将弹出的值插入<code>key_name_2</code>对应列表的最左侧。<br>若列表没有元素会阻塞列表直到超时或发现可弹元素为止</li></ul><h2 id="Set类型"><a href="#Set类型" class="headerlink" title="Set类型"></a>Set类型</h2><p><code>Set</code>类型是<code>String</code>类型的无序集合<br>每一个集合成员是唯一的，不会也不能出现重复的数据<br>集合中最多能有 2^32 -1 个成员（约40亿）</p><h3 id="场景-3"><a href="#场景-3" class="headerlink" title="场景"></a>场景</h3><p>需要用到差，并，交这种运算的地方<br>避免重复</p><h3 id="Set命令"><a href="#Set命令" class="headerlink" title="Set命令"></a>Set命令</h3><h4 id="赋值-3"><a href="#赋值-3" class="headerlink" title="赋值"></a>赋值</h4><ul><li><code>sadd &lt;key_name&gt; &lt;menber_1&gt; &lt;menber_2&gt; ......</code><br>向集合添加一个或多个成员</li></ul><h4 id="取值-3"><a href="#取值-3" class="headerlink" title="取值"></a>取值</h4><ul><li><code>scard &lt;key_name&gt;</code><br>获取集合的成员数</li><li><code>smembers &lt;key_name&gt;</code><br>返回集合的所有成员</li><li><code>sismember &lt;key_name&gt; &lt;member&gt;</code><br>判断<code>member</code>是否为<code>key</code>集合的成员</li><li><code>srandmamber &lt;key_name&gt; &lt;int_count&gt;</code><br>返回<code>int_count</code>个结合中的元素</li></ul><h4 id="删除-4"><a href="#删除-4" class="headerlink" title="删除"></a>删除</h4><ul><li><code>del &lt;key_name&gt;</code><br>删除<code>key</code></li><li><code>srem &lt;key_name&gt; &lt;menber_1&gt; &lt;menber_2&gt; ......</code><br>删除集合中的一个或多个成员</li><li><code>spop &lt;key_name&gt; &lt;int_count&gt;</code><br>移除并返回集合中的<code>int_count</code>个随机元素</li><li><code>smove &lt;key_name_1&gt; &lt;key_name_2&gt; &lt;member&gt;</code><br>将成员<code>menber</code>从<code>key_name_1</code>集合移动到<code>key_name_2</code>集合中去</li></ul><h4 id="集合操作"><a href="#集合操作" class="headerlink" title="集合操作"></a>集合操作</h4><h5 id="差集"><a href="#差集" class="headerlink" title="差集"></a>差集</h5><ul><li><code>sdiff &lt;key_name_1&gt; &lt;key_name_2&gt; ......</code><br>返回给定所有集合的差集</li><li><code>sdiffstore &lt;final_key_name&gt; &lt;key_name_1&gt; &lt;key_name_2&gt;......</code><br>返回给定的集合的差集，并保存在<code>final_key_name</code>中</li></ul><h5 id="交集"><a href="#交集" class="headerlink" title="交集"></a>交集</h5><ul><li><code>sinter &lt;key_name_1&gt; &lt;key_name_2&gt; ......</code><br>返回给定所有集合的交集</li><li><code>sinterstore &lt;final_key_name&gt; &lt;key_name_1&gt; &lt;key_name_2&gt;......</code><br>返回给定的集合的交集，并保存在<code>final_key_name</code>中</li></ul><h5 id="并集"><a href="#并集" class="headerlink" title="并集"></a>并集</h5><ul><li><code>sunion &lt;key_name_1&gt; &lt;key_name_2&gt; ......</code><br>返回给定所有集合的并集</li><li><code>sunionstore &lt;final_key_name&gt; &lt;key_name_1&gt; &lt;key_name_2&gt;......</code><br>返回给定的集合的并集，并保存在<code>final_key_name</code>中</li></ul><h2 id="ZSet类型"><a href="#ZSet类型" class="headerlink" title="ZSet类型"></a>ZSet类型</h2><p>有序集合<br>每一个元素都会关联一个<code>double</code>类型的分数，<code>Redis</code>通过记录的分数来对集合进行 <code>从小到大</code> 的排序<br>与<code>Set</code>类型一样，同一个集合内，不允许出现重复元素<br>分数允许重复<br>最多成员数为<code>2^32 -1</code>（约40亿）</p><h3 id="场景-4"><a href="#场景-4" class="headerlink" title="场景"></a>场景</h3><p>排行榜</p><h3 id="Set命令-1"><a href="#Set命令-1" class="headerlink" title="Set命令"></a>Set命令</h3><h4 id="赋值-4"><a href="#赋值-4" class="headerlink" title="赋值"></a>赋值</h4><ul><li><code>zadd &lt;key_name&gt; &lt;socre_1&gt; &lt;score_1&gt; &lt;socre_2&gt; &lt;score_2&gt;......</code><br>向有序集合添加一个或多个成员，或更新已存在成员的分数</li></ul><h4 id="取值-4"><a href="#取值-4" class="headerlink" title="取值"></a>取值</h4><ul><li><code>zcard &lt;key_name&gt;</code><br>获取有序集合成员数</li><li><code>zcount &lt;key_name&gt; &lt;min&gt; &lt;max&gt;</code><br>计算在有序集合中，分数处于<code>min</code>与<code>max</code>之间的成员数</li><li><code>zrank &lt;key_name&gt; &lt;menber&gt;</code><br>返回有序集合中指定<code>menber</code>的索引</li><li><code>zrange &lt;key_name&gt; &lt;start&gt; &lt;stop&gt;</code><br>返回有序集合指定 索引区间 内的成员(低到高)<br>若<code>start=0 stop=-1</code>则为所有</li><li><code>zrevrange &lt;key_name&gt; &lt;start&gt; &lt;stop&gt;</code><br>返回有序集合指定 索引区间 内的成员(高到低)</li><li><code>zrangebyscore &lt;key_name&gt; &lt;min&gt; &lt;max&gt;</code><br>返回有序集合指定 分数区间 内的成员(低到高)</li><li><code>zrevrangebyscore &lt;key_name&gt; &lt;max&gt; &lt;min&gt;</code><br>返回有序集合指定 分数区间 内的成员(高到低)</li></ul><h4 id="删除-5"><a href="#删除-5" class="headerlink" title="删除"></a>删除</h4><ul><li><code>del &lt;key_name&gt;</code><br>删除<code>key</code></li><li><code>zrem &lt;key_name&gt; &lt;member_1&gt; &lt;member_2&gt;</code><br>删除有序集合中的一个或多个成员</li><li><code>zremrangebyrank &lt;key_name&gt; &lt;start&gt; &lt;stop&gt;</code><br>删除有序集合中给定的 排名区间 的所有成员（第一名为0，从低到高） </li><li><code>zremrangebyscore &lt;key_name&gt; &lt;min&gt; &lt;max&gt;</code><br>删除有序集合中给定的 分数区间 的所有成员（第一名为0，从低到高） </li></ul><h4 id="自增"><a href="#自增" class="headerlink" title="自增"></a>自增</h4><ul><li><code>zincrby &lt;key_name&gt; &lt;increment&gt; &lt;member&gt;</code><br>增加<code>menber</code>元素分数<code>increment</code>点</li></ul><h2 id="HyperLogLog类型"><a href="#HyperLogLog类型" class="headerlink" title="HyperLogLog类型"></a>HyperLogLog类型</h2><p>用来做基数统计</p><blockquote><p><strong>什么是基数</strong><br>数据集{1, 3,5, 7, 5, 1, 9} 的 基数集为{1, 3, 5, 7, 9}</p></blockquote><ul><li>在输入袁术的数量或体积非常非常大时，计算基数所需的空间总是固定的，并且很小。</li><li>每个<code>HyperLogLog</code>只需要 12KB内存 ，可以计算接近2^64个不同元素的基数</li><li>核心是基数估计算法，最终数值会有一定误差</li><li> <strong><code>HyperLogLog</code> 只会根据输入的元素来计算基数，并不会存储元素本身</strong></li></ul><h3 id="场景-5"><a href="#场景-5" class="headerlink" title="场景"></a>场景</h3><p>数据量大的数据统计<br>注意，如果数据量小，反而会浪费空间</p><h3 id="HyperLogLog命令"><a href="#HyperLogLog命令" class="headerlink" title="HyperLogLog命令"></a>HyperLogLog命令</h3><ul><li><code>pfadd &lt;key_name&gt; &lt;element_1&gt; &lt;element_2&gt;</code><br>添加指定元素到<code>HyperLogLog</code>中</li><li><code>pfcount &lt;key_name_1&gt; &lt;key_name_2&gt;</code><br>返回给定的<code>HyperLogLog</code>基数估算值</li><li><code>pfmerge &lt;key_name_1&gt; &lt;key_name_2&gt; &lt;key_name_2&gt;</code><br>将多个<code>HyperLogLog</code>合并到<code>key_name_1</code>中</li></ul><h1 id="发布订阅-pub-sub"><a href="#发布订阅-pub-sub" class="headerlink" title="发布订阅(pub/sub)"></a>发布订阅(pub/sub)</h1><p><code>Redis</code>发布订阅(pub/sub)是一种消息通信模式<br>发送者(pub)发送消息，订阅者(sub)接受消息<br>客户端可以订阅任意数量的频道  </p><p>三个客户端订阅<code>频道channel1</code><br><img src="/Redis/20200826121324114.png"><br>订阅了以后，有新的消息来的话会通过<code>PUBLISH</code>命令发送给<code>频道channel1</code>  </p><h2 id="常用命令-1"><a href="#常用命令-1" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="订阅"><a href="#订阅" class="headerlink" title="订阅"></a>订阅</h3><ul><li><code>SUBSCRIBE channel [channel1.....]</code><br>订阅给定的一个或多个频道  </li><li><code>PSUBSCRIBE pattern [pattern]</code><br>订阅一个或多个符合给定模式的频道  </li></ul><h3 id="消息发布"><a href="#消息发布" class="headerlink" title="消息发布"></a>消息发布</h3><ul><li><code>PBULISH channel1 message</code><br>将消息发布到指定频道  </li></ul><h3 id="退订"><a href="#退订" class="headerlink" title="退订"></a>退订</h3><ul><li><code>UNSUBSCRIBE [channel....]</code><br>退订给定的频道  </li><li><code>PUNSUBSCRIBE [pattern]</code><br>退订给定模式的频道  </li></ul><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>博客订阅，微信公众号订阅，新闻订阅等  </p><h1 id="多数据库"><a href="#多数据库" class="headerlink" title="多数据库"></a>多数据库</h1><p>数据库是由一个整数索引标识的，而不是数据库名称<br>默认情况下链接到数据库0<br>你可以自己在配置文件下设置数据库数量  </p><h2 id="常用命令-2"><a href="#常用命令-2" class="headerlink" title="常用命令"></a>常用命令</h2><ul><li><code>select 数据库索引数</code><br>切换数据库  </li><li><code>move key 目标数据库索引数</code><br>移动数据到另一个库中  </li><li><code>flushdb</code><br>清空当前数据库所有的key  </li><li><code>flushall</code><br>清空整个Redis数据库所有key  </li></ul><h1 id="Redis事务"><a href="#Redis事务" class="headerlink" title="Redis事务"></a>Redis事务</h1><p>Redis事务可以一次执行多个命令(单独步骤中执行一组命令)  </p><blockquote><p>批量操作在发送EXEC命令前被放入队列缓存<br>收到EXEC命令后，进入事务执行，事务中的任意命令执行失败，其余命令依然执行<br>事务进行过程中，客户端提交的命令不会插入到事务执行命令序列中  </p></blockquote><p>Redis会将一个事务中的所有命令序列化，然后按顺序执行<br>执行中不会被其他命令插入，不允许加塞行为<br>并没有回滚机制  </p><h2 id="常用命令-3"><a href="#常用命令-3" class="headerlink" title="常用命令"></a>常用命令</h2><p><code>DISCARD</code><br>取消事务<br><code>EXEC</code><br>执行所有事务块内的命令<br><code>MULTI</code><br>标记一个事务块的开始<br><code>UNWATCH</code><br>取消WATCH命令对所有key的监视<br><code>WATCH key [key.....]</code><br>监视一个或多个Key，如果这些key被改动，那么事务将被打断  </p><h2 id="事务流程"><a href="#事务流程" class="headerlink" title="事务流程"></a>事务流程</h2><ol><li>开始事务</li><li>命令入队</li><li>执行事务</li></ol><h3 id="示例1-A向B转50元"><a href="#示例1-A向B转50元" class="headerlink" title="示例1 A向B转50元"></a>示例1 A向B转50元</h3><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">multi <span class="hljs-comment"> // 事务开始</span><br><span class="hljs-built_in">get</span> account:<span class="hljs-keyword">a</span> <span class="hljs-comment"> // 获取a账户金额</span><br>incrby account:b <span class="hljs-number">50</span> <span class="hljs-comment"> // b账户增加50元</span><br>decrby account:<span class="hljs-keyword">a</span> <span class="hljs-number">50</span> <span class="hljs-comment"> // a账户减少50元</span><br><span class="hljs-built_in">get</span> account:<span class="hljs-keyword">a</span> <span class="hljs-comment"> // 得到a账户余额</span><br><span class="hljs-built_in">get</span> account:b <span class="hljs-comment"> // 得到b账户余额</span><br>exec <span class="hljs-comment"> // 执行队列</span><br></code></pre></td></tr></table></figure><h3 id="示例2-DISCARD放弃队列运行"><a href="#示例2-DISCARD放弃队列运行" class="headerlink" title="示例2 DISCARD放弃队列运行"></a>示例2 DISCARD放弃队列运行</h3><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gams">multi  <span class="hljs-comment">// 事务开始</span><br><span class="hljs-keyword">set</span> aa <span class="hljs-comment">123</span><br>get <span class="hljs-comment">aa</span><br>discard<br></code></pre></td></tr></table></figure><p>实际上什么都不会执行，事务将命令传入，并没有执行就解散了队列  </p><h3 id="示例3-事务错误处理"><a href="#示例3-事务错误处理" class="headerlink" title="示例3 事务错误处理"></a>示例3 事务错误处理</h3><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gams">multi<br><span class="hljs-keyword">set</span> aa <span class="hljs-comment">hello</span><br>get <span class="hljs-comment">aa</span><br>incr <span class="hljs-comment">aa</span><br>exec<br></code></pre></td></tr></table></figure><p>如果某个命令报错，则有报错的命令不会被执行，其他命令照样执行，且不会回滚  </p><h3 id="示例4-事务的WATCH"><a href="#示例4-事务的WATCH" class="headerlink" title="示例4 事务的WATCH"></a>示例4 事务的WATCH</h3><p>某一账户在事务内进行操作，在提交事务前，另一个进程对账户进行操作  </p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">watch <span class="hljs-keyword">a</span> <span class="hljs-comment"> // 开启监视，如果目标在事务开启前被改动，则打断事务（不会执行）</span><br>multi<br><span class="hljs-built_in">get</span> <span class="hljs-keyword">a</span><br>incr <span class="hljs-keyword">a</span><br>exec <span class="hljs-comment"> // 执行事务</span><br></code></pre></td></tr></table></figure><h2 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h2><p>想要保证一组命令执行过程中不被其它命令插入<br>原子性<br>诸如商品秒杀之类的  </p><h1 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h1><p>持久化：把内存的数据写到磁盘中去，防止服务器宕机后数据丢失<br>Redis提供了两种持久化方式</p><ul><li>RDB(默认)</li><li>AOF</li></ul><h2 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h2><p>Redis DataBase的缩写<br>功能是rdbSave（生成RDB文件到磁盘）和rdbLoad（从RDB文件中载入内存）两个函数<br><img src="/Redis/20200826021359970.png"></p><p>优点：快照保存速度快，还原也快<br>缺点：需要占用内存  </p><p>快照条件 见配置<code>redis.conf</code>文件  </p><h2 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h2><p>Append-only file的缩写<br>这种方式，会将每一个收到的命令写到文件中（默认为appendoly.aof），redis重启后，会通过重新执行文件中的命令来重建数据库内容<br><img src="/Redis/20200826021821245.png">  </p><p>每当执行任务或函数时，flushAppendOnlyFile函数都会被调用，这个函数执行以下两个工作aof写入保存<br>WRITE:判断条件，将aof_buf中的缓存写入到AOF文件<br>SAVE：根据条件，调用fsync或fdatasync函数，将AOF文件保存到磁盘中  </p><h1 id="实时同步-异步同步"><a href="#实时同步-异步同步" class="headerlink" title="实时同步-异步同步"></a>实时同步-异步同步</h1><h2 id="实时同步"><a href="#实时同步" class="headerlink" title="实时同步"></a>实时同步</h2><p>对于一致性要求高的，应采用实时同步方案  </p><ul><li>查询缓存查询不到再从DB查询，查询到后，顺便将数据保存到缓存  </li><li>更新数据到缓存时，先更新数据库，缓存中的数据设置过期  </li></ul><h2 id="异步队列"><a href="#异步队列" class="headerlink" title="异步队列"></a>异步队列</h2><p>对于并发高的，可采用异步队列的方式同步<br>东西不直接存到数据库中，而是存到中间件队列里，等数据库什么时候有空了，在从队列里处理数据<br>能实现的中间件比较多：ActiveMQ, RabbitMQ, ZeroMQ, Kafaka  </p><h2 id="UDF自定义函数"><a href="#UDF自定义函数" class="headerlink" title="UDF自定义函数"></a>UDF自定义函数</h2><p>面对mysql接口编程，利用触发器进行缓存同步<br>学习成本高  </p><h1 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h1><p>查询一个不存在的数据。由于缓存时不命中，需要从数据库查询，查不到数据则不写入缓存。这将导致这个不存在的数据每次请求都要查两次，查完缓存查数据库，造成缓存穿透  </p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><h3 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h3><p><img src="/Redis/20200826051659831.png"><br>布隆过滤器是一种数据结构<br>对所有可能查询的参数以hash形式存储，当用户想要查询的时候，使用布隆过滤器发现不在集合中，就直接丢弃，不再对持久层查询<br><img src="/Redis/20200826052744906.png">  </p><h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h4><ul><li>数据命中不高  </li><li>数据相对固定，实时性低  </li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>代码维护  </li><li>一定的缓存空间</li></ul><h3 id="缓存空对象"><a href="#缓存空对象" class="headerlink" title="缓存空对象"></a>缓存空对象</h3><p><img src="/Redis/20200826051652448.png"><br>持久层查询不到就缓存空结果<br>查询时,先判断缓存中是否存在(exists(key)),如果有直接返回空，没有则查询后返回  </p><blockquote><p>注意insert时需要清除查询的key，否则就算数据库有值，也只查不到   </p></blockquote><h4 id="适用场景-1"><a href="#适用场景-1" class="headerlink" title="适用场景"></a>适用场景</h4><ul><li>数据命中不高  </li><li>数据频繁变化，实时性高  </li></ul><h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><ul><li>存了空值，要浪费很多的缓存空间  </li><li>对于需要保持一致性的业务会有影响  </li></ul><h1 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h1><p>缓存集中大量失效时，引发大量的数据库查询<br><img src="/Redis/20200826052939263.png">  </p><h2 id="解决方法-1"><a href="#解决方法-1" class="headerlink" title="解决方法"></a>解决方法</h2><h3 id="redis高可用"><a href="#redis高可用" class="headerlink" title="redis高可用"></a>redis高可用</h3><p>这个思想的含义是，既然redis有可能挂掉，那我多增设几台redis，这样一台挂掉之后其他的还可以继续工作，其实就是搭建的集群  </p><h3 id="限流降级"><a href="#限流降级" class="headerlink" title="限流降级"></a>限流降级</h3><p>这个解决方案的思想是，在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待  </p><h3 id="数据预热"><a href="#数据预热" class="headerlink" title="数据预热"></a>数据预热</h3><p>数据加热的含义就是在正式部署之前，把可能的数据先预先访问一遍，这样部分可能大量访问的数据就会加载到缓存中。在即将发生大并发访问前手动触发加载缓存不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀   </p><h1 id="热点key"><a href="#热点key" class="headerlink" title="热点key"></a>热点key</h1><p>某个key有大量线程访问，其失效的瞬间，有大量线程来构建缓存，造成后端负载加大，甚至可能会让系统崩溃<br><img src="/Redis/20200826053525250.png">  </p><h2 id="解决方法-2"><a href="#解决方法-2" class="headerlink" title="解决方法"></a>解决方法</h2><h3 id="互斥锁-mutex-key"><a href="#互斥锁-mutex-key" class="headerlink" title="互斥锁(mutex key)"></a>互斥锁(mutex key)</h3><p>只让一个线程构建缓存，其他线程等待构建缓存的线程执行<br><img src="/Redis/20200826053631821.png">  </p><h3 id="缓存时间设置"><a href="#缓存时间设置" class="headerlink" title="缓存时间设置"></a>缓存时间设置</h3><p>不会失效就不会有问题，时间长点也会让发生频率降低  </p>]]></content>
    
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Scrapy-Splash-爬虫-同时返回图片与网页</title>
    <link href="/post/71ce616a/"/>
    <url>/post/71ce616a/</url>
    
    <content type="html"><![CDATA[<h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><ul><li>Splash 3.4.1</li><li>Scrapy-Splash 0.7.2</li><li>Windows10 专业版</li></ul><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>Splash如何同时返回html与图片</p><h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>在用<code>Scrapy</code>爬取网站时发现网页是一个动态渲染的画面<br>于是使用<code>Splash</code>爬取，查看png预览图，发现<code>Splash</code>已经得到正确的结果<br><img src="/Scrapy-Splash-%E7%88%AC%E8%99%AB-%E5%90%8C%E6%97%B6%E8%BF%94%E5%9B%9E%E5%9B%BE%E7%89%87%E4%B8%8E%E7%BD%91%E9%A1%B5/20200413055848348.png"><br><code>Scrapy-Splash</code>返回的 html 里也发现了对应的图片标签与路径<br>但直接通过图片路径来获取图片失败，提示为权限不足<br><img src="/Scrapy-Splash-%E7%88%AC%E8%99%AB-%E5%90%8C%E6%97%B6%E8%BF%94%E5%9B%9E%E5%9B%BE%E7%89%87%E4%B8%8E%E7%BD%91%E9%A1%B5/20200413055808053.png"></p><h1 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>在Splash获取到的预览画面中，图片已经正确的被渲染<br>那么只要让Splash同时返回图片和网页的数据就可以解决问题</p><h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><h3 id="更改Scrapy-Splash的lua代码参数"><a href="#更改Scrapy-Splash的lua代码参数" class="headerlink" title="更改Scrapy-Splash的lua代码参数"></a>更改<code>Scrapy-Splash</code>的<code>lua</code>代码参数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">splash_lua_script = <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">function main(splash, args)</span><br><span class="hljs-string">    assert(splash:go(args.url))</span><br><span class="hljs-string">    assert(splash:wait(0.5))</span><br><span class="hljs-string">    local preview_picture = splash:select(&#x27;#slick-slide00 img&#x27;)</span><br><span class="hljs-string">    return &#123;</span><br><span class="hljs-string">        html = splash:html(),</span><br><span class="hljs-string">        png = preview_picture:png(),</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string">    end</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br></code></pre></td></tr></table></figure><p>Splash只能通过使用 CSS 的方式来获取元素<br>这段代码的过程：获取网页，等待0.5s，通过CSS获取图片元素，并最终返回图片元素的截图</p><h3 id="Scrapy-Splash请求提交"><a href="#Scrapy-Splash请求提交" class="headerlink" title="Scrapy-Splash请求提交"></a>Scrapy-Splash请求提交</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">yield</span> SplashRequest(<br>    url=title_url,<br>    callback=self.parse_title_page,<br>    endpoint=<span class="hljs-string">&#x27;execute&#x27;</span>,<br>    args=&#123;<br>        <span class="hljs-string">&#x27;lua_source&#x27;</span>: splash_lua_script,<br>        <span class="hljs-string">&#x27;images&#x27;</span>: <span class="hljs-string">&#x27;1&#x27;</span><br>    &#125;<br>)<br></code></pre></td></tr></table></figure><p>使用方法和在<code>Scrapy</code>里提交普通的<code>Request</code>一致。</p><p>需要注意的是<code>endpoint</code>这个参数<br>Scrapy-Splash有三种返回的Response类型类型：  </p><table><thead><tr><th>实际返回类型</th><th>内容格式</th><th><code>endpoint</code>值</th></tr></thead><tbody><tr><td>SplashResponse</td><td>binary</td><td>render.png</td></tr><tr><td>SplashTextResponse</td><td>text</td><td>render.html</td></tr><tr><td>SplashJsonResponse</td><td>json</td><td>render.json或execute</td></tr></tbody></table><p>由于我希望同时返回图片和网页<br>若使用<code>render.png</code>则返回的二进制数据无法分开网页和图片<br>若使用<code>render.html</code>则压根不返回图片。<br>于是这里使用<code>execute</code></p><h3 id="回调函数中处理图片"><a href="#回调函数中处理图片" class="headerlink" title="回调函数中处理图片"></a>回调函数中处理图片</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> base64<br>base64.b64decode(response.data[<span class="hljs-string">&#x27;png&#x27;</span>])<br></code></pre></td></tr></table></figure><p>使用<code>execute</code>后，返回的内容会是<code>json</code>，返回的图片会被记录为字符串。<br>为了将字符串转变回图片，需要使用<code>base64</code>转换会图片。</p>]]></content>
    
    
    
    <tags>
      
      <tag>爬虫</tag>
      
      <tag>Scrapy</tag>
      
      <tag>Splash</tag>
      
      <tag>Scrapy-Splash</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Scrapy-Splash-爬虫</title>
    <link href="/post/b06c579/"/>
    <url>/post/b06c579/</url>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="信息"><a href="#信息" class="headerlink" title="信息"></a><strong>信息</strong></h2><p>Scrapy的Splash插件<br>github地址：<a href="https://github.com/scrapy-plugins/scrapy-splash">https://github.com/scrapy-plugins/scrapy-splash</a><br>这个插件只是让Scrapy使用Splash服务而已<br>如果没人给你提供Splash服务，那么你需要自己弄</p><a href="/post/11f87120/" title="Splash-js渲染-爬虫">Splash-js渲染-爬虫</a><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a><strong>流程</strong></h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a><strong>安装</strong></h3><p>pip install scrapy-splash</p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a><strong>配置</strong></h3><ol><li><p>在<code>settings.py</code>中添加<code>Splash</code>地址</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">SPLASH_URL = <span class="hljs-string">&#x27;http://192.168.59.103:8050&#x27;</span><br></code></pre></td></tr></table></figure><p> 根据ip来，要是本地就localhost:8050</p></li><li><p>在<code>settings.py</code>中配置<code>Downloader</code>中间件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">DOWNLOADER_MIDDLEWARES = &#123;<br>    <span class="hljs-string">&#x27;scrapy_splash.SplashCookiesMiddleware&#x27;</span>: <span class="hljs-number">723</span>,<br>    <span class="hljs-string">&#x27;scrapy_splash.SplashMiddleware&#x27;</span>: <span class="hljs-number">725</span>,      <span class="hljs-string">&#x27;scrapy.downloadermiddlewares.httpcompression.HttpCompressionMiddleware&#x27;</span>: <span class="hljs-number">810</span>,<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>启用Spider中间件<code>SplashDeduplicateArgsMiddleware</code> </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">SPIDER_MIDDLEWARES = &#123;<br>    <span class="hljs-string">&#x27;scrapy_splash.SplashDeduplicateArgsMiddleware&#x27;</span>: <span class="hljs-number">100</span>,<br>&#125;<br></code></pre></td></tr></table></figure><p> 这个功能需要<code>cache_args</code>支持。<br>它能通过不保存 重复的Splash参数 节约磁盘空间<br>若Splash版本2.1+，它能通过 不重复发送Splash参数 节约带宽</p></li><li><p>设置去重类<code>DUPEFILTER_CLASS</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">DUPEFILTER_CLASS = <span class="hljs-string">&#x27;scrapy_splash.SplashAwareDupeFilter&#x27;</span><br></code></pre></td></tr></table></figure></li><li><p>如果你使用HTTP cache，那么要定义一个缓存后端</p><p> scrapy-splash提供一个<code>scrapy.contrib.httpcache.FilesystemCacheStorage</code>子类</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">HTTPCACHE_STORAGE = <span class="hljs-string">&#x27;scrapy_splash.SplashAwareFSCacheStorage&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a><strong>使用</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">yield</span> SplashRequest(url, self.parse_result, callback <span class="hljs-comment">#任务完成之后对应的回调函数</span><br>    <span class="hljs-comment">#args设置的是端点API的参数，关于API参数问题，请参考: `Splash HTTP API &lt;./api.html&gt;`_</span><br>    args=&#123;<br>        <span class="hljs-comment"># 可选参数，表示spalsh在执行完成之后会等待一段时间后返回</span><br>        <span class="hljs-string">&#x27;wait&#x27;</span>: <span class="hljs-number">0.5</span>,<br>        <span class="hljs-comment">#url是一个必须的参数，表明将要对哪个url进行请求</span><br>        <span class="hljs-string">&#x27;url&#x27;</span> : <span class="hljs-string">&quot;http://www.example.com&quot;</span>,<br>        <span class="hljs-comment">#http_method:表示Splash将向目标url发送何种请求</span><br>        <span class="hljs-string">&#x27;http_method&#x27;</span>: <span class="hljs-string">&#x27;GET&#x27;</span><br>        <span class="hljs-comment"># &#x27;body&#x27; 用于POST请求，作为请求的请求体</span><br>        <span class="hljs-comment"># &#x27;lua_source&#x27; 如果需要执行lua脚本，那么这个参数表示对应lua脚本的字符串</span><br>    &#125;,<br>    endpoint=<span class="hljs-string">&#x27;render.json&#x27;</span>, <span class="hljs-comment"># optional; default is render.html</span><br>    splash_url=<span class="hljs-string">&#x27;&lt;url&gt;&#x27;</span>,     <span class="hljs-comment"># optional; overrides SPLASH_URL</span><br>    slot_policy=scrapy_splash.SlotPolicy.PER_DOMAIN,  <span class="hljs-comment"># optional,</span><br>    <span class="hljs-comment"># &quot;meta&quot; 是一个用来向回调函数传入参数的方式，在回调函数中的response.meta中可以取到这个地方传入的参数</span><br>)<br></code></pre></td></tr></table></figure><p>如果在splash中使用lua脚本，那么args中的内容会通过main函数的 splash.args 参数传入，其余的内容会通过第二个 参数 args 传入。<br>比如下面有一个简单的用户登录的例子:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs python">lua_script= <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">function main(splash, args)</span><br><span class="hljs-string"></span><br><span class="hljs-string">local ok, reason = splash:go(args.url)</span><br><span class="hljs-string">user_name = args.user_name</span><br><span class="hljs-string">user_passwd = args.user_passwd</span><br><span class="hljs-string">user_text = splash:select(&quot;#email&quot;)</span><br><span class="hljs-string">pass_text = splash:select(&quot;#pass&quot;)</span><br><span class="hljs-string">login_btn = splash:select(&quot;#loginbutton&quot;)</span><br><span class="hljs-string">if (user_text and pass_text and login_btn) then</span><br><span class="hljs-string">    user_text:send_text(user_name)</span><br><span class="hljs-string">    pass_text:send_text(user_passwd)</span><br><span class="hljs-string">    login_btn:mouse_click(&#123;&#125;)</span><br><span class="hljs-string">end</span><br><span class="hljs-string"></span><br><span class="hljs-string">splash:wait(math.random(5, 10))</span><br><span class="hljs-string">return &#123;</span><br><span class="hljs-string">    url = splash:url(),</span><br><span class="hljs-string">    cookies = splash:get_cookies(),</span><br><span class="hljs-string">    headers = splash.args.headers,</span><br><span class="hljs-string"> &#125;</span><br><span class="hljs-string">end&#x27;&#x27;&#x27;</span><br><br><span class="hljs-keyword">yield</span> SplashRequest(<br>    url=self.login_url,<br>    endpoint=<span class="hljs-string">&quot;execute&quot;</span>,<br>    args=&#123;<br>        <span class="hljs-string">&quot;wait&quot;</span>: <span class="hljs-number">30</span>,<br>        <span class="hljs-string">&quot;lua_source&quot;</span>: lua_script,<br>        <span class="hljs-string">&quot;user_name&quot;</span>: <span class="hljs-string">&quot;xxxx&quot;</span>,  <span class="hljs-comment"># 在Lua脚本中这个参数可用通过args.user_name取得</span><br>        <span class="hljs-string">&quot;user_passwd&quot;</span>: <span class="hljs-string">&quot;xxxx&quot;</span>,<br>    &#125;,<br>    meta = &#123;<span class="hljs-string">&quot;user_name&quot;</span> : <span class="hljs-string">&quot;xxxx&quot;</span>&#125;,<br>    callback=self.after_login,<br>    errback=self.error_parse,<br>)<br></code></pre></td></tr></table></figure><p>上述代码提交了一个Splash的请求，在脚本中首先获取用户名和密码的输入框元素和对应的提交按钮元素，接着填入用户名和 密码，最后点击提交并返回对应的cookie。 回调函数 after_login 的代码如下:</p></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">after_login</span>(<span class="hljs-params">self, response</span>):</span><br>    <span class="hljs-comment">#首先根据一定条件判断登录是否成功</span><br>    self.login_user = response.meta[<span class="hljs-string">&quot;user_name&quot;</span>] <span class="hljs-comment"># 保存当前登录用户</span><br>    self.cookie = response.data[<span class="hljs-string">&quot;cookies&quot;</span>]  <span class="hljs-comment"># 保存cookie</span><br></code></pre></td></tr></table></figure><p>在回调函数中，可以通过response.data来获取lua脚本中返回的内容，而对应的HTML代码的获取方式与使用传统的Request方式 相同。</p><p>另外在回调函数中可以通过response.meta来获取Request中meta传入的参数。</p><p>上述示例演示了如何使用SplashRequest来像Splash发送渲染请求，以及如何在回调函数中获取lua脚本中的返回、 以及如何在回调函数中获取lua脚本中的返回、如何向回调函数传递参数。</p><p>当然您也可以使用常规的scrapy.Request来向Splash发送请求，发送的示例如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">yield</span> scrapy.Request(url, self.parse_result, meta=&#123;<br>    <span class="hljs-string">&#x27;splash&#x27;</span>: &#123;<br>        <span class="hljs-string">&#x27;args&#x27;</span>: &#123;<br>            <span class="hljs-comment"># 在此处设置端点API的参数</span><br>            <span class="hljs-string">&#x27;html&#x27;</span>: <span class="hljs-number">1</span>,<br>            <span class="hljs-string">&#x27;png&#x27;</span>: <span class="hljs-number">1</span>,<br><br>            <span class="hljs-comment"># &#x27;url&#x27; is prefilled from request url</span><br>            <span class="hljs-comment"># &#x27;http_method&#x27; is set to &#x27;POST&#x27; for POST requests</span><br>            <span class="hljs-comment"># &#x27;body&#x27; is set to request body for POST requests</span><br>        &#125;,<br><br>        <span class="hljs-comment"># optional parameters</span><br>        <span class="hljs-string">&#x27;endpoint&#x27;</span>: <span class="hljs-string">&#x27;render.json&#x27;</span>,  <span class="hljs-comment"># optional; default is render.json</span><br>        <span class="hljs-string">&#x27;splash_url&#x27;</span>: <span class="hljs-string">&#x27;&lt;url&gt;&#x27;</span>,      <span class="hljs-comment"># optional; overrides SPLASH_URL</span><br>        <span class="hljs-string">&#x27;slot_policy&#x27;</span>: scrapy_splash.SlotPolicy.PER_DOMAIN,<br>        <span class="hljs-string">&#x27;splash_headers&#x27;</span>: &#123;&#125;,       <span class="hljs-comment"># optional; a dict with headers sent to Splash</span><br>        <span class="hljs-string">&#x27;dont_process_response&#x27;</span>: <span class="hljs-literal">True</span>, <span class="hljs-comment"># optional, default is False</span><br>        <span class="hljs-string">&#x27;dont_send_headers&#x27;</span>: <span class="hljs-literal">True</span>,  <span class="hljs-comment"># optional, default is False</span><br>        <span class="hljs-string">&#x27;magic_response&#x27;</span>: <span class="hljs-literal">False</span>,    <span class="hljs-comment"># optional, default is True</span><br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>splash 参数中的内容是用于splash的，使用这个参数表明我们希望向splash发送渲染请求。</p><p>最终它们会被组织成 request.meta[‘splash’] 。在scrapy处理这些请求的时候根据这个来确定是否创建spalsh的 中间件，最终请求会被中间件以HTTP API的方式转发到splash中。</p><p>splash中各个参数的作用如下:</p><ul><li><p>meta[‘splash’][‘args’] 是最终发送到splash HTTP API的参数</p><ul><li>url 表示目标站点的url</li><li>http_method 表示向url发送的HTTP的请求方式</li><li>body 是采用POST方式发送请求时，请求体的内容</li></ul></li><li><p>meta[‘splash’][‘cache_args’] 表示将要被作为缓冲的参数的列表字符串，以分号分隔</p></li><li><p>meta[‘splash’][‘endpoint’] 表示对应的端点</p></li><li><p>meta[‘splash’][‘splash_url’] 与settings文件中的 SPLASH_URL 作用相同，但是会优先采用这里的设置</p></li><li><p>meta[‘splash’][‘splash_headers’] 即将发送到splash服务器上的请求头信息，注意，这里它不是最终发送到对应站点的请求头信息</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>爬虫</tag>
      
      <tag>Scrapy</tag>
      
      <tag>Splash</tag>
      
      <tag>Scrapy-Splash</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>服务器软件分类与常用服务器软件</title>
    <link href="/post/2257bb18/"/>
    <url>/post/2257bb18/</url>
    
    <content type="html"><![CDATA[<h2 id="按动静服务分"><a href="#按动静服务分" class="headerlink" title="按动静服务分"></a>按动静服务分</h2><ul><li>静态服务：主要提供静态资源，不同用户访问到的资源相同</li><li>动态服务：提供动态服务，不同用户访问到的资源不同</li></ul><h2 id="服务器的几个叫法："><a href="#服务器的几个叫法：" class="headerlink" title="服务器的几个叫法："></a>服务器的几个叫法：</h2><ul><li>web服务器：广义上来说，就是响应用户的需求，提供服务，当下所有的服务器软件都可以称之为web服务器软件</li><li>HTTP服务器(静态服务)：使用HTTP协议传输资源，提供服务</li><li>应用服务器(动态服务)：一个特定应用的承载容器</li></ul><h2 id="常见的轻量级服务器软件："><a href="#常见的轻量级服务器软件：" class="headerlink" title="常见的轻量级服务器软件："></a>常见的轻量级服务器软件：</h2><ul><li> <code>Nginx</code>：典型的静态服务器，可做反向代理、负载均衡，一般放在最前面直面用户，和后端Tomcat打配合；纯C写的，性能贼高、内存消耗极少、稳定性也相当好，互联网公司重度使用</li><li> <code>Tengine</code>：阿里出品，基于Nginx服务器做的改造(加强和封装)，对大流量场景做了很多高级功能，性能、稳定性优秀</li><li> <code>Apache http server</code>：也是静态服务器，但是不如Nginx</li><li> <code>IIS</code>：微软开发，只能用在Windows下，具有应用服务器能力的http服务器</li><li> <code>Tomcat</code>：Apache出品，典型的应用服务器软件，符合Servlet标准的应用容器，也可以提供http服务，但一般不会作为http服务器；是Spring Boot框架默认的内置服务器</li><li> <code>Jetty</code>：跟Tomcat是一个性质的东西，符合Servlet标准的应用容器，也是Spring Boot框架支持的服务器，但不是默认的</li><li> <code>Undertow</code>：红帽子出品，跟Tomcat、Jetty一样也是Spring Boot框架支持的服务器，但不是默认的；高并发时性能优于Tomcat、Jetty</li></ul><h2 id="几款商用重量级的服务器软件："><a href="#几款商用重量级的服务器软件：" class="headerlink" title="几款商用重量级的服务器软件："></a>几款商用重量级的服务器软件：</h2><ul><li><code>JBoss</code>(从8版开始更名为<code>WildFly</code>)：不仅是Servlet应用容器，更是EJB的应用容器，整套JavaEE框架部署的解决方案</li><li> <code>WebLogic</code>：Oracle公司出品，用于部署企业级JavaEE应用，全能型，几乎支持JavaEE所有的应用规范</li><li> <code>WebSphere</code>：IBM公司出品，支持更多JavaEE的应用规范的综合应用服务器</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>服务器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Scrapy-基础</title>
    <link href="/post/5c6a28/"/>
    <url>/post/5c6a28/</url>
    
    <content type="html"><![CDATA[<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a><strong>链接</strong></h2><p>官网：<a href="https://scrapy.org/">https://scrapy.org/</a><br>官方文档：<a href="https://docs.scrapy.org/en/latest/">https://docs.scrapy.org/en/latest/</a><br>翻译文档：<a href="https://scrapy-chs.readthedocs.io/zh_CN/1.0/intro/overview.html">https://scrapy-chs.readthedocs.io/zh_CN/1.0/intro/overview.html</a></p><h2 id="信息"><a href="#信息" class="headerlink" title="信息"></a><strong>信息</strong></h2><p>特点：入门快，扩展性强<br>内建CSS选择器和XPath表达式<br>基于IPython shell<br><img src="/Scrapy%E5%9F%BA%E7%A1%80/20200407124348251.png"></p><h3 id="Scrapy主要组件"><a href="#Scrapy主要组件" class="headerlink" title="Scrapy主要组件"></a><strong>Scrapy主要组件</strong></h3><ul><li><strong>引擎(Scrapy)</strong><br>  <em>用来处理整个系统的数据流处理, 触发事务(框架核心)</em></li><li><strong>调度器(Scheduler)</strong><br>  <em>用来接受引擎发过来的请求, 压入队列中, 并在引擎再次请求的时候返回. 可以想像成一个URL（抓取网页的网址或者说是链接）的优先队列, 由它来决定下一个要抓取的网址是什么, 同时去除重复的网址</em></li><li><strong>下载器(Downloader)</strong><br>  <em>用于下载网页内容, 并将网页内容返回给蜘蛛(Scrapy下载器是建立在twisted这个高效的异步模型上的)</em></li><li><strong>爬虫(Spiders)</strong><br>  <em>爬虫是主要干活的, 用于从特定的网页中提取自己需要的信息, 即所谓的实体(Item)。用户也可以从中提取出链接,让Scrapy继续抓取下一个页面</em></li><li><strong>项目管道(Pipeline)</strong><br>  <em>负责处理爬虫从网页中抽取的实体，主要的功能是持久化实体、验证实体的有效性、清除不需要的信息。当页面被爬虫解析后，将被发送到项目管道，并经过几个特定的次序处理数据。</em></li><li><strong>下载器中间件(Downloader Middlewares)</strong><br>  <em>位于Scrapy引擎和下载器之间的框架，主要是处理Scrapy引擎与下载器之间的请求及响应。</em></li><li><strong>爬虫中间件(Spider Middlewares)</strong><br>  <em>介于Scrapy引擎和爬虫之间的框架，主要工作是处理蜘蛛的响应输入和请求输出。</em></li><li><strong>调度中间件(Scheduler Middewares)</strong><br>  <em>介于Scrapy引擎和调度之间的中间件，从Scrapy引擎发送到调度的请求和响应。</em></li></ul><h3 id="运行流程"><a href="#运行流程" class="headerlink" title="运行流程"></a><strong>运行流程</strong></h3><ol><li>Engine从Spider中得到第一个Requests进行爬取</li><li>ENGIN将Request放入SCHEDULER调度器，并且获取下个Request</li><li>SCHEDULER将Requests返回给ENGINE（因为ENGING进行任务调度）</li><li>ENGINE发送Requests到Downoader，通过Downloader Middlewares 进行处理（这一步进行Http请求，返回response）</li><li>通过Downloader Middleware进行资源下载(就是html信息)，如果下载完成，通过Dowloader生成一个Resonse并且发送给ENGINE</li><li>ENGINE 从DOWNLOADER接收 Resonse,并将Resonse发送给Spider进行处理。Spider通过Spider Middleware进行处理Response</li><li>Spider处理Response 并且返回items和新的Requests给ENGINE,这部分处理通过Spilder Middleware进行处理</li><li>Engine发送items到item Pipelines 然后 发送 Request到Scheduler 并且 获取下个Request进行处理</li><li>重复第一个步骤进行处理。</li></ol><h3 id="基本代码流程"><a href="#基本代码流程" class="headerlink" title="基本代码流程"></a><strong>基本代码流程</strong></h3><p>编写item，编写spider与setting，编写pipeline</p><h2 id="基础操作"><a href="#基础操作" class="headerlink" title="基础操作"></a><strong>基础操作</strong></h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a><strong>安装</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pip install Scrapy<br></code></pre></td></tr></table></figure><p>若是希望使用<code>Scrapy shell</code>的话，需要留意<code>python环境变量</code>的问题</p><h4 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a><strong>创建项目</strong></h4><p>选定一个文件夹，打开控制台。输入指令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">scrapy startproject tutorial<br></code></pre></td></tr></table></figure><p>命令会创建tutorial目录，并在里面生成一些文件</p><ul><li><code>scrapy.cfg</code>: 项目的配置文件</li><li><code>tutorial/</code>: 该项目的python模块。之后您将在此加入代码</li><li><code>tutorial/items.py</code>: 项目中的item文件</li><li><code>tutorial/pipelines.py</code>: 项目中的pipelines文件</li><li><code>tutorial/settings.py</code>: 项目的设置文件</li><li><code>tutorial/spiders/</code>: 放置spider代码的目录</li></ul><h4 id="定义Item"><a href="#定义Item" class="headerlink" title="定义Item"></a><strong>定义Item</strong></h4><p><code>Item</code> 是保存爬取到的数据的容器。<br>其使用方法和 python字典 类似， 并且提供了额外保护机制来避免拼写错误导致的未定义字段错误。</p><p>根据需要 爬取的网页 获取到的数据对<code>Item</code>进行建模。 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> scrapy<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TutorialItem</span>(<span class="hljs-params">scrapy.Item</span>):</span><br>    identification = scrapy.Field()<br>    name = scrapy.Field()<br></code></pre></td></tr></table></figure><p>这里定义了一个<code>Item 类</code>，类中包含两个属性  </p><h4 id="编写Spider"><a href="#编写Spider" class="headerlink" title="编写Spider"></a><strong>编写Spider</strong></h4><p>Spider是用户编写用于从单个网站(或者一些网站)爬取数据的类。</p><p>其包含了一个用于下载的初始URL，如何跟进网页中的链接以及如何分析页面中的内容， 提取生成 item 的方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> scrapy<br><span class="hljs-keyword">from</span> tutorial.items <span class="hljs-keyword">import</span> TutorialItem<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BingSpider</span>(<span class="hljs-params">scrapy.spiders.Spider</span>):</span><br>    name = <span class="hljs-string">&quot;first&quot;</span><br>    allowed_domains = [<span class="hljs-string">&quot;bing.com&quot;</span>]<br>    start_urls = [<span class="hljs-string">&quot;https://cn.bing.com/&quot;</span>]<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">parse</span>(<span class="hljs-params">self, response</span>):</span><br>        item = TutorialItem()<br>        item[<span class="hljs-string">&quot;identification&quot;</span>] = response.xpath(<span class="hljs-string">&#x27;//*[@id=&quot;b_footerItems&quot;]//text()&#x27;</span>).extract()<br>        item[<span class="hljs-string">&quot;name&quot;</span>] = response.xpath(<span class="hljs-string">&#x27;//*[@id=&quot;sbox&quot;]//text()&#x27;</span>).extract()<br>        <span class="hljs-keyword">yield</span> item<br></code></pre></td></tr></table></figure><ul><li><p>关于定义本身<br>为了创建一个<code>Spider</code>，您必须继承<code>scrapy.spiders.Spider</code>类， 且定义一些属性:</p><ul><li><code>name</code>: 用于区别<code>Spider</code>。 该名字必须是唯一的，您不可以为不同的<code>Spider</code>设定相同的名字。</li><li><code>start_urls</code>: 包含了<code>Spider</code>在启动时进行爬取的<code>url</code>列表。 因此，第一个被获取到的页面将是其中之一。 后续的URL则从初始的URL获取到的数据中提取。</li><li><code>parse()</code> 是<code>Spider</code>的一个方法。 被调用时，每个 初始URL 完成下载后生成的<code>Response</code>对象将会作为唯一的参数传递给该函数。 该方法负责解析返回的数据(response data)，提取数据(生成<code>item</code>)以及生成需要进一步处理的URL的 <code>Request</code>对象。</li></ul></li><li><p>获取html中的数据<br><code>Scrapy</code>使用基于<code>XPath</code>和<code>CSS选择器</code>的机制<code>Scrapy Selectors</code>来选取Html中的元素。<br><code>Scrapy Selectors</code>的四种基本方法</p><ul><li>xpath(): 传入xpath表达式，返回该表达式所对应的所有节点的selector list列表 。</li><li>css(): 传入CSS表达式，返回该表达式所对应的所有节点的selector list列表.</li><li>extract(): 序列化该节点为unicode字符串并返回list。</li><li>re(): 根据传入的正则表达式对数据进行提取，返回unicode字符串list列表。</li></ul></li></ul><blockquote><p>如果想要记录整个编码后的网页可以这样做</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">response</span><span class="hljs-selector-class">.body</span><span class="hljs-selector-class">.decode</span>(<span class="hljs-selector-tag">response</span><span class="hljs-selector-class">.encoding</span>)<br></code></pre></td></tr></table></figure><h4 id="进行爬取"><a href="#进行爬取" class="headerlink" title="进行爬取"></a><strong>进行爬取</strong></h4><p>进入项目的根目录，执行下列命令启动<code>Spider</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">scrapy crawl first<br></code></pre></td></tr></table></figure><p>这里的 first 对应着<code>Spider</code>中定义的<code>name</code><br>在控制台里你会看到一些详细的输出信息。<br>过程：</p><ol><li><code>Scrapy</code>为<code>Spider</code>的 <code>start_urls</code> 属性中的每个URL创建了 <code>scrapy.Request</code> 对象，并将 <code>parse</code> 方法作为回调函数(callback)赋值给了<code>Request</code>。</li><li>Request对象经过调度，执行生成 <code>scrapy.http.Response</code> 对象并送回给<code>Spider parse()</code> 方法。</li></ol><h4 id="保存数据"><a href="#保存数据" class="headerlink" title="保存数据"></a><strong>保存数据</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">scrapy crawl first -o items.json<br></code></pre></td></tr></table></figure><p>该命令将采用<code>JSON</code>格式对爬取的数据进行序列化，生成 <code>items.json</code> 文件。<br>在类似本篇教程里这样小规模的项目中，这种存储方式已经足够。<br>如果需要对爬取到的<code>item</code>做更多更为复杂的操作，您可以编写 <code>Item Pipeline</code> 。<br>类似于我们在创建项目时对<code>Item</code>做的，用于您编写自己的 <code>tutorial/pipelines.py</code> 也被创建。<br>不过如果您仅仅想要保存<code>item</code>，您不需要实现任何的<code>pipeline</code>  </p>]]></content>
    
    
    
    <tags>
      
      <tag>Scrapy</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git-基础</title>
    <link href="/post/69c3279c/"/>
    <url>/post/69c3279c/</url>
    
    <content type="html"><![CDATA[<h2 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a>官方文档</h2><p><a href="https://git-scm.com/book/zh/v2">https://git-scm.com/book/zh/v2</a></p><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p><a href="https://git-scm.com/download">https://git-scm.com/download</a></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ol start="0"><li>安装依赖的东西<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel nss  gcc perl-ExtUtils-MakeMaker <br><br></code></pre></td></tr></table></figure></li><li>下载安装包<br> 在一个地方打开控制台，然后下载安装包<br> 这里我下载一个2.9.5版本的git   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">wget https://mirrors.edge.kernel.org/pub/software/scm/git/git-2.9.5.tar.xz <br></code></pre></td></tr></table></figure></li><li>解压，并去到解压出来的目录下   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">tar xf git-2.9.5.tar.xz <br><span class="hljs-built_in">cd</span> git-2.9.5<br></code></pre></td></tr></table></figure></li><li>编译，安装   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">make prefix=/usr/<span class="hljs-built_in">local</span>/git all<br>make prefix=/usr/<span class="hljs-built_in">local</span>/git install<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;export PATH=<span class="hljs-variable">$PATH</span>:/usr/local/git/bin&quot;</span> &gt;&gt; /etc/bashrc<br><span class="hljs-built_in">source</span> /etc/bashrc<br></code></pre></td></tr></table></figure></li><li>配置<br> 安装完了以后需要配置用户名和邮箱<br> 注意与github账户一致   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --global user.name <span class="hljs-string">&quot;Name&quot;</span><br>git config --global user.email  <span class="hljs-string">&quot;E-mail&quot;</span><br></code></pre></td></tr></table></figure><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="添加远程仓库"><a href="#添加远程仓库" class="headerlink" title="添加远程仓库"></a>添加远程仓库</h3><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">git remote <span class="hljs-keyword">add</span><span class="bash"> origin 添加远程仓库的SSH</span><br></code></pre></td></tr></table></figure><h3 id="推送到github-master-节点"><a href="#推送到github-master-节点" class="headerlink" title="推送到github master 节点"></a>推送到github master 节点</h3><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">git <span class="hljs-built_in">push</span> <span class="hljs-built_in">origin</span> master<br></code></pre></td></tr></table></figure><h3 id="查看git版本"><a href="#查看git版本" class="headerlink" title="查看git版本"></a>查看git版本</h3><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">git <span class="hljs-comment">--version</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="更新git工具"><a href="#更新git工具" class="headerlink" title="更新git工具"></a>更新git工具</h3><h4 id="CentOS"><a href="#CentOS" class="headerlink" title="CentOS"></a>CentOS</h4><ol><li>centos7 添加源<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">yum install http:<span class="hljs-regexp">//</span>opensource.wandisco.com<span class="hljs-regexp">/centos/</span><span class="hljs-number">7</span><span class="hljs-regexp">/git/</span>x86_64/wandisco-git-release-<span class="hljs-number">7</span>-<span class="hljs-number">2</span>.noarch.rpm<br></code></pre></td></tr></table></figure></li><li>更新git工具<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">yum update git</span><br></code></pre></td></tr></table></figure><h4 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h4>git版本在2.17.1之前用<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">git update</span><br></code></pre></td></tr></table></figure>在2.17.1之后用<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">git update-git-for-windows</span><br></code></pre></td></tr></table></figure>若是版本非常低，则需要自己去官网下载安装包  </li></ol><h2 id="Github-SSH-Key"><a href="#Github-SSH-Key" class="headerlink" title="Github SSH Key"></a>Github SSH Key</h2><p>GitHub配置SSH Key的目的是为了帮助我们在通过git提交代码是，不需要繁琐的验证过程，简化操作流程  </p><ul><li>centos  <ol><li>创建SSH key  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh-keygen -t rsa -C <span class="hljs-string">&quot;Github邮箱&quot;</span><br></code></pre></td></tr></table></figure></li><li>拷贝ssh-rsa头  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> ~/.ssh  <span class="hljs-comment"># 来到SSH目录</span><br>ls  <span class="hljs-comment"># 查看创建的SSH key</span><br>cat id_rsa.pub <span class="hljs-comment"># 查看某个SSH key的头</span><br></code></pre></td></tr></table></figure><img src="/Git-%E5%9F%BA%E7%A1%80/20200331033744081.png"><br>在查看到以后，将它完整的复制下来  </li><li>Git Hub添加SSH Key<br><img src="/Git-%E5%9F%BA%E7%A1%80/20200331033843357.png"><br><img src="/Git-%E5%9F%BA%E7%A1%80/20200331033924152.png"><br>取个名字，将 <code>ssh-rsa</code> 头复制进去就完成了  </li></ol></li></ul><hr><p>参考：<br><a href="https://blog.csdn.net/u013778905/article/details/83501204">https://blog.csdn.net/u013778905/article/details/83501204</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CentOS-xfce-中文输入法</title>
    <link href="/post/49efdfc2/"/>
    <url>/post/49efdfc2/</url>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a><strong>环境</strong></h2><ul><li>Centos7 腾讯云服务器</li></ul><h2 id="显示输入框"><a href="#显示输入框" class="headerlink" title="显示输入框"></a><strong>显示输入框</strong></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ibus-setup<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>服务器</tag>
      
      <tag>CentOS</tag>
      
      <tag>xfce</tag>
      
      <tag>输入法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode日常-简单-121-买卖股票的最佳时机</title>
    <link href="/post/901a48fa/"/>
    <url>/post/901a48fa/</url>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a><strong>题目</strong></h2><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。<br>如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。<br>注意：你不能在买入股票前卖出股票。</p><p>示例 1:<br>　　输入: [7,1,5,3,6,4]<br>　　输出: 5<br>　　解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。<br>　　注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。</p><p>示例 2:<br>　　输入: [7,6,4,3,1]<br>　　输出: 0<br>　　解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</p><h2 id="自解"><a href="#自解" class="headerlink" title="自解"></a><strong>自解</strong></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">maxProfit</span>(<span class="hljs-params">self, prices: List[<span class="hljs-built_in">int</span>]</span>) -&gt; int:</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> prices:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        min_befor = prices[<span class="hljs-number">0</span>]<br>        max_profit = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> prices:<br>            <span class="hljs-comment">#  记下当前位置之前最少的数</span><br>            min_befor = <span class="hljs-built_in">min</span>(i, min_befor)<br>            <span class="hljs-comment">#  如果过去最低点买入，今天卖出的话会不会超过最大的利润记录，会则更新记录</span><br>            max_profit = <span class="hljs-built_in">max</span>(max_profit, i-min_befor)<br>        <span class="hljs-keyword">return</span> max_profit<br></code></pre></td></tr></table></figure><p>时间复杂度：O(n)</p><h2 id="官方思路"><a href="#官方思路" class="headerlink" title="官方思路"></a><strong>官方思路</strong></h2><p>动态规划一般分为一维、二维、多维（使用状态压缩），对应形式为 <code>dp(i)</code>、<code>dp(i)(j)</code>、二进制<code>dp(i)(j)</code>。</p><ol><li><p>动态规划做题步骤  </p><ul><li>明确 <code>dp(i)</code> 应该表示什么（二维情况：<code>dp(i)(j)</code>）；</li><li>根据 <code>dp(i)</code> 和 <code>dp(i−1)</code> 的关系得出状态转移方程；</li><li>确定初始条件，如 <code>dp(0)</code>。</li></ul></li><li><p>本题思路<br>其实方法一的思路不是凭空想象的，而是由动态规划的思想演变而来。这里介绍一维动态规划思想。<br><code>dp[i]</code>表示前 <code>i</code> 天的最大利润，因为我们始终要使利润最大化，则：<br>　　　　　　　　<code>dp[i]=max(dp[i−1],  prices[i]−minprice)</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">maxProfit</span>(<span class="hljs-params">self, prices: List[<span class="hljs-built_in">int</span>]</span>) -&gt; int:</span><br>        n = <span class="hljs-built_in">len</span>(prices)<br>        <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span>: <span class="hljs-keyword">return</span> <span class="hljs-number">0</span> <span class="hljs-comment"># 边界条件</span><br>        dp = [<span class="hljs-number">0</span>] * n<br>        minprice = prices[<span class="hljs-number">0</span>] <br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n):<br>            minprice = <span class="hljs-built_in">min</span>(minprice, prices[i])<br>            dp[i] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>], prices[i] - minprice)<br>        <span class="hljs-keyword">return</span> dp[-<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><p>时间复杂度：O(n)</p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>LeetCode</tag>
      
      <tag>简单</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Splash-js渲染-爬虫</title>
    <link href="/post/11f87120/"/>
    <url>/post/11f87120/</url>
    
    <content type="html"><![CDATA[<h2 id="Splash是什么？"><a href="#Splash是什么？" class="headerlink" title="Splash是什么？"></a><strong>Splash是什么？</strong></h2><p>Splash是一个javascript渲染服务。<br>它是一个带有HTTP API的轻量级Web浏览器，使用Twisted和QT5在Python 3中实现。<br>QT反应器用于使服务完全异步，允许通过QT主循环利用webkit并发。<br>是Scrapy推荐使用的javascript渲染<br>能起到和web driver相似的功能。<br>只能在 <strong>Linux</strong> 与 <strong>Mac</strong> 系统下安装</p><h2 id="文档"><a href="#文档" class="headerlink" title="文档"></a><strong>文档</strong></h2><p>官方文档：<a href="https://splash.readthedocs.io/en/latest/install.html">https://splash.readthedocs.io/en/latest/install.html</a><br>网友中文文档：<a href="https://splash-cn-doc.readthedocs.io/zh_CN/latest/scrapy-splash-toturial.html">https://splash-cn-doc.readthedocs.io/zh_CN/latest/scrapy-splash-toturial.html</a></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a><strong>安装</strong></h2><p>此服务需要<code>Docker</code>才能安装  </p><ol><li><p>安装Docker<br>需求：Docker版本≥17  </p></li><li><p>拉取splash  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo docker pull scrapinghub/splash<br></code></pre></td></tr></table></figure></li><li><p>启动  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo docker run -itd -p 8050:8050 scrapinghub/splash<br></code></pre></td></tr></table></figure><blockquote><p>有些时候docker会抽风，无法连接，重启一下<code>docker</code>就好<code>service docker restart</code><br>  要是觉得太麻烦，可以在启动时添加启动参数</p><pre><code><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">docker <span class="hljs-builtin-name">run</span> -p 8050:8050 <span class="hljs-attribute">--restart</span>=always -d scrapinghub/splash<br></code></pre></td></tr></table></figure></code></pre><ul><li>-d 后台运行</li><li>–restart=always 崩溃后自动重新启动</li></ul></blockquote></li><li><p>测试服务<br>浏览器中输入网址<code>http://localhost:8050/</code><br><img src="/Splash-js%E6%B8%B2%E6%9F%93-%E7%88%AC%E8%99%AB/20200324060126796.png"><br>若是见到欢迎界面，那么久成了  </p></li></ol><p>运行好了以后，要是防火墙做好了设置，服务器外也能通过<code>ip:端口</code>的形式在浏览器访问到了</p><h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a><strong>入门</strong></h2><h3 id="首页"><a href="#首页" class="headerlink" title="首页"></a><strong>首页</strong></h3><p><img src="/Splash-js%E6%B8%B2%E6%9F%93-%E7%88%AC%E8%99%AB/20200324060126796.png"><br>在首页看到的界面里的代码时<code>Lua</code>语言代码<br><img src="/Splash-js%E6%B8%B2%E6%9F%93-%E7%88%AC%E8%99%AB/20200324061037245.png"><br>点击Render来渲染指定的网页，并返回结果</p><h3 id="Splash提供的http接口"><a href="#Splash提供的http接口" class="headerlink" title="Splash提供的http接口"></a><strong>Splash提供的http接口</strong></h3><p><img src="/Splash-js%E6%B8%B2%E6%9F%93-%E7%88%AC%E8%99%AB/20200324062843769.png"></p><table><thead><tr><th>信息</th><th>意义</th></tr></thead><tbody><tr><td>url</td><td>restful风格url</br>对于抓取网页，最重要的是<code>render.html</code></br>虽然这个演示中并没有</br>一般来说请求类似这样</br><a href="http://localhost:8050/render.html%EF%BC%9Furl=http://www.baidu.com/&amp;timeout=30.0&amp;wait=0.5">http://localhost:8050/render.html？url=http://www.baidu.com/&amp;timeout=30.0&amp;wait=0.5</a> </br>参数解读：</br>url：请求的地址</br>* timeout：选填，超时时间</br>* wait：选填，页面加载完毕后，等待的时间</td></tr><tr><td>png</td><td>渲染效果截图</td></tr><tr><td>HAR</td><td>HTTP Archive format:用来记录浏览器加载网页时所消耗的时间的工具。</br>记录每一个HTTP请求发出直到收到完整的HTTP响应中间所耗费的时间，可以迅速帮助我们知道是哪些HTTP请求没有得到及时的回复，从而进行更一步的排查。</td></tr><tr><td>html</td><td>网页html</td></tr></tbody></table><h4 id="通过shell进行"><a href="#通过shell进行" class="headerlink" title="通过shell进行"></a><strong>通过shell进行</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl <span class="hljs-string">&#x27;http://localhost:8050/render.html？url=http://www.baidu.com/&amp;timeout=30.0&amp;wait=0.5&#x27;</span><br></code></pre></td></tr></table></figure><p>效果就类似于<code>get</code>请求一般，返回来的<code>html</code>是已经渲染好了的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl <span class="hljs-string">&#x27;http://localhost:8050/render.html？url=http://www.baidu.com/&amp;timeout=30.0&amp;wait=0.5&#x27;</span> -X POST<br></code></pre></td></tr></table></figure><p>如果要发送<code>post</code>请求的话，这样就可以了。</p><h4 id="通过python进行"><a href="#通过python进行" class="headerlink" title="通过python进行"></a><strong>通过python进行</strong></h4><p>使用方法很简单，就是像普通的请求那样请求本地的Splash即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">url = <span class="hljs-string">&#x27;http://localhost:8050/render.html？url=http://www.baidu.com/&amp;timeout=30.0&amp;wait=0.5&#x27;</span><br>response = request.get(url)<br>print(response.text)    <br></code></pre></td></tr></table></figure><p>使用<code>Scrapy</code>的话，有专门的<code>Scrapy</code>插件:<code>Scrapy-splash</code></p><h2 id="更多"><a href="#更多" class="headerlink" title="更多"></a><strong>更多</strong></h2><p>其实<code>splash</code>不止于渲染，能实现一些浏览器一般的操作，诸如鼠标点击，键盘输入都不在话下。<br>不过，要想实现这些，就需要编写<code>lua</code>代码来实现。<br>可以在python中写好<code>lua</code>代码，通过参数传递过去。</p>]]></content>
    
    
    
    <tags>
      
      <tag>爬虫</tag>
      
      <tag>Splash</tag>
      
      <tag>js渲染</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker-容器-基础</title>
    <link href="/post/721103b4/"/>
    <url>/post/721103b4/</url>
    
    <content type="html"><![CDATA[<h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><ul><li>Centos7 腾讯云服务器</li></ul><h2 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a>官方文档</h2><p><a href="https://docs.docker.com/install/linux/docker-ce/centos/">https://docs.docker.com/install/linux/docker-ce/centos/</a></p><h2 id="Docker的优点"><a href="#Docker的优点" class="headerlink" title="Docker的优点"></a>Docker的优点</h2><h3 id="快速，一致地交付您的应用程序"><a href="#快速，一致地交付您的应用程序" class="headerlink" title="快速，一致地交付您的应用程序"></a>快速，一致地交付您的应用程序</h3><p>Docker 允许开发人员使用您提供的应用程序或服务的本地容器在标准化环境中工作，从而简化了开发的生命周期。</p><ul><li>您的开发人员在本地编写代码，并使用 Docker 容器与同事共享他们的工作。</li><li>他们使用 Docker 将其应用程序推送到测试环境中，并执行自动或手动测试。</li><li>当开发人员发现错误时，他们可以在开发环境中对其进行修复，然后将其重新部署到测试环境中，以进行测试和验证。</li><li>测试完成后，将修补程序推送给生产环境，就像将更新的镜像推送到生产环境一样简单。</li></ul><h3 id="响应式部署和扩展"><a href="#响应式部署和扩展" class="headerlink" title="响应式部署和扩展"></a>响应式部署和扩展</h3><p>Docker 是基于容器的平台，允许高度可移植的工作负载。Docker 容器可以在开发人员的本机上，数据中心的物理或虚拟机上，云服务上或混合环境中运行。</p><p>Docker 的可移植性和轻量级的特性，还可以使您轻松地完成动态管理的工作负担，并根据业务需求指示，实时扩展或拆除应用程序和服务。</p><h3 id="在同一硬件上运行更多工作负载"><a href="#在同一硬件上运行更多工作负载" class="headerlink" title="在同一硬件上运行更多工作负载"></a>在同一硬件上运行更多工作负载</h3><p>Docker 轻巧快速。它为基于虚拟机管理程序的虚拟机提供了可行、经济、高效的替代方案，因此您可以利用更多的计算能力来实现业务目标。非常适合于高密度环境以及中小型部署，而您可以用更少的资源做更多的事情。</p><h2 id="Docker-架构"><a href="#Docker-架构" class="headerlink" title="Docker 架构"></a>Docker 架构</h2><p>Docker 包括三个基本概念:</p><ul><li>镜像（Image）<br>Docker 镜像（Image），就相当于是一个 root 文件系统。比如官方镜像 ubuntu:16.04 就包含了完整的一套 Ubuntu16.04 最小系统的 root 文件系统。</li><li>容器（Container）<br>镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的类和实例一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。</li><li>仓库（Repository）<br>仓库可看成一个代码控制中心，用来保存镜像。  </li></ul><p>Docker 使用客户端-服务器 (C/S) 架构模式，使用远程API来管理和创建Docker容器。  </p><p>Docker 容器通过 Docker 镜像来创建。</p><p>容器与镜像的关系类似于面向对象编程中的对象与类。</p><table><thead><tr><th>Docker</th><th>面向对象</th></tr></thead><tbody><tr><td>容器</td><td>对象</td></tr><tr><td>镜像</td><td>类</td></tr></tbody></table><p><img src="/Docker-%E5%AE%B9%E5%99%A8-%E5%9F%BA%E7%A1%80/20200703121310312.png"></p><table><thead><tr><th>概念</th><th>说明</th></tr></thead><tbody><tr><td>Docker 镜像(Images)</td><td>Docker 镜像是用于创建 Docker 容器的模板，比如 Ubuntu 系统。</td></tr><tr><td>Docker 容器(Container)</td><td>容器是独立运行的一个或一组应用，是镜像运行时的实体。</td></tr><tr><td>Docker 客户端(Client)</td><td>Docker 客户端通过命令行或者其他工具使用 Docker SDK (<a href="https://docs.docker.com/develop/sdk/">https://docs.docker.com/develop/sdk/</a>) 与 Docker 的守护进程通信。</td></tr><tr><td>Docker 主机(Host)</td><td>一个物理或者虚拟的机器用于执行 Docker 守护进程和容器。</td></tr><tr><td>Docker Registry</td><td>Docker 仓库用来保存镜像，可以理解为代码控制中的代码仓库。<br>Docker Hub(<a href="https://hub.docker.com/">https://hub.docker.com</a>) 提供了庞大的镜像集合供使用。<br>一个 Docker Registry 中可以包含多个仓库（Repository）；每个仓库可以包含多个标签（Tag）；每个标签对应一个镜像。通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本。我们可以通过<code> &lt;仓库名&gt;:&lt;标签&gt;</code> 的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 <code>latest</code> 作为默认标签。</td></tr><tr><td>Docker Machine</td><td>Docker Machine是一个简化Docker安装的命令行工具，通过一个简单的命令行即可在相应的平台上安装Docker，比如VirtualBox、 Digital Ocean、Microsoft Azure。</td></tr></tbody></table><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><code>Docker CE</code> 即社区免费版<br><code>Docker EE</code> 即企业版，强调安全，但需付费使用<br>此处为<code>Docker CE</code></p><h3 id="安装的前提条件"><a href="#安装的前提条件" class="headerlink" title="安装的前提条件"></a>安装的前提条件</h3><p>CentOS7 发行版 64位<br>内核版本3.10以上  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">uname -r  <span class="hljs-comment"># 查询内核版本</span><br></code></pre></td></tr></table></figure><h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a><strong>过程</strong></h3><ol><li><strong>卸载旧版本</strong><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo yum remove docker \<br>                  docker-client \<br>                  docker-client-latest \<br>                  docker-common \<br>                  docker-latest \<br>                  docker-latest-logrotate \<br>                  docker-logrotate \<br>                  docker-engine<br></code></pre></td></tr></table></figure></li><li><strong>安装必要的包</strong><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo yum install -y yum-utils \<br>  device-mapper-persistent-data \<br>  lvm2<br></code></pre></td></tr></table></figure></li><li><strong>设置可靠的存储库</strong><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo yum-config-manager \<br>    --add-repo \<br>    https://download.docker.com/linux/centos/docker-ce.repo<br></code></pre></td></tr></table></figure></li><li><strong>安装Docker-ce</strong><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum install -y docker-ce<br></code></pre></td></tr></table></figure></li><li><strong>安装Docker-ce</strong><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">systemctl start docker<br></code></pre></td></tr></table></figure></li><li><strong>测试运行 hello-world</strong><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run hello-world<br></code></pre></td></tr></table></figure> 由于本地没有hello-world这个镜像，所以会下载一个hello-world的镜像，并在容器内运行，看到以上界面说明Docker已经成功安装</li></ol><h2 id="将docker修改为国内镜像源"><a href="#将docker修改为国内镜像源" class="headerlink" title="将docker修改为国内镜像源"></a><strong>将docker修改为国内镜像源</strong></h2><p>国内<code>pull</code>很慢, 需要更换镜像源<br>这里我将镜像源更改为阿里云的</p><ol><li>打开/创建配置文件<br>没有这个文件就创建<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vim /etc/docker/daemon.json<br></code></pre></td></tr></table></figure></li><li>修改文件<br>文件中添加下面参数<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;registry-mirrors&quot;</span>: [<span class="hljs-string">&quot;https://9cpn8tt6.mirror.aliyuncs.com&quot;</span>]<br>&#125;<br></code></pre></td></tr></table></figure> 保存退出</li><li>重启Docker服务<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo service docker restart<br></code></pre></td></tr></table></figure><h3 id="可选的国内加速地址"><a href="#可选的国内加速地址" class="headerlink" title="可选的国内加速地址"></a>可选的国内加速地址</h3>你应该稍微测试一下能不能用，毕竟这东西不时出问题。</li></ol><table><thead><tr><th>镜像信息</th><th>内容</th></tr></thead><tbody><tr><td>Docker中国区官方镜像</td><td><a href="https://registry.docker-cn.com/">https://registry.docker-cn.com</a></td></tr><tr><td>网易</td><td><a href="http://hub-mirror.c.163.com/">http://hub-mirror.c.163.com</a></td></tr><tr><td>ustc</td><td><a href="https://docker.mirrors.ustc.edu.cn/">https://docker.mirrors.ustc.edu.cn</a></td></tr><tr><td>中国科技大学</td><td><a href="https://docker.mirrors.ustc.edu.cn/">https://docker.mirrors.ustc.edu.cn</a></td></tr><tr><td>阿里云容器</td><td><a href="https://cr.console.aliyun.com/">https://cr.console.aliyun.com/</a> </br>首页点击“创建我的容器镜像”  得到一个专属的镜像加速地址</td></tr></tbody></table><h2 id="启动参数"><a href="#启动参数" class="headerlink" title="启动参数"></a>启动参数</h2><h3 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h3><table><thead><tr><th>参数</th><th>简写</th><th>意义</th></tr></thead><tbody><tr><td>–detach</td><td>-d</td><td>在后台运行容器，并且打印容器id</td></tr><tr><td>–interactive</td><td>-i</td><td>即使没有连接，也要保持标准输入保持打开状态，一般与 -t 连用</td></tr><tr><td>–tty</td><td>-t</td><td>分配一个伪tty，一般与 -i 连用</td></tr></tbody></table><p><code>-i</code> <code>-t</code> <code>-d</code> 可以简写为<code>-itd</code></p><h2 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h2><h3 id="删除Docker-ce"><a href="#删除Docker-ce" class="headerlink" title="删除Docker-ce"></a>删除Docker-ce</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum remove -y docker \<br>                  docker-client \<br>                  docker-client-latest \<br>                  docker-common \<br>                  docker-latest \<br>                  docker-latest-logrotate \<br>                  docker-logrotate \<br>                  docker-selinux \<br>                  docker-engine-selinux \<br>                  docker-engine<br>rm -rf /var/lib/docker<br></code></pre></td></tr></table></figure><h3 id="查看Docker版本"><a href="#查看Docker版本" class="headerlink" title="查看Docker版本"></a>查看Docker版本</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker --version<br></code></pre></td></tr></table></figure><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="Cannot-connect-to-the-Docker-daemon-at-unix-var-run-docker-sock-Is-the-docker-daemon-running"><a href="#Cannot-connect-to-the-Docker-daemon-at-unix-var-run-docker-sock-Is-the-docker-daemon-running" class="headerlink" title="Cannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running?"></a><strong>Cannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running?</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">systemctl daemon-reload<br>systemctl restart docker.service<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Docker</tag>
      
      <tag>容器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode日常-中等-365-水壶问题</title>
    <link href="/post/3f4c2772/"/>
    <url>/post/3f4c2772/</url>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a><strong>题目</strong></h2><p>　　有两个容量分别为 x升 和 y升 的水壶以及无限多的水。请判断能否通过使用这两个水壶，从而可以得到恰好 z升 的水？<br>　　如果可以，最后请用以上水壶中的一或两个来盛放取得的 z升 水。<br>　　你允许：<br>　　　　装满任意一个水壶<br>　　　　清空任意一个水壶<br>　　　　从一个水壶向另外一个水壶倒水，直到装满或者倒空</p><p>示例 1: (From the famous “Die Hard” example)<br>　　输入: x = 3, y = 5, z = 4<br>　　输出: True</p><p>示例 2:<br>　　输入: x = 2, y = 6, z = 5<br>　　输出: False</p><h2 id="自解"><a href="#自解" class="headerlink" title="自解"></a><strong>自解</strong></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">canMeasureWater</span>(<span class="hljs-params">self, x: <span class="hljs-built_in">int</span>, y: <span class="hljs-built_in">int</span>, z: <span class="hljs-built_in">int</span></span>) -&gt; bool:</span><br>        statues = <span class="hljs-built_in">set</span>()<br>        stack = &#123;(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>)&#125;<br><br>        <span class="hljs-keyword">while</span> stack:<br>            now_x, now_y = stack.pop()<br><br>            <span class="hljs-keyword">if</span> now_x==z <span class="hljs-keyword">or</span> now_y==z <span class="hljs-keyword">or</span> now_x+now_y==z:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br><br>            <span class="hljs-keyword">if</span> (now_x, now_y) <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> statues:<br>                statues.add((now_x, now_y))<br><br>                <span class="hljs-comment"># 倒光其中一个</span><br>                stack.add((<span class="hljs-number">0</span>, now_y))<br>                stack.add((now_x, <span class="hljs-number">0</span>))<br>                <span class="hljs-comment"># 装满其中一个</span><br>                stack.add((x, now_y))<br>                stack.add((now_x, y))<br>                <span class="hljs-comment"># 一个倒入另一个, 判断是否会超出容量</span><br>                <span class="hljs-comment"># 全入y</span><br>                <span class="hljs-keyword">if</span> now_x+now_y &lt; y:<br>                    stack.add((<span class="hljs-number">0</span>, now_x+now_y))<br>                <span class="hljs-keyword">else</span>:<br>                    now_x = now_x - (y - now_y)<br>                    stack.add((now_x, y))<br>                <span class="hljs-comment"># 全入x</span><br>                <span class="hljs-keyword">if</span> now_x+now_y &lt; x:<br>                    stack.add((now_x+now_y, <span class="hljs-number">0</span>))<br>                <span class="hljs-keyword">else</span>:<br>                    now_y = now_y - (x - now_x)<br>                    stack.add((x, now_y))<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a><strong>思路</strong></h3><p>运用set(集合)不会有重复元素的功能。<br>通过深度优先的方法迭代获得结果。<br>O(xy)</p><h2 id="数学解法"><a href="#数学解法" class="headerlink" title="数学解法"></a><strong>数学解法</strong></h2><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a><strong>思路</strong></h3><p>这是一道关于<code>数论</code>的题目，确切地说是关于<code>裴蜀定理</code>（英语：Bézout’s identity）的题目。<br><a href="https://baike.baidu.com/item/%E8%A3%B4%E8%9C%80%E5%AE%9A%E7%90%86/5186593?fromtitle=%E8%B4%9D%E7%A5%96%E5%AE%9A%E7%90%86">裴蜀定理</a></p><p>　　我们认为，每次操作只会让桶里的水总量增加<code>x</code>，增加 <code>y</code>，减少<code>x</code>，或者减少<code>y</code>。  </p><p>　　你可能认为这有问题：如果往一个不满的桶里放水，或者把它排空呢？那变化量不就不是<code>x</code>或者<code>y</code>了吗？接下来我们来解释这一点：</p><ul><li>首先要清楚，在题目所给的操作下，两个桶不可能同时有水且不满。因为观察所有题目中的操作，操作的结果都至少有一个桶是空的或者满的</li><li>其次，对一个不满的桶加水是没有意义的。因为如果另一个桶是空的，那么这个操作的结果等价于直接从初始状态给这个桶加满水；而如果另一个桶是满的，那么这个操作的结果等价于从初始状态分别给两个桶加满；  </li><li>再次，把一个不满的桶里面的水倒掉是没有意义的。因为如果另一个桶是空的，那么这个操作的结果等价于回到初始状态；而如果另一个桶是满的，那么这个操作的结果等价于从初始状态直接给另一个桶倒满。</li></ul><p>　　因此，我们可以认为每次操作只会给水的总量带来 <code>x</code> 或者 <code>y</code> 的变化量。因此我们的目标可以改写成：找到一对整数 <code>a,ba</code>，使得</p><p><code>ax+by=z</code></p><p>而只要满足 <code>z≤x+y</code>，且这样的 <code>a,b</code> 存在，那么我们的目标就是可以达成的。这是因为：</p><ul><li>若 a≥0,b≥0，那么显然可以达成目标。</li><li>若 a&lt;0，那么可以进行以下操作：<ol><li>往 <code>y</code> 壶倒水；</li><li>把 <code>y</code> 壶的水倒入 <code>x</code> 壶；</li><li>如果 <code>y</code> 壶不为空，那么 <code>x</code> 壶肯定是满的，把 x 壶倒空，然后再把 <code>y</code> 壶的水倒入 <code>x</code> 壶。</li><li>重复以上操作直至某一步时 <code>x</code> 壶进行了 <code>a</code> 次倒空操作，<code>y</code> 壶进行了 <code>b</code> 次倒水操作。</li></ol></li><li>若 b&lt;0，方法同上，x 与 y 互换。</li></ul><p>而贝祖定理告诉我们，<code>ax+by=z</code> 有解当且仅当 <code>z</code> 是 <code>x,y</code> 的最大公约数的倍数。因此我们只需要找到 <code>x,y</code> 的最大公约数并判断 <code>z</code> 是否是它的倍数即可。</p><hr><p>参考：</p><ul><li><a href="https://leetcode-cn.com/problems/water-and-jug-problem/solution/shui-hu-wen-ti-by-leetcode-solution/">https://leetcode-cn.com/problems/water-and-jug-problem/solution/shui-hu-wen-ti-by-leetcode-solution/</a></li><li><a href="https://www.youtube.com/watch?v=0Oef3MHYEC0">https://www.youtube.com/watch?v=0Oef3MHYEC0</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>LeetCode</tag>
      
      <tag>裴蜀定理</tag>
      
      <tag>贝祖定理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode日常-简单-206. 反转链表</title>
    <link href="/post/44a5a6a1/"/>
    <url>/post/44a5a6a1/</url>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a><strong>题目</strong></h2><p>反转一个单链表。<br>示例:<br>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL<br>输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Definition for singly-linked list.</span><br><span class="hljs-comment"># class ListNode:</span><br><span class="hljs-comment">#     def __init__(self, x):</span><br><span class="hljs-comment">#         self.val = x</span><br><span class="hljs-comment">#         self.next = None</span><br></code></pre></td></tr></table></figure><h2 id="自解"><a href="#自解" class="headerlink" title="自解"></a><strong>自解</strong></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">reverseList</span>(<span class="hljs-params">self, head: ListNode</span>) -&gt; ListNode:</span><br>        pre, tai = <span class="hljs-literal">None</span>, head<br>        <span class="hljs-keyword">while</span> tai:<br>            temp = tai.<span class="hljs-built_in">next</span> <span class="hljs-comment"># 记下下一个节点备用</span><br><br>            tai.<span class="hljs-built_in">next</span> = pre<br>            pre = tai<br>            tai = temp<br>        <span class="hljs-keyword">return</span> pre<br></code></pre></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a><strong>思路</strong></h3><p>简单迭代，只要每次覆盖next之前记录下来就没问题了。<br>O(n)</p><h2 id="大佬解法"><a href="#大佬解法" class="headerlink" title="大佬解法"></a><strong>大佬解法</strong></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">reverseList</span>(<span class="hljs-params">self, head</span>):</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">:type head: ListNode</span><br><span class="hljs-string">:rtype: ListNode</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-comment"># 递归终止条件是当前为空，或者下一个节点为空</span><br><span class="hljs-keyword">if</span>(head==<span class="hljs-literal">None</span> <span class="hljs-keyword">or</span> head.<span class="hljs-built_in">next</span>==<span class="hljs-literal">None</span>):<br><span class="hljs-keyword">return</span> head<br><span class="hljs-comment"># 这里的cur就是最后一个节点</span><br>cur = self.reverseList(head.<span class="hljs-built_in">next</span>)<br><span class="hljs-comment"># 这里请配合动画演示理解</span><br><span class="hljs-comment"># 如果链表是 1-&gt;2-&gt;3-&gt;4-&gt;5，那么此时的cur就是5</span><br><span class="hljs-comment"># 而head是4，head的下一个是5，下下一个是空</span><br><span class="hljs-comment"># 所以head.next.next 就是5-&gt;4</span><br>head.<span class="hljs-built_in">next</span>.<span class="hljs-built_in">next</span> = head<br><span class="hljs-comment"># 防止链表循环，需要将head.next设置为空</span><br>head.<span class="hljs-built_in">next</span> = <span class="hljs-literal">None</span><br><span class="hljs-comment"># 每层递归函数都返回cur，也就是最后一个节点</span><br><span class="hljs-keyword">return</span> cur<br></code></pre></td></tr></table></figure><p><img src="/LeetCode%E6%97%A5%E5%B8%B8-%E7%AE%80%E5%8D%95-206.-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/%E9%80%92%E5%BD%92.gif"></p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a><strong>思路</strong></h3><p>这题有个很骚气的递归解法，递归解法很不好理解，这里最好配合代码和动画一起理解。<br>递归的两个条件：</p><p>终止条件是当前节点或者下一个节点==null<br>    在函数内部，改变节点的指向，也就是 head 的下一个节点指向 head 递归函数那句</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">head.<span class="hljs-built_in">next</span>.<span class="hljs-built_in">next</span> = head<br></code></pre></td></tr></table></figure><p>很不好理解，其实就是 head 的下一个节点指向head。<br>递归函数中每次返回的 cur 其实只最后一个节点，在递归函数内部，改变的是当前节点的指向。<br>动画演示如下：</p><hr><p>参考：<br><a href="https://leetcode-cn.com/problems/valid-parentheses">https://leetcode-cn.com/problems/valid-parentheses</a><br><a href="https://leetcode-cn.com/problems/reverse-linked-list/solution/dong-hua-yan-shi-206-fan-zhuan-lian-biao-by-user74/">https://leetcode-cn.com/problems/reverse-linked-list/solution/dong-hua-yan-shi-206-fan-zhuan-lian-biao-by-user74/</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>LeetCode</tag>
      
      <tag>简单</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode日常-简单-面试题 10.01. 合并排序的数组</title>
    <link href="/post/4951caca/"/>
    <url>/post/4951caca/</url>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a><strong>题目</strong></h2><p>给定两个排序后的数组 A 和 B，其中 A 的末端有足够的缓冲空间容纳 B。 编写一个方法，将 B 合并入 A 并排序。</p><p>初始化 A 和 B 的元素数量分别为 m 和 n。</p><p>示例:<br>　　输入:<br>　　　　A = [1,2,3,0,0,0], m = 3<br>　　　　B = [2,5,6],       n = 3<br>输出: [1,2,2,3,5,6]</p><p>说明:<br>　　A.length == n + m</p><h2 id="自解"><a href="#自解" class="headerlink" title="自解"></a><strong>自解</strong></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">merge</span>(<span class="hljs-params">self, A: List[<span class="hljs-built_in">int</span>], m: <span class="hljs-built_in">int</span>, B: List[<span class="hljs-built_in">int</span>], n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        Do not return anything, modify A in-place instead.</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">for</span> a <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m+n-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):<br>            <span class="hljs-comment"># 快速结束条件</span><br>            <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span>:<br>                <span class="hljs-keyword">break</span><br>            <span class="hljs-keyword">if</span> m == <span class="hljs-number">0</span>:<br>                <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>                    A[i] = B[i]<br>                <span class="hljs-keyword">break</span><br>            <span class="hljs-comment"># A与B中最后的数比较，较大的塞最后</span><br>            <span class="hljs-keyword">if</span> A[m-<span class="hljs-number">1</span>] &gt; B[n-<span class="hljs-number">1</span>]:<br>                A[a] = A[m-<span class="hljs-number">1</span>]<br>                A[m-<span class="hljs-number">1</span>] = <span class="hljs-number">0</span><br>                m = m-<span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                A[a] = B[n-<span class="hljs-number">1</span>]<br>                n = n - <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>思路：每次比较两数组最后有效的数，大的放后面。</p><h2 id="大佬解法"><a href="#大佬解法" class="headerlink" title="大佬解法"></a><strong>大佬解法</strong></h2><p>这一次我的思路居然和大佬的一样…..<br><img src="/LeetCode%E6%97%A5%E5%B8%B8-%E7%AE%80%E5%8D%95-%E9%9D%A2%E8%AF%95%E9%A2%98-10.01.-%E5%90%88%E5%B9%B6%E6%8E%92%E5%BA%8F%E7%9A%84%E6%95%B0%E7%BB%84/20200316035302605.gif"></p><h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a><strong>完整代码</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">merge</span>(<span class="hljs-params">self, A: List[<span class="hljs-built_in">int</span>], m: <span class="hljs-built_in">int</span>, B: List[<span class="hljs-built_in">int</span>], n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        idx1 = m - <span class="hljs-number">1</span><br>        idx2 = n - <span class="hljs-number">1</span><br>        cur = m + n - <span class="hljs-number">1</span> <span class="hljs-comment"># 添加 cur 指针追踪位置</span><br>        <span class="hljs-keyword">while</span> idx1 &gt; -<span class="hljs-number">1</span> <span class="hljs-keyword">and</span> idx2 &gt; -<span class="hljs-number">1</span>:<br>            <span class="hljs-comment"># print(A)</span><br>            <span class="hljs-keyword">if</span> A[idx1] &lt; B[idx2]:<br>                A[cur] = B[idx2]<br>                cur -= <span class="hljs-number">1</span><br>                idx2 -= <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                A[cur] = A[idx1]<br>                cur -= <span class="hljs-number">1</span><br>                idx1 -= <span class="hljs-number">1</span><br>        <span class="hljs-keyword">if</span> idx2 != -<span class="hljs-number">1</span>: A[:idx2 + <span class="hljs-number">1</span>] = B[:idx2 + <span class="hljs-number">1</span>] <span class="hljs-comment"># 比较完B还有剩下的，全填到A前面即可</span><br>        <span class="hljs-keyword">return</span> A<br></code></pre></td></tr></table></figure><hr><p>参考：<br><a href="https://leetcode-cn.com/problems/sorted-merge-lcci/solution/tu-jie-shuang-zhi-zhen-yuan-di-xiu-gai-by-z1m/">https://leetcode-cn.com/problems/sorted-merge-lcci/solution/tu-jie-shuang-zhi-zhen-yuan-di-xiu-gai-by-z1m/</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>LeetCode</tag>
      
      <tag>简单</tag>
      
      <tag>合并排序的数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>服务器部署-CentOS-VNC-tigervnc</title>
    <link href="/post/68a5bdc6/"/>
    <url>/post/68a5bdc6/</url>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a><strong>环境</strong></h2><ul><li>Centos7.2 腾讯云服务器</li></ul><h2 id="VNC简介"><a href="#VNC简介" class="headerlink" title="VNC简介"></a><strong>VNC简介</strong></h2><p>VNC由Olivetti &amp; Oracle研究室所開發，此研究室在1999年併入美國電話電報公司（AT&amp;T）。AT&amp;T於2002年中止了此研究室的運作，並把VNC以GPL釋出。<br>由於VNC以GPL授權，衍生出了幾個VNC軟體：</p><table><thead><tr><th>VNC类型</th><th>信息</th></tr></thead><tbody><tr><td>RealVNC</td><td>由VNC團隊部份成員開發，分為全功能商業版及免費版。</td></tr><tr><td>TightVNC</td><td>強調節省頻寬使用</td></tr><tr><td>UltraVNC</td><td>加入了TightVNC的部份程式及加強效能的圖型映射驅動程式，並結合Active Directory及NTLM的帳號密碼認證，但僅有Windows版本。</td></tr><tr><td>Vine Viewer</td><td>MacOSX的VNC用戶端</td></tr></tbody></table><h2 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a><strong>官方文档</strong></h2><p><a href="https://tigervnc.org/">官方首页</a><br>在首页下面有配置相关的文档<br>[TigerVNC的官方github Wiki](<a href="https://github.com/TigerVNC/tigervnc/wiki">https://github.com/TigerVNC/tigervnc/wiki</a><br><a href="https://tigervnc.org/doc/vncconfig.html">https://tigervnc.org/doc/vncconfig.html</a>)</p><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a><strong>操作</strong></h2><h3 id="部署服务器端"><a href="#部署服务器端" class="headerlink" title="部署服务器端"></a><strong>部署服务器端</strong></h3><h4 id="TightVNC安装与配置"><a href="#TightVNC安装与配置" class="headerlink" title="TightVNC安装与配置"></a><strong>TightVNC安装与配置</strong></h4><ol><li><strong>检查是否安装VNC</strong><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">rpm -q tigervnc tigervnc-server<br></code></pre></td></tr></table></figure></li><li><strong>安装X-Window</strong><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum groupinstall <span class="hljs-string">&quot;X Window System&quot;</span><br></code></pre></td></tr></table></figure></li><li><strong>安装VNC</strong><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum install tigervnc-server -y <br></code></pre></td></tr></table></figure></li><li><strong>更改启动设置</strong></li><li>打开启动设置配置文件<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vim /root/.vnc/xstartup<br></code></pre></td></tr></table></figure></li><li>将配置文件的内容替换为以下下内容<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/sh</span><br><span class="hljs-comment">#Uncomment the following two lines for normal desktop:</span><br><span class="hljs-built_in">unset</span> SESSION_MANAGER<br><span class="hljs-comment">#exec /etc/X11/xinit/xinitrc</span><br>[ -x /etc/vnc/xstartup ] &amp;&amp; <span class="hljs-built_in">exec</span> /etc/vnc/xstartup<br>[ -r <span class="hljs-variable">$HOME</span>/.Xresources ] &amp;&amp; xrdb KaTeX parse error: Expected <span class="hljs-string">&#x27;EOF&#x27;</span>, got <span class="hljs-string">&#x27;&amp;&#x27;</span> at position 59: …config -iconic &amp;̲ <span class="hljs-comment">#xterm -geome…VNCDESKTOP Desktop&quot;&amp;</span><br><span class="hljs-comment">#twm &amp;</span><br>startxfce4 &amp;<br></code></pre></td></tr></table></figure></li><li><strong>配置VNC</strong><ol><li><strong>打开配置文件</strong><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vim /etc/systemd/system/vncserver@\:1.service<br></code></pre></td></tr></table></figure></li><li><strong>根据文件里的提示修改一些配置</strong><br><img src="/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2-CentOS-VNC-tigervnc/20200313124928499.png"><br>这里给出一个xfce的简单配置<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[Unit]</span><br><span class="hljs-attr">Description</span>=Remote desktop service (VNC)<br><span class="hljs-attr">After</span>=syslog.target network.target<br><br><span class="hljs-section">[Service]</span><br><span class="hljs-attr">Type</span>=simple<br><br><span class="hljs-comment"># Clean any existing files in /tmp/.X11-unix environment</span><br><span class="hljs-attr">ExecStartPre</span>=/bin/sh -c <span class="hljs-string">&#x27;/usr/bin/vncserver -kill %i &gt; /dev/null 2&gt;&amp;1 || :&#x27;</span><br><span class="hljs-attr">ExecStart</span>=/usr/sbin/runuser -l root -c <span class="hljs-string">&quot;/usr/bin/vncserver %i&quot;</span><br><span class="hljs-attr">PIDFile</span>=/root/.vnc/%H%i.pid<br><span class="hljs-attr">ExecStop</span>=/bin/sh -c <span class="hljs-string">&#x27;/usr/bin/vncserver -kill %i &gt; /dev/null 2&gt;&amp;1 || :&#x27;</span><br><br><span class="hljs-section">[Install]</span><br><span class="hljs-attr">WantedBy</span>=multi-user.target<br></code></pre></td></tr></table></figure>实际上，如果你有多个用户想用vnc就要配置多份配置</li></ol></li><li>系统重新加载配置<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">systemctl daemon-reload<br></code></pre></td></tr></table></figure></li><li>为VNC配置密码<br>这个密码是使用VNC客户端链接服务器时所使用的密码<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vncpasswd /etc/vncpasswd<br></code></pre></td></tr></table></figure></li><li>启动VNC服务<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">systemctl start vncserver@\:1.service<br></code></pre></td></tr></table></figure></li><li>设置VNC服务开机启动<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">systemctl <span class="hljs-built_in">enable</span> vncserver@\:1.service<br></code></pre></td></tr></table></figure><h4 id="设置防火墙"><a href="#设置防火墙" class="headerlink" title="设置防火墙"></a><strong>设置防火墙</strong></h4>VNC的运行端口是基于配置的。<br>VNC的默认端口是<code>5900</code><br>我在上面配置了<code>vncserver@:1.service</code><br>那么这个配置的 VNC 会运行在 <code>5900</code> + <code>1</code> = <code>5901</code> 端口<br>输入代码在防火墙中开启 对应端口的TCP连接即可。<a href="/post/67dbc8e6/" title="服务器部署-CentOS-firewall-防火墙">服务器部署-CentOS-firewall-防火墙</a></li></ol><h4 id="常用VNC命令"><a href="#常用VNC命令" class="headerlink" title="常用VNC命令"></a><strong>常用VNC命令</strong></h4><ol><li>运行一个VNC服务<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vncserver :服务号码<br></code></pre></td></tr></table></figure></li><li>查看正在运行的VNC服务进程<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vncserver -list<br></code></pre></td></tr></table></figure></li><li>关闭某个VNC服务进程<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vncserver -<span class="hljs-built_in">kill</span> :VNC服务号<br></code></pre></td></tr></table></figure><h3 id="用户端"><a href="#用户端" class="headerlink" title="用户端"></a><strong>用户端</strong></h3><h4 id="下载客户端"><a href="#下载客户端" class="headerlink" title="下载客户端"></a><strong>下载客户端</strong></h4>这个Tiger VNC Viewer的github页<br><a href="https://github.com/TigerVNC/tigervnc/releases">https://github.com/TigerVNC/tigervnc/releases</a><br>软件下载的网页不挂梯子的话卡的不行，基本不可能下载下来。</li></ol><h4 id="连接服务器"><a href="#连接服务器" class="headerlink" title="连接服务器"></a><strong>连接服务器</strong></h4><p>输入地址和VNC服务号码即可。<br>形如：<code>服务器ip:VNC配置防火墙端口号</code><br>例如：<code>192.168.1.1:5901</code><br>成功连接后会要求输入VNC密码<br>输入正确后就能连上了</p><h2 id="更多操作"><a href="#更多操作" class="headerlink" title="更多操作"></a><strong>更多操作</strong></h2><h3 id="修改TigerVNC默认端口"><a href="#修改TigerVNC默认端口" class="headerlink" title="修改TigerVNC默认端口"></a><strong>修改TigerVNC默认端口</strong></h3><ol><li>打开源码文件<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vi /usr/bin/vncserver<br></code></pre></td></tr></table></figure></li><li>在文中找到端口内容<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs perl">vncPort = <span class="hljs-number">5900</span> + $displayNumber<br><span class="hljs-keyword">if</span> (!<span class="hljs-keyword">bind</span>(S, <span class="hljs-keyword">pack</span>(<span class="hljs-string">&#x27;S n x12&#x27;</span>, $AF_INET, <span class="hljs-number">5900</span> + $n))) &#123; <br></code></pre></td></tr></table></figure></li><li>修改端口内容<br>这里我把默认的<code>5900</code>端口改成了<code>15900</code>端口<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs perl">vncPort = <span class="hljs-number">15900</span> + $displayNumber<br><span class="hljs-keyword">if</span> (!<span class="hljs-keyword">bind</span>(S, <span class="hljs-keyword">pack</span>(<span class="hljs-string">&#x27;S n x12&#x27;</span>, $AF_INET, <span class="hljs-number">15900</span> + $n))) &#123; <br></code></pre></td></tr></table></figure>需要注意的是，端口改了，防火墙设置也要改，连接时用的端口号也要改。<br>由于RealVNC viewer没有手动设置端口的功能，只能从默认端口登入。所以上面我给的是TigerVNC viewer。</li></ol><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a><strong>问题</strong></h2><p>会与Anconda发生冲突，如果设置了环境变量的话</p>]]></content>
    
    
    
    <tags>
      
      <tag>服务器</tag>
      
      <tag>CentOS</tag>
      
      <tag>VNC</tag>
      
      <tag>tigervnc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>服务器部署-CentOS-图形界面</title>
    <link href="/post/4d03d9bb/"/>
    <url>/post/4d03d9bb/</url>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a><strong>环境</strong></h2><ul><li>Centos7.2 腾讯云服务器</li></ul><h2 id="图形界面该如何选择"><a href="#图形界面该如何选择" class="headerlink" title="图形界面该如何选择"></a><strong>图形界面该如何选择</strong></h2><table><thead><tr><th>桌面环境/窗口管理器</th><th>RAM used</th><th>% CPU used</th><th>类型</th></tr></thead><tbody><tr><td>KDE 4.6</td><td>363 MB</td><td>4 %</td><td>桌面环境</td></tr><tr><td>Unity</td><td>271 MB</td><td>14%</td><td>桌面环境(shell)</td></tr><tr><td>GNOME 2</td><td>191 MB</td><td>1 %</td><td>桌面环境</td></tr><tr><td>GNOME 3</td><td>193 MB</td><td>10%</td><td>桌面环境</td></tr><tr><td>XFCE 4.8</td><td>144 MB</td><td>10 %</td><td>桌面环境</td></tr><tr><td>LXDE</td><td>85 MB</td><td>10 %</td><td>桌面环境</td></tr><tr><td>2019年数据,来自网络。</td><td></td><td></td><td></td></tr></tbody></table><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a><strong>操作</strong></h2><h3 id="1-安装epel源"><a href="#1-安装epel源" class="headerlink" title="1. 安装epel源"></a><strong>1. 安装epel源</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum install epel-release<br></code></pre></td></tr></table></figure><h3 id="2-安装桌面协议”X-Window-system”"><a href="#2-安装桌面协议”X-Window-system”" class="headerlink" title="2. 安装桌面协议”X Window system”"></a><strong>2. 安装桌面协议”X Window system”</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum groupinstall <span class="hljs-string">&quot;X Window system&quot;</span><br></code></pre></td></tr></table></figure><h3 id="3-安装一个GUI"><a href="#3-安装一个GUI" class="headerlink" title="3. 安装一个GUI"></a><strong>3. 安装一个GUI</strong></h3><p>其实有很多种选择，一般在xfce和GNOME中选一个来安装    </p><h4 id="xfce"><a href="#xfce" class="headerlink" title="xfce"></a>xfce</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum groupinstall xfce<br></code></pre></td></tr></table></figure><h4 id="GNOME"><a href="#GNOME" class="headerlink" title="GNOME"></a>GNOME</h4><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">yum</span> groupinstall <span class="hljs-string">&quot;GNOME Desktop&quot;</span> <span class="hljs-string">&quot;Graphical Administration Tools&quot;</span> <br></code></pre></td></tr></table></figure><h3 id="4-设置运行级别"><a href="#4-设置运行级别" class="headerlink" title="4. 设置运行级别"></a><strong>4. 设置运行级别</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo systemctl set-default graphical.target<br></code></pre></td></tr></table></figure><h3 id="5-查看运行级别"><a href="#5-查看运行级别" class="headerlink" title="5. 查看运行级别"></a><strong>5. 查看运行级别</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">runlevel   返回当前运行级别<br></code></pre></td></tr></table></figure><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td>0</td><td>runlevel1.target/poweroff.target</td><td>关机</td></tr><tr><td>1</td><td>runlevel1.target, rescue.target</td><td>单用户模式</td></tr><tr><td>2,4</td><td>runlevel2.target, runlevel4.target, multi-user.target</td><td>用户定义/域特定运行级别。默认等同于 3。</td></tr><tr><td>3</td><td>runlevel3.target, multi-user.target</td><td>多用户，非图形化。用户可以通过多个控制台或网络登录。</td></tr><tr><td>5</td><td>runlevel5.target, graphical.target</td><td>多用户，图形化。通常为所有运行级别 3 的服务外加图形化登录。</td></tr><tr><td>6</td><td>runlevel6.target, reboot.target</td><td>重启</td></tr><tr><td>emergency</td><td>emergency.target</td><td>紧急Shell</td></tr></tbody></table><h2 id="附言"><a href="#附言" class="headerlink" title="附言"></a><strong>附言</strong></h2><p>装上了图形界面，运行了，也不代表你能看到。<br>你需要用一些支持图形界面的连接方式连上服务器才能看到图形界面。<br>如：VNC, XDMCP之类的</p>]]></content>
    
    
    
    <tags>
      
      <tag>服务器</tag>
      
      <tag>CentOS</tag>
      
      <tag>xfce</tag>
      
      <tag>图形界面</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CentOS-Chrome</title>
    <link href="/post/799278f5/"/>
    <url>/post/799278f5/</url>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a><strong>环境</strong></h2><ul><li>Centos7.4 腾讯云服务器</li></ul><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a><strong>操作</strong></h2><ol><li>添加源<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo wget http://repo.fdzh.org/chrome/google-chrome-mirrors.repo -P /etc/yum.repos.d/<br></code></pre></td></tr></table></figure></li><li>安装Chrome<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo yum install google-chrome-stable<br></code></pre></td></tr></table></figure></li><li>为Chrome添加启动参数<ol><li>vim打开设置<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vim  /usr/share/applications/google-chrome.desktop<br></code></pre></td></tr></table></figure></li><li>修改设置<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">Exec=/usr/bin/google-chrome-stable %U<br></code></pre></td></tr></table></figure>↓修改为↓<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">Exec=/usr/bin/google-chrome-stable %U --no-sandbox<br></code></pre></td></tr></table></figure></li><li>退出，保存。</li></ol></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>服务器</tag>
      
      <tag>CentOS</tag>
      
      <tag>Chrome</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CentOS-yum</title>
    <link href="/post/b43bef47/"/>
    <url>/post/b43bef47/</url>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a><strong>环境</strong></h2><ul><li>Centos7.2 腾讯云服务器</li></ul><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a><strong>常用命令</strong></h2><ol><li>安装、卸载、更新软件<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum install 软件名称  <span class="hljs-comment"># 安装</span><br>yum remove 软件名称  <span class="hljs-comment"># 卸载</span><br>yum update 软件名称  <span class="hljs-comment"># 更新</span><br>yum update  <span class="hljs-comment"># 更新所有软件命令</span><br></code></pre></td></tr></table></figure></li><li>清理<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum remove 包名  <span class="hljs-comment"># 删除软件包</span><br>yum clean packages  <span class="hljs-comment"># 清除缓存目录下的软件包</span><br>yum clean headers  <span class="hljs-comment"># 清除缓存目录下的 headers</span><br>yum clean oldheaders  <span class="hljs-comment"># 清除缓存目录下旧的 headers</span><br></code></pre></td></tr></table></figure></li><li>查看信息<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum list  <span class="hljs-comment"># 列出所有可安装的软件包</span><br>yum list updates  <span class="hljs-comment"># 列出所有可更新的软件包</span><br>yum list installed  <span class="hljs-comment"># 列出所有已安装的软件包</span><br><br>yum info updates  <span class="hljs-comment"># 列出所有可更新的软件包信息</span><br>yum info installed  <span class="hljs-comment"># 列出所有已安裝的软件包信息</span><br></code></pre></td></tr></table></figure><h2 id="不常用命令"><a href="#不常用命令" class="headerlink" title="不常用命令"></a><strong>不常用命令</strong></h2><table><thead><tr><th>命令参数</th><th>信息</th></tr></thead><tbody><tr><td>makecache</td><td>创建元数据缓存</td></tr><tr><td>deplist</td><td>列出软件包的依赖关系</td></tr><tr><td>erase</td><td>从系统中移除一个或多个软件包</td></tr><tr><td>groupinfo</td><td>显示组的详细信息</td></tr><tr><td>groupinstall</td><td>向系统中安装一组软件包</td></tr><tr><td>grouplist</td><td>列出可安装的组</td></tr><tr><td>groupremove</td><td>从系统中移除一组软件包</td></tr><tr><td>help</td><td>显示用法信息</td></tr><tr><td>info</td><td>显示关于软件包或组的详细信息</td></tr><tr><td>provides</td><td>查找提供指定内容的软件包</td></tr><tr><td>reinstall</td><td>覆盖安装一个包</td></tr><tr><td>repolist</td><td>显示已配置的仓库</td></tr><tr><td>resolvedep</td><td>判断哪个包提供了指定的依赖</td></tr><tr><td>search</td><td>在软件包详细信息中搜索指定字符串</td></tr><tr><td>version</td><td>yum版本信息</td></tr></tbody></table></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>服务器</tag>
      
      <tag>CentOS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>服务器部署-CentOS-中文乱码-utf-8</title>
    <link href="/post/2b4c0931/"/>
    <url>/post/2b4c0931/</url>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a><strong>环境</strong></h2><ul><li>Centos7.2 腾讯云服务器</li></ul><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a><strong>操作</strong></h2><h3 id="1-安装中文字库"><a href="#1-安装中文字库" class="headerlink" title="1. 安装中文字库"></a><strong>1. 安装中文字库</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum groupinstall <span class="hljs-string">&quot;fonts&quot;</span> -y<br></code></pre></td></tr></table></figure><h3 id="2-查看中文字库"><a href="#2-查看中文字库" class="headerlink" title="2. 查看中文字库"></a><strong>2. 查看中文字库</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">locale -a | grep <span class="hljs-string">&quot;zh_CN&quot;</span>  <br></code></pre></td></tr></table></figure><p>命令意义：列出所有可用的公共语言环境的名称，然后筛选中文</p><p>如果安装正确的话，会有如下项：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">zh_CN</span><br><span class="hljs-selector-tag">zh_CN</span><span class="hljs-selector-class">.gb18030</span><br><span class="hljs-selector-tag">zh_CN</span><span class="hljs-selector-class">.gb2312</span><br><span class="hljs-selector-tag">zh_CN</span><span class="hljs-selector-class">.gbk</span><br><span class="hljs-selector-tag">zh_CN</span><span class="hljs-selector-class">.utf8</span><br></code></pre></td></tr></table></figure><p>每项结果的含义：{语言代号}_{国家代号}.{字符集}<br>自此，中文显示会变得正常。<br>但系统的语言环境是英文，所以显示的都是英文信息。</p><h3 id="3-重启系统"><a href="#3-重启系统" class="headerlink" title="3. 重启系统"></a><strong>3. 重启系统</strong></h3><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">reboot</span><br></code></pre></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a><strong>其他</strong></h2><h3 id="修改系统语言环境"><a href="#修改系统语言环境" class="headerlink" title="修改系统语言环境"></a><strong>修改系统语言环境</strong></h3><p>个人其实不建议作这种修改。</p><h4 id="修改方法"><a href="#修改方法" class="headerlink" title="修改方法"></a>修改方法</h4><p>这里将环境改为 <code>zh_CN.UTF-8</code><br>如果直接 <code>zh_CN</code>，会出现乱码。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">localectl set-locale LANG=zh_CN.UTF-8<br></code></pre></td></tr></table></figure><h4 id="重启后验证是否修改成功"><a href="#重启后验证是否修改成功" class="headerlink" title="重启后验证是否修改成功"></a>重启后验证是否修改成功</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">date<br></code></pre></td></tr></table></figure><p>返回的日期是中文的，说明成功。</p>]]></content>
    
    
    
    <tags>
      
      <tag>服务器</tag>
      
      <tag>CentOS</tag>
      
      <tag>中文乱码</tag>
      
      <tag>utf-8</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CentOS-EPEL-源</title>
    <link href="/post/22732f7a/"/>
    <url>/post/22732f7a/</url>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a><strong>环境</strong></h2><ul><li>Centos7.2 腾讯云服务器</li><li>EPEL7</li></ul><h3 id="什么是EPEL"><a href="#什么是EPEL" class="headerlink" title="什么是EPEL?"></a><strong>什么是EPEL?</strong><span id='WhatIsEPEL'></span></h3><p>　　EPEL的全称叫 Extra Packages for Enterprise Linux 。EPEL是由 Fedora 社区打造，为 RHEL 及衍生发行版如 CentOS、Scientific Linux 等提供高质量软件包的项目。<br>　　<strong>装上了 EPEL之后，就相当于添加了一个第三方源。</strong><br>　　如果你知道rpmfusion.org的话，拿 rpmfusion 做比较还是很恰当的。rpmfusion 主要为桌面发行版提供大量rpm包，而EPEL则为服务器版本提供大量的rpm包，而且大多数rpm包在官方 repository 中是找不到的。EPEL绝大多数rpm包要比官方repository 的rpm包版本要来得新。</p><h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a><strong>过程</strong></h2><ol><li>安装 EPEL<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum install epel-release<br></code></pre></td></tr></table></figure></li><li>更新源<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum clean all &amp;&amp; yum makecache<br></code></pre></td></tr></table></figure><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a><strong>其它</strong></h2><h3 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h3></li><li>卸载本体<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum remove epel-release<br></code></pre></td></tr></table></figure></li><li>清空epel目录<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">rm -rf /var/cache/yum/x86_64/7/epel/<br></code></pre></td></tr></table></figure>注意到有一个叫 7 的目录，这代表着是EPEL7的记录。<br>如果你试图卸载其它版本，那么是其它数字。</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>服务器</tag>
      
      <tag>CentOS</tag>
      
      <tag>EPEL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>服务器部署-CentOS-基本安全设置</title>
    <link href="/post/db527ca6/"/>
    <url>/post/db527ca6/</url>
    
    <content type="html"><![CDATA[<h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><ul><li>Centos7.2 腾讯云服务器</li></ul><h2 id="基本信息确认"><a href="#基本信息确认" class="headerlink" title="基本信息确认"></a>基本信息确认</h2><h3 id="密码"><a href="#密码" class="headerlink" title="密码"></a>密码</h3><ul><li>连接服务器的各类型密码不应低于8位（建议20位）  </li><li>密码字符涵盖类型越多越好。数字、英文大写、小写、特殊字符  </li></ul><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><h3 id="一、修改主机名"><a href="#一、修改主机名" class="headerlink" title="一、修改主机名"></a>一、修改主机名</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hostnamectl set-hostname  主机名<br></code></pre></td></tr></table></figure><h3 id="二、创建新用户，禁用root登录"><a href="#二、创建新用户，禁用root登录" class="headerlink" title="二、创建新用户，禁用root登录"></a>二、创建新用户，禁用root登录</h3><p>禁用在SSH中直接使用root用户登录。<br>想要获取服务器所有权限，需要先用普通用户登录成功后，再进行root用户的登录获取。<br>使得他人更难接触root用户的难度增加，服务器更安全。</p><h4 id="1-新建用户"><a href="#1-新建用户" class="headerlink" title="1. 新建用户"></a>1. 新建用户</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">adduser 用户名  <span class="hljs-comment"># 新建用户</span><br>passwd 用户名  <span class="hljs-comment"># 为新用户设置密码</span><br></code></pre></td></tr></table></figure><p><a href="#WhatIsadduser">Linux adduser命令是啥？</a>　<a href="#WhatIspasswd">Linux passwd命令是啥？</a></p><h4 id="2-创建doc文件夹"><a href="#2-创建doc文件夹" class="headerlink" title="2. 创建doc文件夹"></a>2. 创建doc文件夹</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">mkdir  /opt/doc<br></code></pre></td></tr></table></figure><p><a href="#WhatIsmkdir">Linux passwd命令是啥？</a></p><h4 id="3-为新用户分配doc目录权限"><a href="#3-为新用户分配doc目录权限" class="headerlink" title="3. 为新用户分配doc目录权限"></a>3. 为新用户分配doc目录权限</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">chown  用户名   /opt/doc<br>chmod  755   /opt/doc<br></code></pre></td></tr></table></figure><p><a href="#WhatIschown">Linux chown命令是啥？</a>　<a href="#WhatIschmod">Linux chmod命令是啥？</a></p><h4 id="4-SSH禁止使用root用户登录"><a href="#4-SSH禁止使用root用户登录" class="headerlink" title="4. SSH禁止使用root用户登录"></a>4. SSH禁止使用root用户登录</h4><ol><li>打开ssh配置文件<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vi /etc/ssh/sshd_config<br></code></pre></td></tr></table></figure></li><li>找到对应项并设置为no<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">PermitRootLogin no<br></code></pre></td></tr></table></figure></li><li>重新启动SSH服务以应用设置<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">service sshd restart<br></code></pre></td></tr></table></figure><h4 id="5-测试root用户登录"><a href="#5-测试root用户登录" class="headerlink" title="5. 测试root用户登录"></a>5. 测试root用户登录</h4>测试看看，是不是通过root用户无法直接登录了。<br>要是登录不了，说明成功了。</li></ol><h3 id="三、修改SSH端口"><a href="#三、修改SSH端口" class="headerlink" title="三、修改SSH端口"></a>三、修改SSH端口</h3><p>SSH端口不为22<br>使得黑客需要扫描很多的端口才能发现真的SSH端口，浪费黑客的时间。</p><h4 id="1-修改SSH配置文件"><a href="#1-修改SSH配置文件" class="headerlink" title="1. 修改SSH配置文件"></a>1. 修改SSH配置文件</h4><ol><li><p>打开配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vi /etc/ssh/sshd_config<br></code></pre></td></tr></table></figure></li><li><p>找到 #Port 22 并做修改</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#Port 22</span><br></code></pre></td></tr></table></figure><p> 修改为↓</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">Port 22 <span class="hljs-comment"># 将旧端口也取消注释保留，使得两端口暂时并存，以防操作失误导致无法连接服务器。</span><br>Port 51369 <span class="hljs-comment"># 新起一行，设置新的SSH端口。注意别与已用端冲突。</span><br></code></pre></td></tr></table></figure><h4 id="2-修改修改SELinux"><a href="#2-修改修改SELinux" class="headerlink" title="2. 修改修改SELinux"></a>2. 修改修改SELinux</h4></li><li><p>安装semanage（已安装的可以跳过）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum -y install policycoreutils-python.x86_64<br></code></pre></td></tr></table></figure></li><li><p>添加51369端口到 SELinux</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">semanage port -a -t ssh_port_t -p tcp 51369<br></code></pre></td></tr></table></figure></li><li><p>查看当前SElinux 允许的ssh端口</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">semanage port -l | grep ssh<br></code></pre></td></tr></table></figure><p> 成果添加端口的话会有两个端口<br> ssh_port_t tcp 51369, 22</p></li><li><p>重新启动SSH服务以应用设置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">systemctl restart sshd.service<br></code></pre></td></tr></table></figure><h4 id="3-防火墙-安全组-开放对应端口"><a href="#3-防火墙-安全组-开放对应端口" class="headerlink" title="3. 防火墙/安全组 开放对应端口"></a>3. 防火墙/安全组 开放对应端口</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">firewall-cmd --permanent --zone=public --add-port=51369/tcp <br></code></pre></td></tr></table></figure><h4 id="4-尝试通过51369端口SSH登录服务器"><a href="#4-尝试通过51369端口SSH登录服务器" class="headerlink" title="4.尝试通过51369端口SSH登录服务器"></a>4.尝试通过51369端口SSH登录服务器</h4><h4 id="5-在SSH配置文件中删除22端口"><a href="#5-在SSH配置文件中删除22端口" class="headerlink" title="5.在SSH配置文件中删除22端口"></a>5.在SSH配置文件中删除22端口</h4></li><li><p>打开配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vi /etc/ssh/sshd_config<br></code></pre></td></tr></table></figure></li><li><p>找到第一步被去掉注释符号的 Port 22 并删除</p></li></ol><h3 id="四、定期检查"><a href="#四、定期检查" class="headerlink" title="四、定期检查"></a><strong>四、定期检查</strong></h3><h4 id="1-定期检查进程"><a href="#1-定期检查进程" class="headerlink" title="1. 定期检查进程"></a>1. 定期检查进程</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">top<br></code></pre></td></tr></table></figure><p>top命令在centos下检查有没有占用很大又名字奇怪的进程。</p><h4 id="2-定期检查近期试图登陆"><a href="#2-定期检查近期试图登陆" class="headerlink" title="2. 定期检查近期试图登陆"></a>2. 定期检查近期试图登陆</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">lastb  <span class="hljs-comment"># 显示最近没有登录成功的信息</span><br>last  <span class="hljs-comment"># 显示最近登陆成功的ip地址</span><br></code></pre></td></tr></table></figure><h4 id="3-定期检查有没有不合理的命令"><a href="#3-定期检查有没有不合理的命令" class="headerlink" title="3. 定期检查有没有不合理的命令"></a>3. 定期检查有没有不合理的命令</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">history</span>  <span class="hljs-comment"># 显示最近的命令输入</span><br></code></pre></td></tr></table></figure><p>查询下有没有近期不合理的命令。</p><hr><h2 id="更多服务器安全设置参考https-blog-csdn-net-scorpio3k-article-details-48678661-depth-1-utm-source-distribute-pc-relevant-none-task-amp-utm-source-distribute-pc-relevant-none-task"><a href="#更多服务器安全设置参考https-blog-csdn-net-scorpio3k-article-details-48678661-depth-1-utm-source-distribute-pc-relevant-none-task-amp-utm-source-distribute-pc-relevant-none-task" class="headerlink" title="更多服务器安全设置参考https://blog.csdn.net/scorpio3k/article/details/48678661?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task"></a>更多服务器安全设置参考<a href="https://blog.csdn.net/scorpio3k/article/details/48678661?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task">https://blog.csdn.net/scorpio3k/article/details/48678661?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task</a></h2><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a><strong>附录</strong></h2><h3 id="Linux-adduser命令"><a href="#Linux-adduser命令" class="headerlink" title="Linux adduser命令"></a>Linux adduser命令<span id='WhatIsadduser'></span></h3><p>用于新增使用者帐号或更新预设的使用者资料。<br>adduser 与 useradd 指令为同一指令（经由符号连结 symbolic link）。<br>使用权限：系统管理员。<br><a href="https://www.runoob.com/linux/linux-comm-adduser.html">命令与参数详细</a></p><h3 id="Linux-passwd"><a href="#Linux-passwd" class="headerlink" title="Linux passwd"></a>Linux passwd<span id='WhatIspasswd'></span></h3><p>更改使用者的密码。<br><a href="https://www.runoob.com/linux/linux-comm-passwd.html">命令与参数详细</a></p><h3 id="Linux-mkdir"><a href="#Linux-mkdir" class="headerlink" title="Linux mkdir"></a>Linux mkdir<span id='WhatIsmkdir'></span></h3><p>用于建立目录。<br><a href="https://www.runoob.com/linux/linux-comm-mkdir.html">命令与参数详细</a></p><h3 id="Linux-chmod"><a href="#Linux-chmod" class="headerlink" title="Linux chmod"></a>Linux chmod<span id='WhatIschmod'></span></h3><p>Linux/Unix 的文件调用权限分为三级 : 文件拥有者、群组、其他。<br>利用 chmod 可以藉以控制文件如何被他人所调用。<br>使用权限 : 所有使用者<br><a href="https://www.runoob.com/linux/linux-comm-chmod.html">命令与参数详细</a></p><h3 id="Linux-chown"><a href="#Linux-chown" class="headerlink" title="Linux chown"></a>Linux chown<span id='WhatIschown'></span></h3><p>Linux/Unix 是多人多工操作系统，所有的文件皆有拥有者。<br>利用 chown 将指定文件的拥有者改为指定的用户或组，用户可以是用户名或者用户ID；组可以是组名或者组ID；文件是以空格分开的要改变权限的文件列表，支持通配符。<br>一般来说，这个指令只有是由系统管理者(root)所使用，一般使用者没有权限可以改变别人的文件拥有者，也没有权限把自己的文件拥有者改设为别人。只有系统管理者(root)才有这样的权限。<br><a href="https://www.runoob.com/linux/linux-comm-chown.html">命令与参数详细</a></p><hr><p>参考：<br><a href="https://blog.csdn.net/qinglingLS/article/details/86755722">https://blog.csdn.net/qinglingLS/article/details/86755722</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>服务器</tag>
      
      <tag>CentOS</tag>
      
      <tag>服务器安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>服务器部署-CentOS-firewall-防火墙</title>
    <link href="/post/67dbc8e6/"/>
    <url>/post/67dbc8e6/</url>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a><strong>环境</strong></h2><ul><li>Centos7.2 腾讯云服务器</li><li>Win 10 专业版 本地</li><li>XShell 6.0.0031</li></ul><h2 id="防火墙的作用"><a href="#防火墙的作用" class="headerlink" title="防火墙的作用"></a><strong>防火墙的作用</strong></h2><ul><li>复杂来说：<br>防火墙技术是通过有机结合各类用于安全管理与筛选的软件和硬件设备，帮助计算机网络于其内、外网之间构建一道相对隔绝的保护屏障。</li><li>简单来说<br>关掉家里没必要打开的窗户，以防小偷或者销售人员进来打扰。</li></ul><h2 id="防火墙须知要点"><a href="#防火墙须知要点" class="headerlink" title="防火墙须知要点"></a><strong>防火墙须知要点</strong></h2><h3 id="防火墙许可"><a href="#防火墙许可" class="headerlink" title="防火墙许可"></a><strong>防火墙许可</strong></h3><p>防火墙许可有三种：</p><ul><li>Allow：允许。</li><li>Deny：无视请求。</li><li>Reject：拒绝请求，并告诉发过来的家伙，我拒绝了你。</li><li>Limit：指定特定IP，拒绝它的访问。</li></ul><h3 id="防火墙方向"><a href="#防火墙方向" class="headerlink" title="防火墙方向"></a><strong>防火墙方向</strong></h3><p>防火墙不仅可以对进来的数据进行限制。也能对出去的数据进行限制。</p><h3 id="常用防火墙设置信息"><a href="#常用防火墙设置信息" class="headerlink" title="常用防火墙设置信息"></a><strong>常用防火墙设置信息</strong></h3><table><thead><tr><th>协议:端口</th><th>信息</th></tr></thead><tbody><tr><td>TCP:22</td><td>Linux SSH登录</td></tr><tr><td>TCP:80</td><td>Web服务HTTP</td></tr><tr><td>TCP:443</td><td>Web服务HTTPS</td></tr><tr><td>TCP:3306</td><td>MySQL服务</td></tr></tbody></table><h2 id="常用防火墙设置命令"><a href="#常用防火墙设置命令" class="headerlink" title="常用防火墙设置命令"></a><strong>常用防火墙设置命令</strong></h2><h3 id="firewall服务"><a href="#firewall服务" class="headerlink" title="firewall服务"></a>firewall服务</h3><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">systemctl status firewalld  <span class="hljs-comment"># 查看firewall service状态</span><br>systemctl disable firewalld.service  <span class="hljs-comment"># 禁用防火墙</span><br>service firewalld <span class="hljs-literal">start</span>  <span class="hljs-comment"># 开启firewall service服务</span><br>service firewalld restart  <span class="hljs-comment"># 重启firewall service服务</span><br>service firewalld <span class="hljs-literal">stop</span>  <span class="hljs-comment"># 关闭firewall service服务</span><br></code></pre></td></tr></table></figure><h3 id="firewall"><a href="#firewall" class="headerlink" title="firewall"></a>firewall</h3><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">firewall-<span class="hljs-keyword">cmd</span><span class="bash"> --reload  <span class="hljs-comment"># 重启防火墙</span></span><br></code></pre></td></tr></table></figure><p>需要注意的是，对规则修改以后，需要重启防火墙才会生效。</p><h4 id="firewall查询"><a href="#firewall查询" class="headerlink" title="firewall查询"></a>firewall查询</h4><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">firewall-<span class="hljs-keyword">cmd</span><span class="bash"> --state     <span class="hljs-comment"># 查看firewall的状态</span></span><br>firewall-<span class="hljs-keyword">cmd</span><span class="bash"> --list-all   <span class="hljs-comment"># 查看防火墙规则</span></span><br>firewall-<span class="hljs-keyword">cmd</span><span class="bash"> --query-port=8080/tcp  <span class="hljs-comment"># 查询8080端口是否开放TCP</span></span><br></code></pre></td></tr></table></figure><h4 id="firewall修改"><a href="#firewall修改" class="headerlink" title="firewall修改"></a>firewall修改</h4><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">firewall-<span class="hljs-keyword">cmd</span><span class="bash"> --permanent --remove-port=8080/tcp  <span class="hljs-comment"># 移除8080端口TCP规则</span></span><br>firewall-<span class="hljs-keyword">cmd</span><span class="bash"> --permanent --add-port=9527/tcp  <span class="hljs-comment"># 添加9527端口TCP规则</span></span><br><br><span class="hljs-comment"># 参数解释</span><br><span class="hljs-comment">#  firwall-cmd：是Linux提供的操作firewall的一个工具；</span><br><span class="hljs-comment">#  --permanent：表示设置为持久；</span><br><span class="hljs-comment">#  --add-port：标识添加的端口；</span><br></code></pre></td></tr></table></figure><h2 id="安全组-设置在前面的-防火墙"><a href="#安全组-设置在前面的-防火墙" class="headerlink" title="安全组 设置在前面的 防火墙"></a><strong>安全组 设置在前面的 防火墙</strong></h2><p>现在很多云都有设立在服务器之前的防火墙。<br>他们一般被称为<code>安全组</code>。<br><img src="/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2-CentOS-firewall-%E9%98%B2%E7%81%AB%E5%A2%99/20200308043435990.png"><br>这是腾讯云默认的安全组，允许所有Ip和端口的访问。<br><img src="/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2-CentOS-firewall-%E9%98%B2%E7%81%AB%E5%A2%99/20200308043627336.png"><br>你可以根据自己的需要在这上面通过GUI设置一些规则，内容几乎和服务器的防火墙完全相同。<br><img src="/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2-CentOS-firewall-%E9%98%B2%E7%81%AB%E5%A2%99/20200308053129012.png"><br>需要注意的是，安全组 和 服务器自身的防火墙 是相互独立的。<br>也就是说，如果你 在服务器里开放了一个原本没有开放的端口，那么在应用的安全组里也需要开放相同的端口才能正常访问。</p>]]></content>
    
    
    
    <tags>
      
      <tag>服务器</tag>
      
      <tag>CentOS</tag>
      
      <tag>防火墙</tag>
      
      <tag>firewall</tag>
      
      <tag>安全组</tag>
      
      <tag>服务器安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode日常-简单-面试题59 - II. 队列的最大值</title>
    <link href="/post/2a6c49ca/"/>
    <url>/post/2a6c49ca/</url>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a><strong>题目</strong></h2><p>请定义一个队列并实现函数 max_value 得到队列里的最大值.<br>要求函数max_value、push_back 和 pop_front 的时间复杂度都是O(1)。<br>若队列为空，pop_front 和 max_value 需要返回 -1<br>示例 1：</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入: <br>[<span class="hljs-string">&quot;MaxQueue&quot;</span>,<span class="hljs-string">&quot;push_back&quot;</span>,<span class="hljs-string">&quot;push_back&quot;</span>,<span class="hljs-string">&quot;max_value&quot;</span>,<span class="hljs-string">&quot;pop_front&quot;</span>,<span class="hljs-string">&quot;max_value&quot;</span>]<br>[[],[<span class="hljs-number">1</span>],[<span class="hljs-number">2</span>],[],[],[]]<br>输出: [null,null,null,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]<br></code></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入: <br>[<span class="hljs-string">&quot;MaxQueue&quot;</span>,<span class="hljs-string">&quot;pop_front&quot;</span>,<span class="hljs-string">&quot;max_value&quot;</span>]<br>[[],[],[]]<br>输出: [null,<span class="hljs-number">-1</span>,<span class="hljs-number">-1</span>]<br></code></pre></td></tr></table></figure><p>限制：<br>&emsp; 1 &lt;= push_back,pop_front,max_value的总操作数 &lt;= 10000<br>&emsp; 1 &lt;= value &lt;= 10^5</p><h2 id="自解"><a href="#自解" class="headerlink" title="自解"></a><strong>自解</strong></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MaxQueue</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        self.queue = <span class="hljs-built_in">list</span>()<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">max_value</span>(<span class="hljs-params">self</span>) -&gt; int:</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(self.queue) <span class="hljs-keyword">if</span> self.queue <span class="hljs-keyword">else</span> -<span class="hljs-number">1</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">push_back</span>(<span class="hljs-params">self, value: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        self.queue.insert(<span class="hljs-number">0</span>,value)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">pop_front</span>(<span class="hljs-params">self</span>) -&gt; int:</span><br>        <span class="hljs-keyword">return</span> self.queue.pop() <span class="hljs-keyword">if</span> self.queue <span class="hljs-keyword">else</span> -<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>没有留意题目的O(1)要求，看到了别人的评论才知道。<br>list.max() 时间复杂度为O(n)，不符合要求。</p><h2 id="大佬解法"><a href="#大佬解法" class="headerlink" title="大佬解法"></a><strong>大佬解法</strong></h2><h3 id="思考过程"><a href="#思考过程" class="headerlink" title="思考过程"></a><strong>思考过程</strong></h3><p>要想在<code>O(1)</code>时间内做到取出最大值，我们可以想到，能否用一个<code>cur_max</code>的变量，来记录并且比较每一次新入队的<code>value</code>。<br>这个想法是极好的，但是如果队列是<code>[4,3]</code>这个样子，<code>cur_max</code>只会记下4是最大的，当调用一次<code>pop_front()</code>后，此时队列为<code>[3]</code>，而<code>cur_max</code>没有变化，所以单个变量记录最大值行不通。</p><p>进一步地我们可以想到，一个变量不行，那我直接用一个辅助队列记录值OK不OK呢？</p><p>答案是OK的。我们让辅助队列的数从大到小排列好，要找最大值直接返回辅助队列的头部即可，同时这也是<code>O(1)</code>时间复杂度的操作，完美契合题意。下面详细讲讲辅助队列怎么能够实现这个操作。</p><h3 id="详细步骤"><a href="#详细步骤" class="headerlink" title="详细步骤"></a><strong>详细步骤</strong></h3><p>我们先初始化两个队列：<br>原始队列que = []，帮助我们记录原始数值。<br>辅助队列sort_que = []，帮助我们对原始数值进行排序。</p><p>对于原始队列<code>que</code>，来一个就装一个，走一个就放一个，没啥好担心的。</p><p>重点是这个辅助队列<code>sort_que</code>。<br>第一个问题：<code>sort_que</code>里面怎么排序？</p><p>要回答这个问题，我们首先要知道，队列的性质是先进先出。</p><p>假设原始队列是<code>[1,2]</code>，那么先走的那一位是队列里面的1。我们的<code>sort_que</code>的头部理应为2，因为原始队列<code>[1,2]</code>的最大值是2。即使对原始队列<code>[1,2]</code>调用<code>pop_front</code>造成1的离开，最大值依然是2，此时，我们仍然需要保持<code>sort_que</code>的头部仍是2。</p><p>这个要求，就衍生出了sort_que队列的怎么排序了，请看代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">while</span> sort_que <span class="hljs-keyword">and</span> sort_que[-<span class="hljs-number">1</span>] &lt; value:<br>    sort_que.pop()<br>self.sort_que.append(value)<br></code></pre></td></tr></table></figure><p>这就是说，如果<code>sort_que</code>不为空，并且<code>sort_que</code>的最后一位元素小于当前入队元素<code>value</code>的话，直接把最后一位元素弹走，直到<code>sort_que</code>为空，或<code>sort_que</code>的最后一位元素大于等于<code>value</code>。这就保证了，<code>sort_que</code>的头部总是原始队列que的最大值~<br>第二个问题：原始队列<code>que</code>发生<code>pop_front</code>时<code>sort_que</code>该怎么变动？</p><p>这个其实比较简单，当<code>que</code>弹出的数恰好等于<code>sort_que</code>的头部元素时，咱把<code>sort_que</code>的头部也跟着弹出就好。请看代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">res = que.pop(<span class="hljs-number">0</span>)<br><span class="hljs-keyword">if</span> res == sort_que[<span class="hljs-number">0</span>]:<br>    sort_que.pop(<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p>我们这里的que和sort_que假设是Python中的list形式，用pop(0)的方法可以弹出list的第一个元素，但这个的时间复杂度是<code>O(n)</code>，这一点要注意。<br><img src="/LeetCode%E6%97%A5%E5%B8%B8-%E7%AE%80%E5%8D%95-%E9%9D%A2%E8%AF%95%E9%A2%9859---II.-%E9%98%9F%E5%88%97%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/20200307122705425.png"><br>Python中的deque可以对<code>pop(0)</code>，就是<code>popleft()</code>实现<code>O(1)</code>的时间复杂度。<br><img src="/LeetCode%E6%97%A5%E5%B8%B8-%E7%AE%80%E5%8D%95-%E9%9D%A2%E8%AF%95%E9%A2%9859---II.-%E9%98%9F%E5%88%97%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/20200307122946910.png"></p><h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a><strong>完整代码</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MaxQueue</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> deque<br>        self.que = deque()<br>        self.sort_que = deque()   <br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">max_value</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">return</span> self.sort_que[<span class="hljs-number">0</span>] <span class="hljs-keyword">if</span> self.sort_que <span class="hljs-keyword">else</span> -<span class="hljs-number">1</span>   <br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">push_back</span>(<span class="hljs-params">self, value</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type value: int</span><br><span class="hljs-string">        :rtype: None</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        self.que.append(value)<br>        <span class="hljs-keyword">while</span> self.sort_que <span class="hljs-keyword">and</span> self.sort_que[-<span class="hljs-number">1</span>] &lt; value:<br>            self.sort_que.pop()<br>        self.sort_que.append(value)<br>        <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">pop_front</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self.que: <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br>        res = self.que.popleft()<br>        <span class="hljs-keyword">if</span> res == self.sort_que[<span class="hljs-number">0</span>]:<br>            self.sort_que.popleft()<br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><hr><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof">https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof</a><br>作者：quantumdriver<br>链接：<a href="https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof/solution/python-xiang-jie-wei-he-tian-jia-fu-zhu-dui-lie-ji/">https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof/solution/python-xiang-jie-wei-he-tian-jia-fu-zhu-dui-lie-ji/</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>LeetCode</tag>
      
      <tag>简单</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode日常-简单-面试题57 - II. 和为s的连续正数序列</title>
    <link href="/post/311370dd/"/>
    <url>/post/311370dd/</url>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a><strong>题目</strong></h2><p>输入一个正整数 target ，输出所有和为 target 的连续正整数序列（至少含有两个数）。<br>序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。<br>示例 1：<br>&emsp; 输入：target = 9<br>&emsp; 输出：[[2,3,4],[4,5]]<br>示例 2：<br>&emsp; 输入：target = 15<br>&emsp; 输出：[[1,2,3,4,5],[4,5,6],[7,8]]<br>限制：<br>    1 &lt;= target &lt;= 10^5</p><h2 id="自解"><a href="#自解" class="headerlink" title="自解"></a><strong>自解</strong></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">findContinuousSequence</span>(<span class="hljs-params">self, target: <span class="hljs-built_in">int</span></span>) -&gt; List[List[int]]:</span><br>    resoult = <span class="hljs-built_in">list</span>()<br>    <span class="hljs-keyword">for</span> left <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, target):<br>        right = left<br>        sum_ = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> sum_ &lt; target:<br>            right = right+<span class="hljs-number">1</span><br>            sum_ = <span class="hljs-built_in">sum</span>(<span class="hljs-built_in">range</span>(left, right))<br>            <span class="hljs-keyword">if</span> sum_ == target:<br>                resoult.append(<span class="hljs-built_in">list</span>(<span class="hljs-built_in">range</span>(left,right)))<br>    <span class="hljs-keyword">return</span> resoult<br></code></pre></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a><strong>思路</strong></h3><p>逐个数字遍历，窗口逐个变大。找到相等记录。</p><h2 id="大佬解法"><a href="#大佬解法" class="headerlink" title="大佬解法"></a><strong>大佬解法</strong></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">findContinuousSequence</span>(<span class="hljs-params">self, target: <span class="hljs-built_in">int</span></span>) -&gt; List[List[int]]:</span><br>    i = <span class="hljs-number">1</span> <span class="hljs-comment"># 滑动窗口的左边界</span><br>    j = <span class="hljs-number">1</span> <span class="hljs-comment"># 滑动窗口的右边界</span><br>    <span class="hljs-built_in">sum</span> = <span class="hljs-number">0</span> <span class="hljs-comment"># 滑动窗口中数字的和</span><br>    res = []<br><br>    <span class="hljs-keyword">while</span> i &lt;= target // <span class="hljs-number">2</span>:<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">sum</span> &lt; target:<br>            <span class="hljs-comment"># 右边界向右移动</span><br>            <span class="hljs-built_in">sum</span> += j<br>            j += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">elif</span> <span class="hljs-built_in">sum</span> &gt; target:<br>            <span class="hljs-comment"># 左边界向右移动</span><br>            <span class="hljs-built_in">sum</span> -= i<br>            i += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-comment"># 记录结果</span><br>            arr = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">range</span>(i, j))<br>            res.append(arr)<br>            <span class="hljs-comment"># 左边界向右移动</span><br>            <span class="hljs-built_in">sum</span> -= i<br>            i += <span class="hljs-number">1</span><br><br>    <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a><strong>思路</strong></h3><h4 id="什么是滑动窗口"><a href="#什么是滑动窗口" class="headerlink" title="什么是滑动窗口"></a><strong>什么是滑动窗口</strong></h4><p>滑动窗口可以看成数组中框起来的一个部分。在一些数组类题目中，我们可以用滑动窗口来观察可能的候选结果。当滑动窗口从数组的左边滑到了右边，我们就可以从所有的候选结果中找到最优的结果。<br>对于这道题来说，数组就是正整数序列 [1,2,3,…,n]。我们设滑动窗口的左边界为 i，右边界为 j，则滑动窗口框起来的是一个左闭右开区间 [i,j)[i, j)[i,j)。注意，为了编程的方便，滑动窗口一般表示成一个左闭右开区间。在一开始，i=1, j=1 ,滑动窗口位于序列的最左侧，窗口大小为零。<br><img src="/LeetCode%E6%97%A5%E5%B8%B8-%E7%AE%80%E5%8D%95-%E9%9D%A2%E8%AF%95%E9%A2%9857---II.-%E5%92%8C%E4%B8%BAs%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%AD%A3%E6%95%B0%E5%BA%8F%E5%88%97/20200306021159040.png"><br>滑动窗口的重要性质是：<strong>窗口的左边界和右边界永远只能向右移动</strong>，而不能向左移动。这是为了保证滑动窗口的时间复杂度是 O(n)。如果左右边界向左移动的话，这叫做“回溯”，算法的时间复杂度就可能不止 O(n)。</p><p>在这道题中，我们关注的是滑动窗口中所有数的和。<br>当滑动窗口的右边界向右移动时，也就是 j = j + 1，窗口中多了一个数字 j，窗口的和也就要加上 j。<br>当滑动窗口的左边界向右移动时，也就是 i = i + 1，窗口中少了一个数字 i，窗口的和也就要减去 i。<br><strong>滑动窗口只有 右边界向右移动（扩大窗口） 和 左边界向右移动（缩小窗口）</strong> 两个操作，所以实际上非常简单。</p><h4 id="如何用滑动窗口解这道题"><a href="#如何用滑动窗口解这道题" class="headerlink" title="如何用滑动窗口解这道题"></a><strong>如何用滑动窗口解这道题</strong></h4><p>要用滑动窗口解这道题，我们要回答两个问题：<br>&emsp; 第一个问题，窗口何时扩大，何时缩小？<br>&emsp; 第二个问题，滑动窗口能找到全部的解吗？</p><h5 id="第一个问题，窗口何时扩大，何时缩小？"><a href="#第一个问题，窗口何时扩大，何时缩小？" class="headerlink" title="第一个问题，窗口何时扩大，何时缩小？"></a><strong>第一个问题，窗口何时扩大，何时缩小？</strong></h5><p>&emsp; 当窗口的和小于 target 的时候，窗口的和需要增加，所以要扩大窗口，窗口的右边界向右移动<br>&emsp; 当窗口的和大于 target 的时候，窗口的和需要减少，所以要缩小窗口，窗口的左边界向右移动<br>&emsp; 当窗口的和恰好等于 target 的时候，我们需要记录此时的结果。设此时的窗口为 [i,j)，那么我们已经找到了一个 i 开头的序列，也是唯一一个 i 开头的序列，接下来需要找 i+1 开头的序列，所以窗口的左边界要向右移动</p><h5 id="第二个问题，滑动窗口能找到全部的解吗？"><a href="#第二个问题，滑动窗口能找到全部的解吗？" class="headerlink" title="第二个问题，滑动窗口能找到全部的解吗？"></a><strong>第二个问题，滑动窗口能找到全部的解吗？</strong></h5><p><img src="/LeetCode%E6%97%A5%E5%B8%B8-%E7%AE%80%E5%8D%95-%E9%9D%A2%E8%AF%95%E9%A2%9857---II.-%E5%92%8C%E4%B8%BAs%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%AD%A3%E6%95%B0%E5%BA%8F%E5%88%97/20200306111214452.png"><br>&emsp; 我们一开始要找的是 1 开头的序列，只要窗口的和小于 target，窗口的右边界会一直向右移动。<br>&emsp; 假设 1+2+⋯+8 小于 target，再加上一个 9 之后， 发现 1+2+⋯+8+9 又大于 target 了。这说明 1 开头的序列找不到解。此时滑动窗口的最右元素是 9。</p><p>接下来，我们需要找 2 开头的序列，我们发现，2+⋯+8&lt;1+2+⋯+8&lt;target。这说明 2 开头的序列至少要加到 9。那么，我们只需要把原先 1<del>9 的滑动窗口的左边界向右移动，变成 2</del>9 的滑动窗口，然后继续寻找。而右边界完全不需要向左移动。</p><p>以此类推，滑动窗口的左右边界都不需要向左移动，所以这道题用滑动窗口一定可以得到所有的解。时间复杂度是 O(n)O(n)O(n)。</p><p>注：这道题当前可以用等差数列的求和公式来计算滑动窗口的和。不过我这里没有使用求和公式，是为了展示更通用的解题思路。实际上，把题目中的正整数序列换成任意的递增整数序列，这个方法都可以解。</p><h2 id="真·大佬解法"><a href="#真·大佬解法" class="headerlink" title="真·大佬解法"></a><strong>真·大佬解法</strong></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">findContinuousSequence</span>(<span class="hljs-params">self, target: <span class="hljs-built_in">int</span></span>) -&gt; List[List[int]]:</span><br>        res = []<br>        <span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>, target+<span class="hljs-number">1</span>):<br>            temp = target - n*(n-<span class="hljs-number">1</span>)//<span class="hljs-number">2</span><br>            <span class="hljs-keyword">if</span> temp &lt;= <span class="hljs-number">0</span>:<br>                <span class="hljs-keyword">break</span><br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> temp % n:<br>                a_1 = temp // n<br>                res.append([a_1 + i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)])<br>        <span class="hljs-keyword">return</span> res[::-<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><p>O(√target)</p><p>解题思路<br>一个以 a1 为首项，以 1 为公差，以 n 为项数的等差数列的和为 target<br><img src="/LeetCode%E6%97%A5%E5%B8%B8-%E7%AE%80%E5%8D%95-%E9%9D%A2%E8%AF%95%E9%A2%9857---II.-%E5%92%8C%E4%B8%BAs%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%AD%A3%E6%95%B0%E5%BA%8F%E5%88%97/20200306112539983.png"><br>转化为<br><img src="/LeetCode%E6%97%A5%E5%B8%B8-%E7%AE%80%E5%8D%95-%E9%9D%A2%E8%AF%95%E9%A2%9857---II.-%E5%92%8C%E4%B8%BAs%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%AD%A3%E6%95%B0%E5%BA%8F%E5%88%97/20200306112557880.png"><br>目标是找出所有满足条件的 n、a1 对，<br>思路是对 n 从 2 开始遍历（题目要求最少是 222 个数），验证 a1 是否为正整数。<br>有一个问题是 n 遍历到多少呢？<br>其实不需要特地去算 n 的上限，随着 n 的递增，a1 递减，当 a1&lt;=0 时跳出循环即可。</p><hr><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof">https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof</a><br>作者：nettee<br>链接：<a href="https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/solution/shi-yao-shi-hua-dong-chuang-kou-yi-ji-ru-he-yong-h/">https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/solution/shi-yao-shi-hua-dong-chuang-kou-yi-ji-ru-he-yong-h/</a><br>作者：erik_chen<br>链接：<a href="https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/solution/shu-xue-wen-ti-shu-xue-jie-jue-by-erik_chen/">https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/solution/shu-xue-wen-ti-shu-xue-jie-jue-by-erik_chen/</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>LeetCode</tag>
      
      <tag>简单</tag>
      
      <tag>滑动窗口</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode日常-简单-20-有效的括号</title>
    <link href="/post/f21acc01/"/>
    <url>/post/f21acc01/</url>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a><strong>题目</strong></h2><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。<br>有效字符串需满足：</p><ul><li>左括号必须用相同类型的右括号闭合。</li><li>左括号必须以正确的顺序闭合。</li></ul><p>注意空字符串可被认为是有效字符串。</p><h2 id="自解"><a href="#自解" class="headerlink" title="自解"></a><strong>自解</strong></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">isValid</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; bool:</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-string">&quot;()&quot;</span> <span class="hljs-keyword">in</span> s <span class="hljs-keyword">or</span> <span class="hljs-string">&quot;&#123;&#125;&quot;</span><span class="hljs-keyword">in</span> s <span class="hljs-keyword">or</span> <span class="hljs-string">&quot;[]&quot;</span><span class="hljs-keyword">in</span> s:<br>        s = s.replace(<span class="hljs-string">&quot;()&quot;</span>,<span class="hljs-string">&quot;&quot;</span>)<br>        s = s.replace(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>,<span class="hljs-string">&quot;&quot;</span>)<br>        s = s.replace(<span class="hljs-string">&quot;[]&quot;</span>,<span class="hljs-string">&quot;&quot;</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">not</span> s<br></code></pre></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a><strong>思路</strong></h3><p>如果是合理的字符组合（不为空）。<br>那么这个字符串只有两种情况：</p><ul><li>字符串长度&gt;0, 且必定存在必定存在子串’{}’或’()’或’[]’<br>  这种情况下，对子串’{}’或’()’或’[]’进行去除，能得到缩小了的同问题。<br>  不断重复去除的过程最终能使字符串长度==0.</li><li>字符串长度==0</li></ul><p>时间复杂度：O(n²)</p><h2 id="官方解法"><a href="#官方解法" class="headerlink" title="官方解法"></a><strong>官方解法</strong></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">isValid</span>(<span class="hljs-params">self, s</span>):</span><br>        <span class="hljs-comment"># 设置一个堆栈跟踪开括号</span><br>        stack = []<br><br>        <span class="hljs-comment"># 哈希表 记录对应关系。这使得代码看起来非常干净。</span><br>        <span class="hljs-comment"># 也使得增加更多类型的括号更容易</span><br>        mapping = &#123;<span class="hljs-string">&quot;)&quot;</span>: <span class="hljs-string">&quot;(&quot;</span>, <span class="hljs-string">&quot;&#125;&quot;</span>: <span class="hljs-string">&quot;&#123;&quot;</span>, <span class="hljs-string">&quot;]&quot;</span>: <span class="hljs-string">&quot;[&quot;</span>&#125;<br><br>        <span class="hljs-comment"># 遍历每个字符</span><br>        <span class="hljs-keyword">for</span> char <span class="hljs-keyword">in</span> s:<br>            <span class="hljs-comment"># 如果是闭括号</span><br>            <span class="hljs-keyword">if</span> char <span class="hljs-keyword">in</span> mapping:<br>                <span class="hljs-comment"># 如果栈非空，弹出最顶层元素</span><br>                <span class="hljs-comment"># 否则将虚值&quot;#&quot;赋值给top_element</span><br>                top_element = stack.pop() <span class="hljs-keyword">if</span> stack <span class="hljs-keyword">else</span> <span class="hljs-string">&#x27;#&#x27;</span><br>                <span class="hljs-comment"># 根据哈希表获取对应符号，如不符合对应，返回False</span><br>                <span class="hljs-keyword">if</span> mapping[char] != top_element:<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-comment"># 是开括号，压入栈中</span><br>                stack.append(char)<br><br>        <span class="hljs-comment"># 如果在最后，栈是空的，那么匹配正确。</span><br>        <span class="hljs-comment"># 如果栈不是空的，是出现了开括号多于闭括号的情况，如((()</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">not</span> stack<br></code></pre></td></tr></table></figure><p>时间复杂度：O(n)O(n)O(n)，因为我们一次只遍历给定的字符串中的一个字符并在栈上进行 O(1)O(1)O(1) 的推入和弹出操作。</p><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a><strong>算法</strong></h3><ol><li>初始化栈 S。</li><li>一次处理表达式的每个括号。</li><li>如果遇到开括号，我们只需将其推到栈上即可。这意味着我们将稍后处理它，让我们简单地转到前面的 子表达式。</li><li>如果我们遇到一个闭括号，那么我们检查栈顶的元素。如果栈顶的元素是一个 相同类型的 左括号，那么我们将它从栈中弹出并继续处理。否则，这意味着表达式无效。</li><li>如果到最后我们剩下的栈中仍然有元素，那么这意味着表达式无效。</li></ol><hr><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/valid-parentheses">https://leetcode-cn.com/problems/valid-parentheses</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>LeetCode</tag>
      
      <tag>简单</tag>
      
      <tag>栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SQL记录</title>
    <link href="/post/e1a4d6bf/"/>
    <url>/post/e1a4d6bf/</url>
    
    <content type="html"><![CDATA[<h1 id="基本语句"><a href="#基本语句" class="headerlink" title="基本语句"></a>基本语句</h1><h2 id="查"><a href="#查" class="headerlink" title="查"></a>查</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> 列名称 <span class="hljs-keyword">FROM</span> 表名称<br></code></pre></td></tr></table></figure><h2 id="增"><a href="#增" class="headerlink" title="增"></a>增</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> table_name (列<span class="hljs-number">1</span>, 列<span class="hljs-number">2</span>,...) <span class="hljs-keyword">VALUES</span> (值<span class="hljs-number">1</span>, 值<span class="hljs-number">2</span>,....)<br></code></pre></td></tr></table></figure><h2 id="删"><a href="#删" class="headerlink" title="删"></a>删</h2><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> 表名称 <span class="hljs-keyword">WHERE</span> 列名称 = 值<br></code></pre></td></tr></table></figure><h2 id="改"><a href="#改" class="headerlink" title="改"></a>改</h2><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">UPDATE</span> 表名称 <span class="hljs-keyword">SET</span> 列名称 = 新值 <span class="hljs-keyword">WHERE</span> 列名称 = 某值<br></code></pre></td></tr></table></figure><h1 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h1><h2 id="逻辑判断"><a href="#逻辑判断" class="headerlink" title="逻辑判断"></a>逻辑判断</h2><h3 id="IF"><a href="#IF" class="headerlink" title="IF"></a>IF</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">IF</span><span class="hljs-params">(判断语句, 判断结果为True时的返回值, 判断结果为False时的返回值)</span></span><br></code></pre></td></tr></table></figure><ul><li>返回值为数字值或字符串值  </li></ul><blockquote><p>案例：将salary表中的记录性别进行更变<br><img src="/SQL%E8%AE%B0%E5%BD%95/20200902114505313.png">  </p></blockquote><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gams">update salary <span class="hljs-keyword">set</span> <br>    sex <span class="hljs-comment">= IF(sex=</span><span class="hljs-comment">&#x27;f&#x27;</span><span class="hljs-comment">,</span><span class="hljs-comment">&#x27;m&#x27;</span><span class="hljs-comment">,</span><span class="hljs-comment">&#x27;f&#x27;</span><span class="hljs-comment">)</span>;<br></code></pre></td></tr></table></figure><h3 id="CASE"><a href="#CASE" class="headerlink" title="CASE"></a>CASE</h3><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">CASE</span> 判断目标 <span class="hljs-keyword">WHEN</span> 所期望的值 <span class="hljs-keyword">THEN</span> 目标是期望值时所执行内容 <span class="hljs-keyword">ELSE</span> 目标不是期望值时所执行内容 <span class="hljs-keyword">END</span><br></code></pre></td></tr></table></figure><ul><li>如果没有ELSE 部分，则返回值为 NULL</li></ul><blockquote><p>案例：将salary表中的记录性别进行更变<br><img src="/SQL%E8%AE%B0%E5%BD%95/20200902114505313.png">  </p></blockquote><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">UPDATE</span> salary<br><span class="hljs-keyword">SET</span><br>    sex = <span class="hljs-keyword">CASE</span> sex<br>        <span class="hljs-keyword">WHEN</span> <span class="hljs-string">&#x27;m&#x27;</span> <span class="hljs-keyword">THEN</span> <span class="hljs-string">&#x27;f&#x27;</span><br>        <span class="hljs-keyword">ELSE</span> <span class="hljs-string">&#x27;m&#x27;</span><br>    <span class="hljs-keyword">END</span>;<br></code></pre></td></tr></table></figure><h1 id="多表"><a href="#多表" class="headerlink" title="多表"></a>多表</h1><h2 id="JOIN"><a href="#JOIN" class="headerlink" title="JOIN"></a>JOIN</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span><br>     column_name<br><span class="hljs-keyword">FROM</span> Table_name1  <span class="hljs-keyword">JOIN</span> Table_name2 <br>     <span class="hljs-keyword">ON</span> 连接条件<br></code></pre></td></tr></table></figure><ul><li>符合连接条件的内容才会连接  </li></ul><blockquote><p>案例<br>Employee 表包含所有员工，他们的经理也属于员工。每个员工都有一个 Id，此外还有一列对应员工的经理的 Id<br>Employee 表<br><img src="/SQL%E8%AE%B0%E5%BD%95/20200903010508843.png"><br>编写一个 SQL 查询，该查询可以获取收入超过他们经理的员工的姓名   </p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span><br>     a.NAME <span class="hljs-keyword">AS</span> Employee<br><span class="hljs-keyword">FROM</span> Employee <span class="hljs-keyword">AS</span> a <span class="hljs-keyword">JOIN</span> Employee <span class="hljs-keyword">AS</span> b<br>     <span class="hljs-keyword">ON</span> a.ManagerId = b.Id <span class="hljs-keyword">AND</span> a.Salary &gt; b.Salary<br><br></code></pre></td></tr></table></figure><ul><li>INNER JOIN：如果表中有至少一个匹配，则返回行</li><li>LEFT JOIN：即使右表中没有匹配，也从左表返回所有的行</li><li>RIGHT JOIN：即使左表中没有匹配，也从右表返回所有的行</li><li>FULL JOIN：只要其中一个表中存在匹配，则返回行</li></ul><h3 id="LEFT-JOIN"><a href="#LEFT-JOIN" class="headerlink" title="LEFT JOIN"></a>LEFT JOIN</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> column_name(s)<br><span class="hljs-keyword">FROM</span> table_name1<br><span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> table_name2 <br><span class="hljs-keyword">ON</span> table_name1.column_name=table_name2.column_name<br></code></pre></td></tr></table></figure><ul><li>即使右表中没有匹配，也从左表返回所有的行</li></ul><blockquote><p>案例<br>查询两个表提供的FirstName, LastName, City, State<br>Person表<br><img src="/SQL%E8%AE%B0%E5%BD%95/20200903121741885.png"><br>　PersonId 是主键  </p></blockquote><blockquote><p>Address表<br><img src="/SQL%E8%AE%B0%E5%BD%95/20200903121900913.png"></p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> FirstName, LastName, City, State <br><span class="hljs-keyword">from</span> Person <span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> Address <span class="hljs-keyword">on</span> Person.PersonId = Address.PersonId;<br></code></pre></td></tr></table></figure><h1 id="处理"><a href="#处理" class="headerlink" title="处理"></a>处理</h1><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h3 id="ORDER-BY"><a href="#ORDER-BY" class="headerlink" title="ORDER BY"></a>ORDER BY</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">column_name</span>, <span class="hljs-built_in">column_name</span><br><span class="hljs-keyword">FROM</span> <span class="hljs-built_in">table_name</span><br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> 用作排序的列名, 第二个用作排序的列名 <span class="hljs-keyword">ASC</span>|<span class="hljs-keyword">DESC</span>;<br></code></pre></td></tr></table></figure><ul><li>升序<code>ASC</code> |  降序<code>DESC</code>  </li></ul><blockquote><p>案例<br>编写一个 SQL查询，找出所有影片描述为非 boring (不无聊) 的并且 id 为奇数 的影片，结果请按等级 rating 排列<br>cinema表<br><img src="/SQL%E8%AE%B0%E5%BD%95/20200903123854198.png">  </p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> cinema <br><span class="hljs-keyword">where</span> <span class="hljs-keyword">mod</span>(<span class="hljs-keyword">id</span>, <span class="hljs-number">2</span>)=<span class="hljs-number">1</span> <span class="hljs-keyword">and</span> description != <span class="hljs-string">&quot;boring&quot;</span>  <br><span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> rating <span class="hljs-keyword">DESC</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>SQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HexoEditor-Hexo-编辑文章</title>
    <link href="/post/2adc9a5f/"/>
    <url>/post/2adc9a5f/</url>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>这是一款为 <code>Hexo</code> 做了优化的 <code>Markdown</code> 编辑器。<br>使用 <code>Electron</code> 做框架, 修改自 <code>Moeditor</code>。<br>为更好的去为 <code>Hexo</code> 下的博客更好的去书写内容而造。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p><a href="https://github.com/zhuzhuyule/HexoEditor/releases">https://github.com/zhuzhuyule/HexoEditor/releases</a><br>下载对应的系统版本的安装包安装即可。</p><h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><p>先打开软件的菜单<br><img src="/HexoEditor-Hexo-%E7%BC%96%E8%BE%91%E6%96%87%E7%AB%A0/20200228115836813.png"><br>打开软件的设置<br><img src="/HexoEditor-Hexo-%E7%BC%96%E8%BE%91%E6%96%87%E7%AB%A0/20200228115917978.png"><br>在配置中设置好<code>Hexo</code>的信息<br><img src="/HexoEditor-Hexo-%E7%BC%96%E8%BE%91%E6%96%87%E7%AB%A0/20200228115943222.png"><br>在编写好内容后，在页面点击鼠标右键，即可显示一些hexo相关的操作项目。<br><img src="/HexoEditor-Hexo-%E7%BC%96%E8%BE%91%E6%96%87%E7%AB%A0/20200229120204467.png"><br>但实测下来，通过这种方式执行Hexo相关的操作速度比较慢，比直接在命令行里输入对应的指令慢几倍。</p><hr><p>Github地址：<a href="https://github.com/zhuzhuyule/HexoEditor">https://github.com/zhuzhuyule/HexoEditor</a><br>中文文档：<a href="https://github.com/zhuzhuyule/HexoEditor/blob/master/doc/cn/README.md">https://github.com/zhuzhuyule/HexoEditor/blob/master/doc/cn/README.md</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>npm</tag>
      
      <tag>Blog</tag>
      
      <tag>HexoEditor</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo-toc插件-恢复Markdown失效的toc</title>
    <link href="/post/473a65e7/"/>
    <url>/post/473a65e7/</url>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a><strong>简介</strong></h2><p>总所周知，<code>toc</code> 被用于在<code>markdown</code>文件中自动生成目录。<br>而在某次 npm 更新后，hexo中的 markdown 文件的toc失效了。<br>所以如果你如果希望继续使用 <code>toc</code>，就需要安装这个插件了。</p><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a><strong>使用方法</strong></h2><h3 id="1-安装hexo-toc"><a href="#1-安装hexo-toc" class="headerlink" title="1. 安装hexo-toc"></a><strong>1. 安装hexo-toc</strong></h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">npm <span class="hljs-keyword">install</span> hexo-toc <span class="hljs-comment">--save</span><br></code></pre></td></tr></table></figure><h3 id="2-在-config-yml文件中添加参数"><a href="#2-在-config-yml文件中添加参数" class="headerlink" title="2. 在_config.yml文件中添加参数"></a><strong>2. 在<code>_config.yml</code>文件中添加参数</strong></h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">toc:</span><br>  <span class="hljs-attr">maxdepth:</span> <span class="hljs-number">3</span><br>  <span class="hljs-attr">class:</span> <span class="hljs-string">toc</span><br>  <span class="hljs-attr">slugify:</span> <span class="hljs-string">transliteration</span><br>  <span class="hljs-attr">decodeEntities:</span> <span class="hljs-literal">false</span><br>  <span class="hljs-attr">anchor:</span><br>    <span class="hljs-attr">position:</span> <span class="hljs-string">after</span><br>    <span class="hljs-attr">symbol:</span> <span class="hljs-string">&#x27;#&#x27;</span><br>    <span class="hljs-attr">style:</span> <span class="hljs-string">header-anchor</span><br></code></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>意义</th></tr></thead><tbody><tr><td>maxdepth</td><td>允许的最大节点深度，必填</td></tr><tr><td>class</td><td>toc的CSS样式设置（默认值是<code>false</code>）</td></tr><tr><td>slugify</td><td>选择你想要的slugify方法，目前只有<code>uslug</code>（默认）和<code>transliteration</code>两种</td></tr><tr><td>decodeEntities</td><td>是否要编译内容，具体<a href="https://github.com/bubkoo/hexo-toc/pull/15">看这</a></td></tr><tr><td>anchor</td><td>锚点相关的内容，默认是<code>false</code></td></tr><tr><td>position</td><td>锚点相对于标题的位置设置，可选<code>before</code>或<code>after</code>(默认)</td></tr><tr><td>symbol</td><td>锚点的代表字符（默认是<code>#</code>）</td></tr><tr><td>style</td><td>锚点的CSS样式类，默认是<code>header-anchor</code></td></tr></tbody></table><h3 id="3-在markdown文档中使用toc"><a href="#3-在markdown文档中使用toc" class="headerlink" title="3. 在markdown文档中使用toc"></a><strong>3. 在markdown文档中使用<code>toc</code></strong></h3><p>在需要使用到toc的地方输入：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- toc --&gt;</span><br></code></pre></td></tr></table></figure><hr><p>Hexo-toc Github：<a href="https://github.com/bubkoo/hexo-toc">https://github.com/bubkoo/hexo-toc</a></p><hr><p>参考：<br><a href="https://imys.net/20150514/hexo-toc.html">https://imys.net/20150514/hexo-toc.html</a><br><a href="https://www.colabug.com/2018/1022/4979695/">https://www.colabug.com/2018/1022/4979695/</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>npm</tag>
      
      <tag>Blog</tag>
      
      <tag>Hexo-toc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo-Github-建立自己的博客</title>
    <link href="/post/46c185af/"/>
    <url>/post/46c185af/</url>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a><strong>环境</strong></h2><ul><li>win10 专业版</li><li>git环境</li><li>npm环境</li></ul><h2 id="条件"><a href="#条件" class="headerlink" title="条件"></a><strong>条件</strong></h2><p>github账户（拥有SSH秘钥）</p><h2 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a><strong>使用步骤</strong></h2><h3 id="1-在github上创建一个仓库"><a href="#1-在github上创建一个仓库" class="headerlink" title="1. 在github上创建一个仓库"></a><strong>1. 在github上创建一个仓库</strong></h3><h3 id="2-安装hexo"><a href="#2-安装hexo" class="headerlink" title="2. 安装hexo"></a><strong>2. 安装hexo</strong></h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">npm <span class="hljs-keyword">install</span> -g hexo<br></code></pre></td></tr></table></figure><h3 id="3-初始化hexo"><a href="#3-初始化hexo" class="headerlink" title="3. 初始化hexo"></a><strong>3. 初始化hexo</strong></h3><p>在一个你想要存放博客的文件的地方打开CMD</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp">hexo <span class="hljs-keyword">init</span><br></code></pre></td></tr></table></figure><p>命令执行后会生成很多的文件，暂时无需理会，继续于CMD中输入</p><h3 id="4-第一次测试"><a href="#4-第一次测试" class="headerlink" title="4. 第一次测试"></a><strong>4. 第一次测试</strong></h3><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">hexo g</span> <br><span class="hljs-attribute">hexo s</span><br></code></pre></td></tr></table></figure><p>在最后一个命令输入完后，会提示一个地址。<br>你可以将这个地址输入到浏览器中，在浏览器中查看当前博客的样子。</p><h3 id="5-下载主题"><a href="#5-下载主题" class="headerlink" title="5. 下载主题"></a><strong>5. 下载主题</strong></h3><p>官方自带的博客样式并不是我所喜欢的，你可以在各种样式不同的主题中选择一种你喜欢的。<br>各类主题浏览：<a href="https://hexo.io/themes/">https://hexo.io/themes/</a><br>在主题的浏览页，你会看到作者留下的 这个主题的 安装代码。<br>类似于这种：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">git clone https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/Shen-Yu/</span>hexo-theme-ayer.git themes/ayer<br></code></pre></td></tr></table></figure><p>将这个码输入到CMD中，系统会从作者的 仓库里将主题克隆下来。<br>等待git工作完毕后，再次在CMD中输入命令测试效果。</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">hexo g</span> <br><span class="hljs-attribute">hexo s</span><br></code></pre></td></tr></table></figure><h3 id="6-设置配置文件"><a href="#6-设置配置文件" class="headerlink" title="6. 设置配置文件"></a><strong>6. 设置配置文件</strong></h3><p>在hexo的根目录，会有一个<code>_config.yml</code>文件。<br>你可以用诸如 notepad++ 之类文档工具打开。<br>打开以后找到deploy项进行修改。</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">deploy</span><br></code></pre></td></tr></table></figure><p>:-: ↓</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-attribute">deploy</span>:<br>  <span class="hljs-attribute">type</span>: <span class="hljs-string">&#x27;git&#x27;</span><br>  <span class="hljs-attribute">repository</span>: 在github中创建的仓库的ssh<br>  <span class="hljs-attribute">branch</span>: master<br></code></pre></td></tr></table></figure><p>类似的，找到 url 项与 root项 进行修改。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-attr">url:</span> <span class="hljs-attr">http:</span><span class="hljs-comment">//yoursite.com</span><br><span class="hljs-attr">root:</span> <br></code></pre></td></tr></table></figure><p>:-: ↓</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-attr">url:</span> <span class="hljs-attr">http:</span><span class="hljs-comment">//yoursite.com/创建的仓库的名称</span><br><span class="hljs-attr">root:</span> <span class="hljs-regexp">/创建的仓库的名称/</span><br></code></pre></td></tr></table></figure><p>保存修改后的文件。</p><h3 id="7-安装git插件"><a href="#7-安装git插件" class="headerlink" title="7. 安装git插件"></a><strong>7. 安装git插件</strong></h3><p>在CMD中输入</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">npm <span class="hljs-keyword">install</span> hexo-deployer-git<br></code></pre></td></tr></table></figure><h3 id="8-上传到github"><a href="#8-上传到github" class="headerlink" title="8. 上传到github"></a><strong>8. 上传到github</strong></h3><p>在CMD中输入</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">hexo g</span><br><span class="hljs-attribute">hexo d</span><br></code></pre></td></tr></table></figure><p>将文件上传到 github 仓库中</p><h3 id="9-github设置展示"><a href="#9-github设置展示" class="headerlink" title="9. github设置展示"></a><strong>9. github设置展示</strong></h3><p>在github仓库页面，进入仓库设置页面。<br><img src="/Hexo-Github-%E5%BB%BA%E7%AB%8B%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/20200228070314638.png"><br>在仓库设置页面中找到  GitHub Pages 项，将页面设置为基于 master 节点<br><img src="/Hexo-Github-%E5%BB%BA%E7%AB%8B%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/20200228070434020.png"><br>会到仓库首页，找到environment项<br><img src="/Hexo-Github-%E5%BB%BA%E7%AB%8B%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/20200228070446150.png"><br>在其中查看博客。</p><h3 id="10-博客参数修改"><a href="#10-博客参数修改" class="headerlink" title="10. 博客参数修改"></a><strong>10. 博客参数修改</strong></h3><p>参考主题作者的文档。再修改参数之后，再次上传即可<br>这份文档一般在 <code>/hexo目录/theme/主题名字/_config.yml</code></p><hr><p>Hexo官方文档：<a href="https://hexo.io/zh-cn/docs/">https://hexo.io/zh-cn/docs/</a></p><h2 id="额外的技巧"><a href="#额外的技巧" class="headerlink" title="额外的技巧"></a><strong>额外的技巧</strong></h2><h3 id="每次发布后需要在github上重新域名的解决方法"><a href="#每次发布后需要在github上重新域名的解决方法" class="headerlink" title="每次发布后需要在github上重新域名的解决方法"></a><strong>每次发布后需要在github上重新域名的解决方法</strong></h3><p><code>博客目录/source/</code>下用新建一个txt文件。<br>打开编辑后，写下你的域名，如：<br><img src="/Hexo-Github-%E5%BB%BA%E7%AB%8B%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/20200308041542247.png"><br>保存后，将文件名改为CNAME即可（不需要扩展名）。<br><img src="/Hexo-Github-%E5%BB%BA%E7%AB%8B%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/20200308041624052.png"></p><h2 id="一键发布到github的脚本"><a href="#一键发布到github的脚本" class="headerlink" title="一键发布到github的脚本"></a><strong>一键发布到github的脚本</strong></h2><p>实际上只是建立一个批处理命令文件罢了<br>能节约不少时间，搞搞也无妨</p><ol><li>在博客目录下建立一个txt文件</li><li>打开新建的txt文件，写入<figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sas">hexo clean <span class="hljs-variable">&amp;&amp;</span> hexo g <span class="hljs-variable">&amp;&amp;</span> hexo d<br>pause<br></code></pre></td></tr></table></figure></li><li>保存，然后将后缀名改为.bat<br>文件名你可以自己改，不影响的</li></ol><p>以后要发布到Github就打开这个批处理脚本就好了</p><hr><p>参考：<br><a href="https://segmentfault.com/a/1190000017986794">https://segmentfault.com/a/1190000017986794</a><br><a href="https://www.cnblogs.com/SUNYZBlog/p/10772712.html">https://www.cnblogs.com/SUNYZBlog/p/10772712.html</a><br><a href="https://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html">https://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>npm</tag>
      
      <tag>Blog</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
